{
  "faq_version": "1.0",
  "generated_date": "2026-02-11",
  "source_textbook": "AP Computer Science (Python Version)",
  "total_questions": 45,
  "questions": [
    {
      "id": "faq-001",
      "category": "Getting Started",
      "question": "What is this course about?",
      "answer": "This course is a full AP-style introduction to computer science using Python. You will learn how to break problems into smaller parts, design algorithms, and build maintainable programs with functions, data structures, and objects. The scope matches a first university CS course while using Python's readable syntax. Start with the official overview in [Course Description](course-description.md) and the chapter roadmap in [Chapters](chapters/index.md).",
      "bloom_level": "Remember",
      "difficulty": "easy",
      "concepts": [
        "Computer Science",
        "Algorithms",
        "Functions"
      ],
      "keywords": [
        "course",
        "about"
      ],
      "source_links": [
        "course-description.md",
        "chapters/index.md"
      ],
      "has_example": false,
      "word_count": 68
    },
    {
      "id": "faq-002",
      "category": "Getting Started",
      "question": "Who is this course designed for?",
      "answer": "The primary audience is students in grades 10-12 who want a rigorous, college-level computer science experience. It also fits self-learners preparing for CS1 courses that use Python. You do not need prior programming experience, but you should be comfortable with algebra and logical reasoning. The intended audience and readiness expectations are listed in [Course Description](course-description.md).",
      "bloom_level": "Understand",
      "difficulty": "easy",
      "concepts": [
        "Computer Science"
      ],
      "keywords": [
        "who",
        "course",
        "designed"
      ],
      "source_links": [
        "course-description.md"
      ],
      "has_example": false,
      "word_count": 61
    },
    {
      "id": "faq-003",
      "category": "Getting Started",
      "question": "What background knowledge should I have before starting?",
      "answer": "You should have completed Algebra I (Algebra II recommended), be comfortable with basic computer use, and be ready for structured problem solving. Prior coding helps but is not required because early chapters cover fundamentals from the ground up. If you are unsure, review [Chapter 1: Intro to Computer Science](chapters/01-intro-to-computer-science/index.md) and [Chapter 2: Python Fundamentals](chapters/02-python-fundamentals/index.md) before moving on.",
      "bloom_level": "Remember",
      "difficulty": "easy",
      "concepts": [
        "Computer Science",
        "Problem Solving"
      ],
      "keywords": [
        "background",
        "knowledge",
        "have",
        "before",
        "starting"
      ],
      "source_links": [
        "chapters/01-intro-to-computer-science/index.md",
        "chapters/02-python-fundamentals/index.md"
      ],
      "has_example": false,
      "word_count": 71
    },
    {
      "id": "faq-004",
      "category": "Getting Started",
      "question": "How should I move through the chapters?",
      "answer": "Use a dependency-first order: fundamentals, logic, control flow, functions, data structures, then software engineering and analysis. This sequence mirrors the learning graph and helps you avoid learning advanced ideas without prerequisites. A practical plan is one chapter per week with short daily coding practice. Use [Learning Graph Overview](learning-graph/index.md) and [Chapters](chapters/index.md) to track sequence.",
      "bloom_level": "Understand",
      "difficulty": "easy",
      "concepts": [
        "Control Flow",
        "Functions"
      ],
      "keywords": [
        "move",
        "through",
        "chapters"
      ],
      "source_links": [
        "learning-graph/index.md",
        "chapters/index.md"
      ],
      "has_example": false,
      "word_count": 61
    },
    {
      "id": "faq-005",
      "category": "Getting Started",
      "question": "How much time should I plan each week?",
      "answer": "Plan about 4-6 hours per week for reading, coding, and review. A balanced split is 2 hours reading, 2-3 hours coding exercises, and 1 hour for recap and debugging practice. If a chapter introduces a difficult topic like recursion or algorithm analysis, add extra practice time. Review chapter pacing in [Chapters](chapters/index.md) and outcomes in [Course Description](course-description.md).",
      "bloom_level": "Remember",
      "difficulty": "easy",
      "concepts": [
        "Recursion",
        "Debugging"
      ],
      "keywords": [
        "much",
        "time",
        "plan",
        "each",
        "week"
      ],
      "source_links": [
        "chapters/index.md",
        "course-description.md"
      ],
      "has_example": false,
      "word_count": 64
    },
    {
      "id": "faq-006",
      "category": "Getting Started",
      "question": "Do I need special software to complete the course?",
      "answer": "You only need a modern Python 3 installation and a code editor such as VS Code. You can also use the Python REPL for fast experiments before writing scripts. The course does not require expensive tools or specialized hardware. Setup concepts are introduced early in [Chapter 2: Python Fundamentals](chapters/02-python-fundamentals/index.md) and reinforced in [Chapter 1](chapters/01-intro-to-computer-science/index.md).",
      "bloom_level": "Understand",
      "difficulty": "easy",
      "concepts": [
        "Python REPL"
      ],
      "keywords": [
        "need",
        "special",
        "software",
        "complete",
        "course"
      ],
      "source_links": [
        "chapters/02-python-fundamentals/index.md",
        "chapters/01-intro-to-computer-science/index.md"
      ],
      "has_example": false,
      "word_count": 68
    },
    {
      "id": "faq-007",
      "category": "Getting Started",
      "question": "How do MicroSims help me learn?",
      "answer": "MicroSims are focused interactive visual tools that let you test ideas quickly, such as operator behavior, truth tables, or data structure operations. They reduce cognitive load by turning abstract rules into direct feedback. For example, using the truthiness simulator can clarify why a condition evaluates to `True` or `False`. Browse a representative set in [Truthiness Tester](sims/truthiness-tester/index.md) and [Truth Table Builder](sims/truth-table-builder/index.md), then connect them to chapter content in [Chapters](chapters/index.md).",
      "bloom_level": "Remember",
      "difficulty": "easy",
      "concepts": [
        "Truth Tables"
      ],
      "keywords": [
        "microsims",
        "help",
        "learn"
      ],
      "source_links": [
        "sims/truthiness-tester/index.md",
        "sims/truth-table-builder/index.md",
        "chapters/index.md"
      ],
      "has_example": true,
      "word_count": 82
    },
    {
      "id": "faq-008",
      "category": "Getting Started",
      "question": "What should I do if I fall behind?",
      "answer": "First, return to prerequisite chapters and rebuild weak concepts before trying to push ahead. Then use short, daily sessions with one learning target per session, such as loops, slicing, or dictionary traversal. For example, spending 20 minutes writing three small loop exercises is often better than one long cram session. Revisit [Chapter 4: Control Flow](chapters/04-control-flow/index.md) and [Chapter 6: Functions](chapters/06-functions-and-modular-design/index.md) to recover core momentum.",
      "bloom_level": "Understand",
      "difficulty": "easy",
      "concepts": [
        "Control Flow",
        "Loops",
        "Functions"
      ],
      "keywords": [
        "fall",
        "behind"
      ],
      "source_links": [
        "chapters/04-control-flow/index.md",
        "chapters/06-functions-and-modular-design/index.md"
      ],
      "has_example": true,
      "word_count": 77
    },
    {
      "id": "faq-009",
      "category": "Core Concept",
      "question": "What is computational thinking?",
      "answer": "Computational thinking is a problem-solving approach that uses decomposition, abstraction, pattern recognition, and algorithm design. Instead of jumping into code, you define the problem, model it clearly, and choose a repeatable strategy. For example, a grading program becomes smaller tasks: input, validation, calculation, and reporting. The foundational framing appears in [Chapter 1](chapters/01-intro-to-computer-science/index.md) and the concept set in [Concept List](learning-graph/concept-list.md).",
      "bloom_level": "Remember",
      "difficulty": "medium",
      "concepts": [
        "Computational Thinking",
        "Abstraction",
        "Decomposition"
      ],
      "keywords": [
        "computational",
        "thinking"
      ],
      "source_links": [
        "chapters/01-intro-to-computer-science/index.md",
        "learning-graph/concept-list.md"
      ],
      "has_example": true,
      "word_count": 73
    },
    {
      "id": "faq-010",
      "category": "Core Concept",
      "question": "What is an algorithm, and why does it matter?",
      "answer": "An algorithm is a finite, well-defined sequence of steps for solving a problem. Good algorithms produce correct results and scale acceptably as inputs grow. In programming, algorithm quality affects runtime, memory use, and maintainability. For example, choosing binary search over linear search on sorted data can drastically reduce work. See [Chapter 18: Searching and Sorting](chapters/18-searching-and-sorting/index.md) and [Chapter 19: Algorithm Analysis](chapters/19-algorithm-analysis/index.md).",
      "bloom_level": "Understand",
      "difficulty": "medium",
      "concepts": [
        "Algorithms",
        "Linear Search",
        "Binary Search"
      ],
      "keywords": [
        "algorithm",
        "matter"
      ],
      "source_links": [
        "chapters/18-searching-and-sorting/index.md",
        "chapters/19-algorithm-analysis/index.md"
      ],
      "has_example": true,
      "word_count": 74
    },
    {
      "id": "faq-011",
      "category": "Core Concept",
      "question": "How are variables, expressions, and statements different?",
      "answer": "A variable stores a reference to a value, an expression computes a value, and a statement performs an action. `x = 5` is a statement; `x + 2` is an expression; `x` is a variable name bound to data. Keeping these roles distinct helps you reason about program flow and debugging. This distinction is introduced in [Chapter 2](chapters/02-python-fundamentals/index.md) and reinforced in [Chapter 4](chapters/04-control-flow/index.md).",
      "bloom_level": "Apply",
      "difficulty": "medium",
      "concepts": [
        "Variables",
        "Expressions",
        "Statements"
      ],
      "keywords": [
        "variables",
        "expressions",
        "statements",
        "different"
      ],
      "source_links": [
        "chapters/02-python-fundamentals/index.md",
        "chapters/04-control-flow/index.md"
      ],
      "has_example": false,
      "word_count": 73
    },
    {
      "id": "faq-012",
      "category": "Core Concept",
      "question": "What is the relationship between Boolean logic and control flow?",
      "answer": "Boolean expressions drive decision making in `if`, `elif`, and loop conditions. Control flow structures execute different paths depending on truth values, so weak Boolean reasoning leads to incorrect program behavior. For example, misunderstanding `and` versus `or` can invert business rules. Build this connection through [Chapter 3: Boolean Logic](chapters/03-boolean-logic/index.md) and [Chapter 4: Control Flow](chapters/04-control-flow/index.md).",
      "bloom_level": "Analyze",
      "difficulty": "medium",
      "concepts": [
        "Expressions",
        "Boolean Expressions",
        "Control Flow"
      ],
      "keywords": [
        "relationship",
        "between",
        "boolean",
        "logic",
        "control",
        "flow"
      ],
      "source_links": [
        "chapters/03-boolean-logic/index.md",
        "chapters/04-control-flow/index.md"
      ],
      "has_example": true,
      "word_count": 65
    },
    {
      "id": "faq-013",
      "category": "Core Concept",
      "question": "Why are functions central to software design?",
      "answer": "Functions let you encapsulate behavior, reduce duplication, and define clean interfaces between parts of a program. They make code easier to test, document, and reuse. For example, splitting a payroll calculation into small functions enables isolated testing of tax, overtime, and formatting logic. Core function design is covered in [Chapter 6](chapters/06-functions-and-modular-design/index.md) and expanded in [Chapter 16: Software Engineering](chapters/16-software-engineering/index.md).",
      "bloom_level": "Remember",
      "difficulty": "medium",
      "concepts": [
        "Functions",
        "Testing"
      ],
      "keywords": [
        "functions",
        "central",
        "software",
        "design"
      ],
      "source_links": [
        "chapters/06-functions-and-modular-design/index.md",
        "chapters/16-software-engineering/index.md"
      ],
      "has_example": true,
      "word_count": 72
    },
    {
      "id": "faq-014",
      "category": "Core Concept",
      "question": "How do lists, tuples, sets, and dictionaries differ?",
      "answer": "Lists are ordered and mutable, tuples are ordered and immutable, sets are unordered collections of unique values, and dictionaries map keys to values. Choosing correctly improves clarity and performance. For example, use a set for fast membership checks and a dictionary for lookups by identifier. Data structure decisions begin in [Chapter 8: Lists](chapters/08-lists/index.md), [Chapter 10: Tuples and Sets](chapters/10-tuples-and-sets/index.md), and [Chapter 11: Dictionaries](chapters/11-dictionaries/index.md).",
      "bloom_level": "Understand",
      "difficulty": "medium",
      "concepts": [
        "Lists",
        "Tuples",
        "Sets"
      ],
      "keywords": [
        "lists",
        "tuples",
        "sets",
        "dictionaries",
        "differ"
      ],
      "source_links": [
        "chapters/08-lists/index.md",
        "chapters/10-tuples-and-sets/index.md",
        "chapters/11-dictionaries/index.md"
      ],
      "has_example": true,
      "word_count": 79
    },
    {
      "id": "faq-015",
      "category": "Core Concept",
      "question": "What is object-oriented programming in this course?",
      "answer": "Object-oriented programming (OOP) organizes software around classes (blueprints) and objects (instances with state and behavior). It supports encapsulation, reuse, and clearer modeling of real systems. For example, a `Student` class can manage grades and validation methods in one cohesive unit. OOP fundamentals and design choices are presented in [Chapter 12: Classes and Objects](chapters/12-classes-and-objects/index.md) and [Chapter 13: Inheritance and Polymorphism](chapters/13-inheritance-and-polymorphism/index.md).",
      "bloom_level": "Apply",
      "difficulty": "medium",
      "concepts": [
        "Object-Oriented Programming",
        "Classes",
        "Objects"
      ],
      "keywords": [
        "object",
        "oriented",
        "programming",
        "course"
      ],
      "source_links": [
        "chapters/12-classes-and-objects/index.md",
        "chapters/13-inheritance-and-polymorphism/index.md"
      ],
      "has_example": true,
      "word_count": 74
    },
    {
      "id": "faq-016",
      "category": "Core Concept",
      "question": "When should I use recursion instead of iteration?",
      "answer": "Use recursion when a problem has a natural self-similar structure, such as tree traversal or divide-and-conquer decomposition. Use iteration when the logic is linear and state is easy to manage with loops. For example, factorial can be implemented both ways, but recursion may communicate the mathematical definition more directly. Compare tradeoffs in [Chapter 7](chapters/07-higher-order-functions-and-recursion/index.md) and [Chapter 19](chapters/19-algorithm-analysis/index.md).",
      "bloom_level": "Analyze",
      "difficulty": "medium",
      "concepts": [
        "Decomposition",
        "Loops",
        "Functions"
      ],
      "keywords": [
        "use",
        "recursion",
        "instead",
        "iteration"
      ],
      "source_links": [
        "chapters/07-higher-order-functions-and-recursion/index.md",
        "chapters/19-algorithm-analysis/index.md"
      ],
      "has_example": true,
      "word_count": 75
    },
    {
      "id": "faq-017",
      "category": "Core Concept",
      "question": "Why is testing part of learning core concepts?",
      "answer": "Testing validates that your understanding matches actual program behavior, especially around edge cases. It turns assumptions into explicit checks and provides faster feedback than manual inspection alone. For example, unit tests for a function handling empty input can prevent subtle runtime errors later. Practical testing workflows are covered in [Chapter 17: Testing and Debugging](chapters/17-testing-and-debugging/index.md) and supported by error handling in [Chapter 14](chapters/14-errors-and-exceptions/index.md).",
      "bloom_level": "Remember",
      "difficulty": "medium",
      "concepts": [
        "Runtime Errors",
        "Testing",
        "Edge Cases"
      ],
      "keywords": [
        "testing",
        "part",
        "learning",
        "core",
        "concepts"
      ],
      "source_links": [
        "chapters/17-testing-and-debugging/index.md",
        "chapters/14-errors-and-exceptions/index.md"
      ],
      "has_example": true,
      "word_count": 76
    },
    {
      "id": "faq-018",
      "category": "Core Concept",
      "question": "How does the learning graph help with concept dependencies?",
      "answer": "The learning graph models prerequisite relationships so you can study in an order that minimizes confusion. It helps instructors and learners identify gateway concepts such as variables, conditionals, and functions that unlock later topics. For example, attempting object inheritance before class basics usually causes avoidable confusion. Use [Learning Graph](learning-graph/index.md) and [Concept Taxonomy](learning-graph/concept-taxonomy.md) to plan your path.",
      "bloom_level": "Understand",
      "difficulty": "medium",
      "concepts": [
        "Variables",
        "Functions",
        "Inheritance"
      ],
      "keywords": [
        "learning",
        "graph",
        "help",
        "concept",
        "dependencies"
      ],
      "source_links": [
        "learning-graph/index.md",
        "learning-graph/concept-taxonomy.md"
      ],
      "has_example": true,
      "word_count": 65
    },
    {
      "id": "faq-019",
      "category": "Technical Detail",
      "question": "What is short-circuit evaluation?",
      "answer": "Short-circuit evaluation means Python stops evaluating a Boolean expression as soon as the result is determined. In `A and B`, if `A` is `False`, Python does not evaluate `B`. In `A or B`, if `A` is `True`, Python does not evaluate `B`. This can prevent unnecessary computation and avoid runtime errors. See [Chapter 3](chapters/03-boolean-logic/index.md) and glossary definitions in [Glossary](glossary.md).",
      "bloom_level": "Remember",
      "difficulty": "medium",
      "concepts": [
        "Short-Circuit Evaluation",
        "Runtime Errors"
      ],
      "keywords": [
        "short",
        "circuit",
        "evaluation"
      ],
      "source_links": [
        "chapters/03-boolean-logic/index.md",
        "glossary.md"
      ],
      "has_example": false,
      "word_count": 68
    },
    {
      "id": "faq-020",
      "category": "Technical Detail",
      "question": "What is variable scope?",
      "answer": "Scope defines where a variable name is visible and usable. Local variables exist inside functions, while global variables exist at module level. Misunderstanding scope often causes bugs where values appear unchanged or unexpectedly overwritten. For example, assigning inside a function creates a local name unless you intentionally reference module-level state. Scope rules and safe patterns are explained in [Chapter 6](chapters/06-functions-and-modular-design/index.md).",
      "bloom_level": "Understand",
      "difficulty": "medium",
      "concepts": [
        "Variables",
        "Functions",
        "Variable Scope"
      ],
      "keywords": [
        "variable",
        "scope"
      ],
      "source_links": [
        "chapters/06-functions-and-modular-design/index.md"
      ],
      "has_example": true,
      "word_count": 69
    },
    {
      "id": "faq-021",
      "category": "Technical Detail",
      "question": "What is the difference between mutable and immutable types?",
      "answer": "Mutable objects can change after creation, while immutable objects cannot. Lists and dictionaries are mutable; tuples and strings are immutable. This affects side effects, function behavior, and debugging. For example, appending to a list inside a function changes the original object, but modifying a string creates a new object. Review mutability examples in [Chapter 5](chapters/05-working-with-strings/index.md) and [Chapter 8](chapters/08-lists/index.md).",
      "bloom_level": "Apply",
      "difficulty": "medium",
      "concepts": [
        "Lists",
        "Tuples",
        "Dictionaries"
      ],
      "keywords": [
        "difference",
        "between",
        "mutable",
        "immutable",
        "types"
      ],
      "source_links": [
        "chapters/05-working-with-strings/index.md",
        "chapters/08-lists/index.md"
      ],
      "has_example": true,
      "word_count": 70
    },
    {
      "id": "faq-022",
      "category": "Technical Detail",
      "question": "What are list comprehensions, and when should I use them?",
      "answer": "List comprehensions are compact expressions for constructing lists from iterables with optional filtering. They improve readability when the transformation is simple and focused. For example, `[n*n for n in nums if n % 2 == 0]` is concise and clear for creating squared even values. Avoid deeply nested comprehensions that hide intent. Learn style and constraints in [Chapter 8](chapters/08-lists/index.md) and [Chapter 20](chapters/20-advanced-python/index.md).",
      "bloom_level": "Analyze",
      "difficulty": "medium",
      "concepts": [
        "Expressions",
        "Lists"
      ],
      "keywords": [
        "list",
        "comprehensions",
        "use",
        "them"
      ],
      "source_links": [
        "chapters/08-lists/index.md",
        "chapters/20-advanced-python/index.md"
      ],
      "has_example": true,
      "word_count": 72
    },
    {
      "id": "faq-023",
      "category": "Technical Detail",
      "question": "What does Big-O notation describe?",
      "answer": "Big-O describes how time or space requirements grow as input size increases. It does not measure exact runtime; it captures growth trend and scalability. For example, `O(log n)` scales better than `O(n)` as data grows, which is why binary search is preferred on sorted collections. Use Big-O to compare algorithm choices pragmatically. See [Chapter 19: Algorithm Analysis](chapters/19-algorithm-analysis/index.md).",
      "bloom_level": "Remember",
      "difficulty": "medium",
      "concepts": [
        "Binary Search",
        "Big-O Notation"
      ],
      "keywords": [
        "big",
        "notation",
        "describe"
      ],
      "source_links": [
        "chapters/19-algorithm-analysis/index.md"
      ],
      "has_example": true,
      "word_count": 67
    },
    {
      "id": "faq-024",
      "category": "Technical Detail",
      "question": "What is polymorphism in Python?",
      "answer": "Polymorphism means different objects can respond to the same method name in type-specific ways. This supports extensible code by programming to interfaces rather than concrete classes. For example, both `Circle` and `Rectangle` objects can implement an `area()` method while using different formulas internally. This reduces conditional branching in client code. Explore examples in [Chapter 13](chapters/13-inheritance-and-polymorphism/index.md).",
      "bloom_level": "Understand",
      "difficulty": "medium",
      "concepts": [
        "Classes",
        "Objects",
        "Inheritance"
      ],
      "keywords": [
        "polymorphism",
        "python"
      ],
      "source_links": [
        "chapters/13-inheritance-and-polymorphism/index.md"
      ],
      "has_example": true,
      "word_count": 63
    },
    {
      "id": "faq-025",
      "category": "Technical Detail",
      "question": "What is defensive programming?",
      "answer": "Defensive programming is writing code that anticipates bad inputs, invalid states, and misuse. It combines validation, clear errors, and safe defaults to keep software reliable. For example, checking a divisor before division avoids crashes and communicates intent early. Defensive habits are essential for maintainable systems and easier debugging. See [Chapter 14: Errors and Exceptions](chapters/14-errors-and-exceptions/index.md) and [Chapter 17](chapters/17-testing-and-debugging/index.md).",
      "bloom_level": "Apply",
      "difficulty": "medium",
      "concepts": [
        "Errors and Exceptions",
        "Testing",
        "Debugging"
      ],
      "keywords": [
        "defensive",
        "programming"
      ],
      "source_links": [
        "chapters/14-errors-and-exceptions/index.md",
        "chapters/17-testing-and-debugging/index.md"
      ],
      "has_example": true,
      "word_count": 71
    },
    {
      "id": "faq-026",
      "category": "Technical Detail",
      "question": "How do file read and write workflows typically work?",
      "answer": "Typical file workflows use context managers (`with`) to open files safely, process content, and ensure cleanup. Reading often involves line iteration or whole-file parsing; writing usually includes formatting and encoding considerations. For example, writing JSON output requires deterministic keys and robust error handling around malformed data. Core patterns are shown in [Chapter 15: File Input and Output](chapters/15-file-input-and-output/index.md).",
      "bloom_level": "Analyze",
      "difficulty": "medium",
      "concepts": [
        "Context Managers"
      ],
      "keywords": [
        "file",
        "read",
        "write",
        "workflows",
        "typically",
        "work"
      ],
      "source_links": [
        "chapters/15-file-input-and-output/index.md"
      ],
      "has_example": true,
      "word_count": 66
    },
    {
      "id": "faq-027",
      "category": "Technical Detail",
      "question": "Which core terms from the learning graph should I actively master?",
      "answer": "You should prioritize the course's highest-leverage terms so chapter reading and coding practice reinforce each other. A practical approach is to track mastery weekly and validate each term with a tiny code example or short explanation. For example, you can pair one concept like `Loop Patterns` with a script that demonstrates accumulator and counter behavior. Start with this high-value set and use [Glossary](glossary.md) plus [Concept List](learning-graph/concept-list.md) for deeper definitions:\n\n`Computer Science`, `Computational Thinking`, `Algorithms`, `Abstraction`, `Decomposition`, `Pattern Recognition`, `Stepwise Refinement`, `Problem Solving`, `Binary Number System`, `Bits and Bytes`, `Character Encoding`, `ASCII and Unicode`\n\n`Computer Hardware`, `CPU and Memory`, `Input and Output Devices`, `Operating Systems`, `Programming Languages`, `Compiled vs Interpreted`, `Python Language`, `Python Interpreter`, `Python REPL`, `Python Scripts`, `Comments in Code`, `Variables`\n\n`Variable Assignment`, `Variable Naming Rules`, `Data Types`, `Integer Type`, `Float Type`, `Boolean Type`, `String Type`, `Type Function`, `Type Conversion`, `Implicit Type Conversion`, `Explicit Type Casting`, `Arithmetic Operators`\n\n`Integer Division`, `Modulo Operator`, `Operator Precedence`, `String Concatenation`, `String Repetition`, `F-String Formatting`, `Print Function`, `Input Function`, `Multiple Assignment`, `Constants Convention`, `Augmented Assignment`, `Expressions`\n\n`Statements`, `Code Readability`, `Boolean Expressions`, `Comparison Operators`, `Equal and Not Equal`, `Greater and Less Than`, `Logical Operators`, `And Operator`, `Or Operator`, `Not Operator`, `Short-Circuit Evaluation`, `Truthiness and Falsiness`\n\n`Boolean Conversion`, `Chained Comparisons`, `Order of Operations`, `De Morgan's Laws`, `Truth Tables`, `Control Flow`, `Sequential Execution`, `Conditional Statements`, `If Statement`, `If-Else Statement`, `Elif Statement`, `Nested Conditionals`\n\n`Ternary Expression`, `Match Statement`, `Loops`, `For Loop`, `While Loop`, `Range Function`, `Loop Variable`, `Loop Body`, `Infinite Loops`, `Break Statement`, `Continue Statement`, `Nested Loops`\n\n`Loop Patterns`, `Accumulator Pattern`, `Counter Pattern`, `Sentinel Value Pattern`, `Flag Variable Pattern`, `Loop Else Clause`, `String Basics`, `String Indexing`, `Negative Indexing`, `String Slicing`, `Slice Notation`, `String Immutability`\n\n`String Length`, `String Methods`, `Upper and Lower Methods`, `Strip Method`, `Split Method`, `Join Method`, `Find and Replace Methods`, `Startswith and Endswith`, `String Iteration`, `String Comparison`, `Escape Characters`, `Raw Strings`\n\n`Multiline Strings`, `String Formatting`, `Format Method`, `String Validation Methods`, `In Operator for Strings`, `Character Methods`, `String Reversal`, `Functions`, `Function Definition`, `Function Call`, `Parameters`, `Arguments`\n\n`Return Statement`, `Return Values`, `None Type`, `Default Parameters`, `Keyword Arguments`, `Positional Arguments`, `Multiple Return Values`, `Variable Scope`, `Local Variables`, `Global Variables`, `Global Keyword`, `Docstrings`\n\n`Function Documentation`, `Helper Functions`, `Main Function Pattern`, `Name Equals Main`, `Lambda Functions`, `Higher-Order Functions`, `Map Function`, `Filter Function`, `Reduce Function`, `Function Composition`, `Recursion`, `Base Case`\n\n`Recursive Case`",
      "bloom_level": "Remember",
      "difficulty": "medium",
      "concepts": [
        "Computer Science",
        "Computational Thinking",
        "Algorithms"
      ],
      "keywords": [
        "which",
        "core",
        "terms",
        "from",
        "learning",
        "graph"
      ],
      "source_links": [
        "glossary.md",
        "learning-graph/concept-list.md"
      ],
      "has_example": true,
      "word_count": 392
    },
    {
      "id": "faq-028",
      "category": "Technical Detail",
      "question": "Which additional terms should I review to complete concept coverage?",
      "answer": "After mastering the core set, review the following terms to close concept gaps and improve transfer across chapters. For example, pairing each term with one quick code sketch or trace exercise makes retention much stronger than passive reading. Use [Glossary](glossary.md) as your canonical definition source:\n\n`Recursive Call Stack`, `Stack Overflow`, `Recursion vs Iteration`, `Recursive Patterns`, `Memoization`, `List Creation`, `List Indexing`, `List Slicing`, `List Mutability`, `List Methods`, `Append Method`, `Insert Method`\n\n`Remove Method`, `Pop Method`, `Sort Method`, `Reverse Method`, `List Comprehension`, `Nested Lists`, `List of Lists`, `List Traversal`, `For Loop with Lists`, `Enumerate Function`, `List Unpacking`, `Zip Function`\n\n`List Copying`, `Shallow Copy`, `Deep Copy`, `List Concatenation`, `List Repetition`, `In Operator for Lists`, `Index Method`, `Count Method`, `Min Max Sum Functions`, `Len Function for Lists`, `Sorted Function`, `List as Stack`\n\n`List as Queue`, `List Aliasing`, `Identity vs Equality`, `Tuple Creation`, `Tuple Immutability`, `Tuple Packing`, `Tuple Unpacking`, `Named Tuples`, `Tuple Methods`, `Tuples as Keys`, `Tuples vs Lists`, `Set Creation`\n\n`Set Operations`, `Set Union`, `Set Intersection`, `Set Difference`, `Set Symmetric Difference`, `Set Methods`, `Membership Testing`, `Frozenset`, `Removing Duplicates`, `Dictionary Creation`, `Key-Value Pairs`, `Dictionary Access`\n\n\n\nAdditional high-value terms to include in your spaced review set: `Dictionary Methods`, `Get Method`, `Keys Method`, `Values Method`, `Items Method`, `Dictionary Iteration`, `Dictionary Comprehension`, `Nested Dictionaries`, `Default Values`, `Update Method`, `Pop Method for Dicts`, `Dictionary Merging`, `Counting with Dicts`, `Grouping with Dicts`, `Dictionary as Cache`, `Hashable Keys`, `Dict vs List Lookup`, `JSON and Dictionaries`, `OrderedDict`, `DefaultDict`.",
      "bloom_level": "Understand",
      "difficulty": "medium",
      "concepts": [
        "For Loop",
        "Functions",
        "Recursion"
      ],
      "keywords": [
        "which",
        "additional",
        "terms",
        "review",
        "complete",
        "concept"
      ],
      "source_links": [
        "glossary.md"
      ],
      "has_example": true,
      "word_count": 240
    },
    {
      "id": "faq-029",
      "category": "Common Challenges",
      "question": "Why do my loops run forever?",
      "answer": "Infinite loops usually happen when loop conditions never become false or update logic is missing. In `while` loops, verify the variable controlling termination changes each iteration. In `for` loops, logic errors often come from early `continue` or incorrect break conditions. For example, forgetting to increment a counter in `while i < n` causes non-termination. Debug loop state with small prints or a debugger in [Chapter 4](chapters/04-control-flow/index.md).",
      "bloom_level": "Understand",
      "difficulty": "medium",
      "concepts": [
        "Loops",
        "Infinite Loops",
        "Logic Errors"
      ],
      "keywords": [
        "loops",
        "run",
        "forever"
      ],
      "source_links": [
        "chapters/04-control-flow/index.md"
      ],
      "has_example": true,
      "word_count": 72
    },
    {
      "id": "faq-030",
      "category": "Common Challenges",
      "question": "Why am I getting off-by-one errors?",
      "answer": "Off-by-one errors occur when boundaries are misinterpreted, especially with `range`, indexing, and slicing. Python ranges are start-inclusive and stop-exclusive, so `range(0, n)` produces `n` values ending at `n-1`. For example, iterating to `len(items)` and indexing directly can raise an error at the final step. Recheck bounds and test edge inputs in [Chapter 4](chapters/04-control-flow/index.md) and [Chapter 8](chapters/08-lists/index.md).",
      "bloom_level": "Apply",
      "difficulty": "medium",
      "concepts": [
        "Lists"
      ],
      "keywords": [
        "getting",
        "off",
        "one",
        "errors"
      ],
      "source_links": [
        "chapters/04-control-flow/index.md",
        "chapters/08-lists/index.md"
      ],
      "has_example": true,
      "word_count": 74
    },
    {
      "id": "faq-031",
      "category": "Common Challenges",
      "question": "Why does my function return `None` unexpectedly?",
      "answer": "A function returns `None` when execution reaches the end without an explicit `return` value. This often happens in branches where one path returns data and another path does not. For example, a validation function may return `True` on success but forget `False` on failure. Make all return paths explicit and test each branch. See return-value design in [Chapter 6](chapters/06-functions-and-modular-design/index.md).",
      "bloom_level": "Analyze",
      "difficulty": "medium",
      "concepts": [
        "Functions"
      ],
      "keywords": [
        "function",
        "return",
        "none",
        "unexpectedly"
      ],
      "source_links": [
        "chapters/06-functions-and-modular-design/index.md"
      ],
      "has_example": true,
      "word_count": 68
    },
    {
      "id": "faq-032",
      "category": "Common Challenges",
      "question": "Why does recursion fail with maximum depth errors?",
      "answer": "Recursion depth errors usually mean the base case is missing, unreachable, or incorrect. Each recursive call must move closer to termination; otherwise the call stack grows until Python stops execution. For example, decrementing the wrong variable can prevent progress to the base case. Trace input transitions and validate base cases first. Use [Chapter 7](chapters/07-higher-order-functions-and-recursion/index.md) for structured debugging strategies.",
      "bloom_level": "Understand",
      "difficulty": "medium",
      "concepts": [
        "Functions",
        "Recursion",
        "Base Case"
      ],
      "keywords": [
        "recursion",
        "fail",
        "maximum",
        "depth",
        "errors"
      ],
      "source_links": [
        "chapters/07-higher-order-functions-and-recursion/index.md"
      ],
      "has_example": true,
      "word_count": 67
    },
    {
      "id": "faq-033",
      "category": "Common Challenges",
      "question": "Why do dictionary key errors happen?",
      "answer": "A `KeyError` occurs when you access a key that is not present in a dictionary. This is common with user input, optional fields, or inconsistent data sources. For example, `record['email']` fails if `email` is missing, while `record.get('email')` handles absence gracefully. Add key checks or defaults where data is uncertain. Robust patterns appear in [Chapter 11](chapters/11-dictionaries/index.md) and [Chapter 14](chapters/14-errors-and-exceptions/index.md).",
      "bloom_level": "Apply",
      "difficulty": "medium",
      "concepts": [
        "Dictionaries",
        "KeyError"
      ],
      "keywords": [
        "dictionary",
        "key",
        "errors",
        "happen"
      ],
      "source_links": [
        "chapters/11-dictionaries/index.md",
        "chapters/14-errors-and-exceptions/index.md"
      ],
      "has_example": true,
      "word_count": 73
    },
    {
      "id": "faq-034",
      "category": "Common Challenges",
      "question": "Why do tests pass locally but fail later?",
      "answer": "Tests can pass locally yet fail later when they rely on hidden state, environment assumptions, or non-deterministic behavior. Common causes include shared mutable objects, time-dependent logic, and ordering assumptions in collections. For example, one test may mutate global state used by another test. Isolate test setup and teardown, and keep test inputs deterministic. See reliability practices in [Chapter 17](chapters/17-testing-and-debugging/index.md).",
      "bloom_level": "Analyze",
      "difficulty": "medium",
      "concepts": [
        "Objects",
        "Testing",
        "Debugging"
      ],
      "keywords": [
        "tests",
        "pass",
        "locally",
        "but",
        "fail",
        "later"
      ],
      "source_links": [
        "chapters/17-testing-and-debugging/index.md"
      ],
      "has_example": true,
      "word_count": 68
    },
    {
      "id": "faq-035",
      "category": "Best Practice",
      "question": "How should I structure a medium-size Python program?",
      "answer": "Structure programs with clear modules, single-purpose functions, and explicit data flow between components. Keep business logic separate from input/output so you can test core behavior independently. For example, compute results in pure functions and keep file or console interactions in thin wrapper functions. This pattern improves maintainability and reuse. Apply the approach from [Chapter 16: Software Engineering](chapters/16-software-engineering/index.md) and [Chapter 6](chapters/06-functions-and-modular-design/index.md).",
      "bloom_level": "Understand",
      "difficulty": "medium",
      "concepts": [
        "Functions"
      ],
      "keywords": [
        "structure",
        "medium",
        "size",
        "python",
        "program"
      ],
      "source_links": [
        "chapters/16-software-engineering/index.md",
        "chapters/06-functions-and-modular-design/index.md"
      ],
      "has_example": true,
      "word_count": 76
    },
    {
      "id": "faq-036",
      "category": "Best Practice",
      "question": "When should I choose a dictionary over a list?",
      "answer": "Choose a dictionary when you need fast lookup by meaningful keys; choose a list when order and sequential processing are primary. For example, student records keyed by student ID fit a dictionary, while an ordered daily task queue fits a list. Choosing by access pattern prevents awkward code and reduces complexity. Compare use cases in [Chapter 8](chapters/08-lists/index.md) and [Chapter 11](chapters/11-dictionaries/index.md).",
      "bloom_level": "Apply",
      "difficulty": "medium",
      "concepts": [
        "Lists",
        "Dictionaries"
      ],
      "keywords": [
        "choose",
        "dictionary",
        "over",
        "list"
      ],
      "source_links": [
        "chapters/08-lists/index.md",
        "chapters/11-dictionaries/index.md"
      ],
      "has_example": true,
      "word_count": 70
    },
    {
      "id": "faq-037",
      "category": "Best Practice",
      "question": "How can I write code that is easy to debug?",
      "answer": "Write small functions, name variables for intent, and add focused checks at boundaries where bad data enters. Keep side effects explicit and avoid deeply nested logic when possible. For example, returning early on invalid input simplifies the happy-path flow and makes failures obvious. Pair these habits with repeatable tests for confidence. Debuggable design is emphasized in [Chapter 17](chapters/17-testing-and-debugging/index.md) and [Chapter 16](chapters/16-software-engineering/index.md).",
      "bloom_level": "Analyze",
      "difficulty": "medium",
      "concepts": [
        "Variables",
        "Functions",
        "Testing"
      ],
      "keywords": [
        "write",
        "code",
        "easy",
        "debug"
      ],
      "source_links": [
        "chapters/17-testing-and-debugging/index.md",
        "chapters/16-software-engineering/index.md"
      ],
      "has_example": true,
      "word_count": 75
    },
    {
      "id": "faq-038",
      "category": "Best Practice",
      "question": "What is a good strategy for incremental problem solving?",
      "answer": "Use iterative refinement: start with a minimal working solution, verify correctness, then optimize only where needed. This reduces risk and keeps bugs localized to small changes. For example, first solve search with a simple linear method, then switch to binary search only after confirming sorted input assumptions. This strategy balances speed and reliability. See [Chapter 1](chapters/01-intro-to-computer-science/index.md) and [Chapter 19](chapters/19-algorithm-analysis/index.md).",
      "bloom_level": "Evaluate",
      "difficulty": "hard",
      "concepts": [
        "Problem Solving",
        "Binary Search"
      ],
      "keywords": [
        "good",
        "strategy",
        "incremental",
        "problem",
        "solving"
      ],
      "source_links": [
        "chapters/01-intro-to-computer-science/index.md",
        "chapters/19-algorithm-analysis/index.md"
      ],
      "has_example": true,
      "word_count": 73
    },
    {
      "id": "faq-039",
      "category": "Best Practice",
      "question": "How do I balance readability and performance?",
      "answer": "Prioritize readable, correct code first, then optimize measured bottlenecks. Premature optimization increases complexity without proven benefit. For example, replacing clear loops with obscure micro-optimizations can hurt maintainability more than it helps runtime. Use profiling or timing for evidence before refactoring. Tradeoff analysis and practical optimization are covered in [Chapter 19](chapters/19-algorithm-analysis/index.md) and [Chapter 16](chapters/16-software-engineering/index.md).",
      "bloom_level": "Understand",
      "difficulty": "medium",
      "concepts": [
        "Loops",
        "Refactoring"
      ],
      "keywords": [
        "balance",
        "readability",
        "performance"
      ],
      "source_links": [
        "chapters/19-algorithm-analysis/index.md",
        "chapters/16-software-engineering/index.md"
      ],
      "has_example": true,
      "word_count": 66
    },
    {
      "id": "faq-040",
      "category": "Best Practice",
      "question": "What documentation should accompany my code?",
      "answer": "At minimum, include module purpose, function docstrings, parameter and return expectations, and examples for non-obvious behavior. Documentation should explain intent and constraints, not restate syntax. For example, a docstring for a parser should describe accepted format and failure modes. Good documentation lowers onboarding time and improves correctness in team settings. See conventions in [Chapter 6](chapters/06-functions-and-modular-design/index.md).",
      "bloom_level": "Apply",
      "difficulty": "medium",
      "concepts": [
        "Functions",
        "Docstrings",
        "Documentation"
      ],
      "keywords": [
        "documentation",
        "accompany",
        "code"
      ],
      "source_links": [
        "chapters/06-functions-and-modular-design/index.md"
      ],
      "has_example": true,
      "word_count": 64
    },
    {
      "id": "faq-041",
      "category": "Advanced Topics",
      "question": "How should I choose between iterative and recursive designs in production code?",
      "answer": "Use recursion when it best expresses the domain and depth is controlled; prefer iteration when depth may grow unpredictably or when performance and stack safety are priorities. For example, tree traversal is often clearer recursively, while large linear processing is usually safer iteratively. Evaluate maintainability, correctness, and resource constraints together. Compare implementations in [Chapter 7](chapters/07-higher-order-functions-and-recursion/index.md) and [Chapter 19](chapters/19-algorithm-analysis/index.md).",
      "bloom_level": "Apply",
      "difficulty": "hard",
      "concepts": [
        "Functions",
        "Recursion"
      ],
      "keywords": [
        "choose",
        "between",
        "iterative",
        "recursive",
        "designs",
        "production"
      ],
      "source_links": [
        "chapters/07-higher-order-functions-and-recursion/index.md",
        "chapters/19-algorithm-analysis/index.md"
      ],
      "has_example": true,
      "word_count": 73
    },
    {
      "id": "faq-042",
      "category": "Advanced Topics",
      "question": "When do decorators provide real value?",
      "answer": "Decorators are valuable when you need reusable cross-cutting behavior such as logging, timing, retries, access control, or caching without rewriting business logic. They keep core functions focused while adding standardized behavior externally. For example, a timing decorator can benchmark multiple algorithms with consistent instrumentation. Use decorators carefully to avoid hidden control flow that confuses beginners. Advanced usage appears in [Chapter 20](chapters/20-advanced-python/index.md).",
      "bloom_level": "Analyze",
      "difficulty": "hard",
      "concepts": [
        "Algorithms",
        "Control Flow",
        "Functions"
      ],
      "keywords": [
        "decorators",
        "provide",
        "real",
        "value"
      ],
      "source_links": [
        "chapters/20-advanced-python/index.md"
      ],
      "has_example": true,
      "word_count": 68
    },
    {
      "id": "faq-043",
      "category": "Advanced Topics",
      "question": "How can I design for extensibility with classes and polymorphism?",
      "answer": "Design around stable interfaces and substitute implementations behind those interfaces. Keep shared contracts clear and avoid coupling client code to concrete class details. For example, a grading system can accept any object implementing `calculate_score()` rather than branching on class type. This reduces future rewrite costs when requirements grow. See architectural patterns in [Chapter 13](chapters/13-inheritance-and-polymorphism/index.md) and [Chapter 16](chapters/16-software-engineering/index.md).",
      "bloom_level": "Evaluate",
      "difficulty": "hard",
      "concepts": [
        "Classes",
        "Inheritance",
        "Polymorphism"
      ],
      "keywords": [
        "design",
        "extensibility",
        "classes",
        "polymorphism"
      ],
      "source_links": [
        "chapters/13-inheritance-and-polymorphism/index.md",
        "chapters/16-software-engineering/index.md"
      ],
      "has_example": true,
      "word_count": 70
    },
    {
      "id": "faq-044",
      "category": "Advanced Topics",
      "question": "What are practical limits of Big-O in real projects?",
      "answer": "Big-O is essential for growth reasoning, but constants, memory locality, interpreter overhead, and input distribution also matter in practice. Two algorithms with the same Big-O can behave very differently on realistic data. For example, a theoretically optimal method may lose to a simpler one for small input sizes. Combine asymptotic analysis with measurement to choose responsibly. See [Chapter 19](chapters/19-algorithm-analysis/index.md).",
      "bloom_level": "Create",
      "difficulty": "hard",
      "concepts": [
        "Algorithms"
      ],
      "keywords": [
        "practical",
        "limits",
        "big",
        "real",
        "projects"
      ],
      "source_links": [
        "chapters/19-algorithm-analysis/index.md"
      ],
      "has_example": true,
      "word_count": 67
    },
    {
      "id": "faq-045",
      "category": "Advanced Topics",
      "question": "How do I combine testing, exceptions, and logging into a reliability strategy?",
      "answer": "Treat reliability as a system: tests catch regressions, exceptions enforce clear failure behavior, and logging preserves runtime evidence. For example, validate input early, raise precise exceptions, and log contextual details at failure boundaries. Then write tests for both success and failure paths. This integrated approach shortens incident diagnosis and stabilizes code changes over time. Combine practices from [Chapter 14](chapters/14-errors-and-exceptions/index.md), [Chapter 17](chapters/17-testing-and-debugging/index.md), and [Chapter 16](chapters/16-software-engineering/index.md).",
      "bloom_level": "Apply",
      "difficulty": "hard",
      "concepts": [
        "Testing",
        "Debugging"
      ],
      "keywords": [
        "combine",
        "testing",
        "exceptions",
        "logging",
        "into",
        "reliability"
      ],
      "source_links": [
        "chapters/14-errors-and-exceptions/index.md",
        "chapters/17-testing-and-debugging/index.md",
        "chapters/16-software-engineering/index.md"
      ],
      "has_example": true,
      "word_count": 84
    }
  ]
}