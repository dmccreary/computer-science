{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AP Computer Science with Python","text":""},{"location":"#ap-computer-science-with-python","title":"AP Computer Science with Python","text":"<p>Welcome to AP Computer Science with Python!</p> <p>This is a level-2 intelligent textbook currently under construction.</p>"},{"location":"about/","title":"About","text":""},{"location":"about/#about-this-course","title":"About This Course","text":""},{"location":"about/#why-computer-science-matters-now-more-than-ever","title":"Why Computer Science Matters Now More Than Ever","text":"<p>Computer science is one of the fastest-growing subjects in education worldwide. Here are some statistics that demonstrate its reach:</p> <p>In the United States (2026 projections):</p> <ul> <li>Approximately 1.2 million high school students take computer science courses each year[^1]</li> <li>Over 150,000 students take the AP Computer Science A exam annually[^2]</li> <li>About 130,000 students take the AP Computer Science Principles exam each year[^2]</li> <li>Only 57% of U.S. high schools offer a foundational computer science course, creating significant access disparities[^1]</li> </ul> <p>Worldwide:</p> <ul> <li>An estimated 25 million students study programming globally each year</li> <li>Computer science serves as a gateway to careers in software engineering, data science, artificial intelligence, cybersecurity, and many more fields</li> </ul> <p>These numbers represent millions of students working to master the same concepts you'll learn in this course. You're joining a global community of learners building the computational thinking skills that power our digital world.</p> <p>Monty says: Let's code this!</p> <p> Did you know that traditional computer science textbooks at many US colleges and universities cost between $150 and $250?[^3] That's a lot of money to spend before you even write your first line of code! And here's the real kicker -- those expensive books don't even have interactive MicroSims to help you see what's happening.</p> <p>I believe every student deserves access to high-quality computer science education, regardless of their budget. That's why this entire textbook is free and open source, with dozens of interactive simulations that let you explore programming concepts hands-on. No paywalls, no access codes, no \"edition 12 with slightly rearranged homework problems.\"</p> <p>Let me help you master computer science without breaking the bank. Together, we've got this!</p>"},{"location":"about/#learning-through-interactive-visualization","title":"Learning Through Interactive Visualization","text":"<p>This course takes a fundamentally different approach to teaching computer science. Instead of staring at static code listings, you will build deep intuition through interactive MicroSimulations. These browser-based visualizations let you experiment with algorithms, data structures, control flow, and object-oriented concepts in real-time.</p> <p>Watch a sorting algorithm rearrange elements step by step. See how recursion builds up a call stack and unwinds it. Explore how binary search narrows down a target in logarithmic time. Visualize how objects interact in a class hierarchy. These are not passive animations -- they are hands-on laboratories where you control the parameters and discover the concepts yourself.</p>"},{"location":"about/#you-will-have-fun","title":"You Will Have Fun","text":"<p>Yes, you read that right. This course is designed to be genuinely enjoyable. The MicroSims turn abstract concepts into interactive playgrounds. The connections to real-world applications give every topic immediate relevance. And the satisfaction of writing a program that works is deeply rewarding.</p> <p>Whether you aspire to build the next great app, develop artificial intelligence systems, create video games, analyze data to solve real-world problems, or simply want to understand the computational foundations of our increasingly digital world -- this course will give you the tools, the intuition, and the confidence to succeed.</p> <p>Let's explore the beauty of computer science together!</p>"},{"location":"about/#background","title":"Background","text":"<p>The concepts covered by this book were generated by the following prompt:</p> <p>Prompt</p> <p>What standard organizations describe the concepts that should be covered in a high-school AP Computer Science course using Python that would maximize the probability that the student would get college credits for taking the course?</p> <p>Our tools have also matured since January 2025 when we first started using AI to generate textbooks. This version of our intelligent textbook was generated using Claude Code Skills in February 2026. We also put a strong focus on creating high-quality MicroSims that bring abstract concepts to life.</p> <p>-- Dan McCreary, February 2026</p>"},{"location":"about/#references","title":"References","text":"<p>[^1]: Code.org. 2024 State of Computer Science Education. Annual report on access and participation in K-12 computer science.</p> <p>[^2]: College Board. 2025 AP Score Distributions. AP Students.</p> <p>[^3]: OpenStax. About OpenStax. Notes that the average student spends approximately $1,200 per year on textbooks.</p>"},{"location":"contact/","title":"Contact","text":""},{"location":"contact/#contact","title":"Contact","text":"<p>Please connect with me on LinkedIn</p> <p>I am looking forward to your feedback!</p> <ul> <li>Dan McCreary</li> </ul>"},{"location":"course-description/","title":"Course Description","text":""},{"location":"course-description/#ap-computer-science-python-version","title":"AP Computer Science (Python Version)","text":""},{"location":"course-description/#course-title","title":"Course Title","text":"<p>AP Computer Science (Python Version) College-Level Introduction to Computer Science Using Python</p>"},{"location":"course-description/#audience","title":"Audience","text":"<p>This course is designed for:</p> <ul> <li>High school students (grades 10\u201312) seeking a rigorous, college-level computer science experience</li> <li>Students interested in STEM, engineering, mathematics, data science, AI, or software development</li> <li>Students preparing for university-level CS1 courses taught in Python</li> <li>Schools seeking a modern alternative to Java-based AP Computer Science A</li> </ul> <p>This course mirrors the scope and rigor of College Board AP Computer Science A, but uses Python as the primary language of instruction.</p>"},{"location":"course-description/#prerequisites","title":"Prerequisites","text":"<p>Students should have:</p> <ul> <li>Successful completion of Algebra I (Algebra II recommended)</li> <li>Strong logical reasoning and problem-solving skills</li> <li>Comfort with abstract thinking</li> <li>Basic computer literacy</li> </ul> <p>Prior programming experience is helpful but not required.</p>"},{"location":"course-description/#overview","title":"Overview","text":"<p>AP Computer Science (Python Version) is a college-level course that introduces students to:</p> <ul> <li>Computational thinking</li> <li>Algorithm design</li> <li>Object-oriented programming (OOP)</li> <li>Data structures</li> <li>Abstraction and modular design</li> <li>Program analysis and testing</li> </ul> <p>The course emphasizes disciplined software engineering practices while leveraging Python\u2019s readability and expressive power. Students learn to design, implement, test, and debug multi-module programs.</p> <p>Although this is not an official AP exam course, it aligns conceptually with the depth and rigor of AP Computer Science A and first-semester university CS courses taught in Python.</p>"},{"location":"course-description/#topics-covered","title":"Topics Covered","text":""},{"location":"course-description/#1-computational-thinking-and-problem-solving","title":"1. Computational Thinking and Problem Solving","text":"<ul> <li>Decomposition</li> <li>Pattern recognition</li> <li>Abstraction</li> <li>Algorithm design</li> <li>Stepwise refinement</li> </ul>"},{"location":"course-description/#2-python-fundamentals","title":"2. Python Fundamentals","text":"<ul> <li>Variables and assignment</li> <li>Numeric types (<code>int</code>, <code>float</code>)</li> <li>Boolean logic</li> <li>Strings and string methods</li> <li>Type conversion</li> <li>Input and output</li> </ul>"},{"location":"course-description/#3-control-structures","title":"3. Control Structures","text":"<ul> <li>Conditional statements (<code>if</code>, <code>elif</code>, <code>else</code>)</li> <li>Loops (<code>for</code>, <code>while</code>)</li> <li>Nested control structures</li> <li>Logical operators</li> <li>Short-circuit evaluation</li> </ul>"},{"location":"course-description/#4-functions-and-modular-design","title":"4. Functions and Modular Design","text":"<ul> <li>Function definition and invocation</li> <li>Parameters and return values</li> <li>Scope and lifetime of variables</li> <li>Default parameters</li> <li>Docstrings and documentation</li> <li>Modular program structure</li> </ul>"},{"location":"course-description/#5-data-structures","title":"5. Data Structures","text":"<ul> <li>Lists</li> <li>Tuples</li> <li>Dictionaries</li> <li>Sets</li> <li>Traversal patterns</li> <li>Nested data structures</li> </ul>"},{"location":"course-description/#6-object-oriented-programming","title":"6. Object-Oriented Programming","text":"<ul> <li>Classes and objects</li> <li>Instance attributes</li> <li>Methods</li> <li>Constructors (<code>__init__</code>)</li> <li>Encapsulation conventions</li> <li>Composition</li> <li>Inheritance</li> <li>Polymorphism</li> <li>Method overriding</li> </ul>"},{"location":"course-description/#7-algorithms","title":"7. Algorithms","text":"<ul> <li>Searching (linear, binary)</li> <li>Sorting (selection, insertion, merge sort)</li> <li>Algorithm correctness</li> <li>Big-O notation (introductory level)</li> </ul>"},{"location":"course-description/#8-recursion","title":"8. Recursion","text":"<ul> <li>Recursive definitions</li> <li>Base and recursive cases</li> <li>Tracing recursive calls</li> <li>Comparing recursive vs iterative solutions</li> </ul>"},{"location":"course-description/#9-file-io","title":"9. File I/O","text":"<ul> <li>Reading from files</li> <li>Writing to files</li> <li>Structured data formats (introductory JSON concepts)</li> </ul>"},{"location":"course-description/#10-testing-and-debugging","title":"10. Testing and Debugging","text":"<ul> <li>Unit testing basics</li> <li>Assertions</li> <li>Edge cases</li> <li>Defensive programming</li> <li>Code tracing</li> </ul>"},{"location":"course-description/#topics-not-covered","title":"Topics NOT Covered","text":"<p>The following topics are generally outside the scope of this course:</p> <ul> <li>Advanced data structures (trees, graphs, hash tables)</li> <li>Database systems</li> <li>Web frameworks</li> <li>Machine learning</li> <li>Artificial intelligence algorithms</li> <li>Multithreading and concurrency</li> <li>Operating systems</li> <li>Network protocol implementation</li> <li>Cybersecurity engineering</li> <li>Advanced numerical computing</li> </ul>"},{"location":"course-description/#learning-objectives-2001-blooms-taxonomy","title":"Learning Objectives (2001 Bloom\u2019s Taxonomy)","text":""},{"location":"course-description/#1-remember","title":"1. Remember","text":"<p>Students will be able to:</p> <ul> <li>Recall Python syntax and semantics</li> <li>Identify built-in data types and structures</li> <li>List common list, dictionary, and string methods</li> <li>Define key terms such as abstraction, recursion, and polymorphism</li> </ul>"},{"location":"course-description/#2-understand","title":"2. Understand","text":"<p>Students will be able to:</p> <ul> <li>Explain how control flow affects execution</li> <li>Describe how objects encapsulate state and behavior</li> <li>Interpret code segments and predict output</li> <li>Summarize how recursion operates</li> <li>Explain the purpose of modular design</li> </ul>"},{"location":"course-description/#3-apply","title":"3. Apply","text":"<p>Students will be able to:</p> <ul> <li>Write programs using conditionals and loops</li> <li>Implement functions with parameters and return values</li> <li>Create classes that model real-world entities</li> <li>Manipulate lists and dictionaries to solve problems</li> <li>Read from and write to files</li> </ul>"},{"location":"course-description/#4-analyze","title":"4. Analyze","text":"<p>Students will be able to:</p> <ul> <li>Decompose complex problems into smaller components</li> <li>Compare iterative and recursive implementations</li> <li>Identify logical, syntax, and runtime errors</li> <li>Evaluate algorithm efficiency at an introductory level</li> <li>Trace object interactions in multi-class systems</li> </ul>"},{"location":"course-description/#5-evaluate","title":"5. Evaluate","text":"<p>Students will be able to:</p> <ul> <li>Assess readability and maintainability of code</li> <li>Critique algorithmic alternatives</li> <li>Justify design decisions in object-oriented systems</li> <li>Validate test cases for completeness</li> <li>Determine whether a solution satisfies given specifications</li> </ul>"},{"location":"course-description/#6-create","title":"6. Create","text":"<p>Students will be able to:</p> <ul> <li>Design and implement complete multi-module applications</li> <li>Develop reusable classes and data abstractions</li> <li>Construct recursive algorithms</li> <li>Integrate multiple data structures into cohesive solutions</li> <li>Build software systems that model real-world processes</li> </ul>"},{"location":"course-description/#course-outcomes","title":"Course Outcomes","text":"<p>By the end of the course, students will:</p> <ul> <li>Demonstrate mastery of foundational computer science principles</li> <li>Develop proficiency in Python programming</li> <li>Understand object-oriented design concepts</li> <li>Be prepared for college-level CS1 courses taught in Python</li> <li>Be capable of transitioning to Java-based AP Computer Science A if needed</li> </ul>"},{"location":"course-description/#alignment-to-college-level-expectations","title":"Alignment to College-Level Expectations","text":"<p>This course is equivalent to a first-semester college course in computer science taught in Python. It emphasizes:</p> <ul> <li>Formal problem solving</li> <li>Structured programming</li> <li>Object-oriented design</li> <li>Algorithm development</li> <li>Foundational software engineering principles</li> </ul>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#ap-computer-science-python-version-faq","title":"AP Computer Science (Python Version) FAQ","text":""},{"location":"faq/#getting-started-questions","title":"Getting Started Questions","text":""},{"location":"faq/#what-is-this-course-about","title":"What is this course about?","text":"<p>This course is a full AP-style introduction to computer science using Python. You will learn how to break problems into smaller parts, design algorithms, and build maintainable programs with functions, data structures, and objects. The scope matches a first university CS course while using Python's readable syntax. Start with the official overview in Course Description and the chapter roadmap in Chapters.</p>"},{"location":"faq/#who-is-this-course-designed-for","title":"Who is this course designed for?","text":"<p>The primary audience is students in grades 10-12 who want a rigorous, college-level computer science experience. It also fits self-learners preparing for CS1 courses that use Python. You do not need prior programming experience, but you should be comfortable with algebra and logical reasoning. The intended audience and readiness expectations are listed in Course Description.</p>"},{"location":"faq/#what-background-knowledge-should-i-have-before-starting","title":"What background knowledge should I have before starting?","text":"<p>You should have completed Algebra I (Algebra II recommended), be comfortable with basic computer use, and be ready for structured problem solving. Prior coding helps but is not required because early chapters cover fundamentals from the ground up. If you are unsure, review Chapter 1: Intro to Computer Science and Chapter 2: Python Fundamentals before moving on.</p>"},{"location":"faq/#how-should-i-move-through-the-chapters","title":"How should I move through the chapters?","text":"<p>Use a dependency-first order: fundamentals, logic, control flow, functions, data structures, then software engineering and analysis. This sequence mirrors the learning graph and helps you avoid learning advanced ideas without prerequisites. A practical plan is one chapter per week with short daily coding practice. Use Learning Graph Overview and Chapters to track sequence.</p>"},{"location":"faq/#how-much-time-should-i-plan-each-week","title":"How much time should I plan each week?","text":"<p>Plan about 4-6 hours per week for reading, coding, and review. A balanced split is 2 hours reading, 2-3 hours coding exercises, and 1 hour for recap and debugging practice. If a chapter introduces a difficult topic like recursion or algorithm analysis, add extra practice time. Review chapter pacing in Chapters and outcomes in Course Description.</p>"},{"location":"faq/#do-i-need-special-software-to-complete-the-course","title":"Do I need special software to complete the course?","text":"<p>You only need a modern Python 3 installation and a code editor such as VS Code. You can also use the Python REPL for fast experiments before writing scripts. The course does not require expensive tools or specialized hardware. Setup concepts are introduced early in Chapter 2: Python Fundamentals and reinforced in Chapter 1.</p>"},{"location":"faq/#how-do-microsims-help-me-learn","title":"How do MicroSims help me learn?","text":"<p>MicroSims are focused interactive visual tools that let you test ideas quickly, such as operator behavior, truth tables, or data structure operations. They reduce cognitive load by turning abstract rules into direct feedback. For example, using the truthiness simulator can clarify why a condition evaluates to <code>True</code> or <code>False</code>. Browse a representative set in Truthiness Tester and Truth Table Builder, then connect them to chapter content in Chapters.</p>"},{"location":"faq/#what-should-i-do-if-i-fall-behind","title":"What should I do if I fall behind?","text":"<p>First, return to prerequisite chapters and rebuild weak concepts before trying to push ahead. Then use short, daily sessions with one learning target per session, such as loops, slicing, or dictionary traversal. For example, spending 20 minutes writing three small loop exercises is often better than one long cram session. Revisit Chapter 4: Control Flow and Chapter 6: Functions to recover core momentum.</p>"},{"location":"faq/#core-concept-questions","title":"Core Concept Questions","text":""},{"location":"faq/#what-is-computational-thinking","title":"What is computational thinking?","text":"<p>Computational thinking is a problem-solving approach that uses decomposition, abstraction, pattern recognition, and algorithm design. Instead of jumping into code, you define the problem, model it clearly, and choose a repeatable strategy. For example, a grading program becomes smaller tasks: input, validation, calculation, and reporting. The foundational framing appears in Chapter 1 and the concept set in Concept List.</p>"},{"location":"faq/#what-is-an-algorithm-and-why-does-it-matter","title":"What is an algorithm, and why does it matter?","text":"<p>An algorithm is a finite, well-defined sequence of steps for solving a problem. Good algorithms produce correct results and scale acceptably as inputs grow. In programming, algorithm quality affects runtime, memory use, and maintainability. For example, choosing binary search over linear search on sorted data can drastically reduce work. See Chapter 18: Searching and Sorting and Chapter 19: Algorithm Analysis.</p>"},{"location":"faq/#how-are-variables-expressions-and-statements-different","title":"How are variables, expressions, and statements different?","text":"<p>A variable stores a reference to a value, an expression computes a value, and a statement performs an action. <code>x = 5</code> is a statement; <code>x + 2</code> is an expression; <code>x</code> is a variable name bound to data. Keeping these roles distinct helps you reason about program flow and debugging. This distinction is introduced in Chapter 2 and reinforced in Chapter 4.</p>"},{"location":"faq/#what-is-the-relationship-between-boolean-logic-and-control-flow","title":"What is the relationship between Boolean logic and control flow?","text":"<p>Boolean expressions drive decision making in <code>if</code>, <code>elif</code>, and loop conditions. Control flow structures execute different paths depending on truth values, so weak Boolean reasoning leads to incorrect program behavior. For example, misunderstanding <code>and</code> versus <code>or</code> can invert business rules. Build this connection through Chapter 3: Boolean Logic and Chapter 4: Control Flow.</p>"},{"location":"faq/#why-are-functions-central-to-software-design","title":"Why are functions central to software design?","text":"<p>Functions let you encapsulate behavior, reduce duplication, and define clean interfaces between parts of a program. They make code easier to test, document, and reuse. For example, splitting a payroll calculation into small functions enables isolated testing of tax, overtime, and formatting logic. Core function design is covered in Chapter 6 and expanded in Chapter 16: Software Engineering.</p>"},{"location":"faq/#how-do-lists-tuples-sets-and-dictionaries-differ","title":"How do lists, tuples, sets, and dictionaries differ?","text":"<p>Lists are ordered and mutable, tuples are ordered and immutable, sets are unordered collections of unique values, and dictionaries map keys to values. Choosing correctly improves clarity and performance. For example, use a set for fast membership checks and a dictionary for lookups by identifier. Data structure decisions begin in Chapter 8: Lists, Chapter 10: Tuples and Sets, and Chapter 11: Dictionaries.</p>"},{"location":"faq/#what-is-object-oriented-programming-in-this-course","title":"What is object-oriented programming in this course?","text":"<p>Object-oriented programming (OOP) organizes software around classes (blueprints) and objects (instances with state and behavior). It supports encapsulation, reuse, and clearer modeling of real systems. For example, a <code>Student</code> class can manage grades and validation methods in one cohesive unit. OOP fundamentals and design choices are presented in Chapter 12: Classes and Objects and Chapter 13: Inheritance and Polymorphism.</p>"},{"location":"faq/#when-should-i-use-recursion-instead-of-iteration","title":"When should I use recursion instead of iteration?","text":"<p>Use recursion when a problem has a natural self-similar structure, such as tree traversal or divide-and-conquer decomposition. Use iteration when the logic is linear and state is easy to manage with loops. For example, factorial can be implemented both ways, but recursion may communicate the mathematical definition more directly. Compare tradeoffs in Chapter 7 and Chapter 19.</p>"},{"location":"faq/#why-is-testing-part-of-learning-core-concepts","title":"Why is testing part of learning core concepts?","text":"<p>Testing validates that your understanding matches actual program behavior, especially around edge cases. It turns assumptions into explicit checks and provides faster feedback than manual inspection alone. For example, unit tests for a function handling empty input can prevent subtle runtime errors later. Practical testing workflows are covered in Chapter 17: Testing and Debugging and supported by error handling in Chapter 14.</p>"},{"location":"faq/#how-does-the-learning-graph-help-with-concept-dependencies","title":"How does the learning graph help with concept dependencies?","text":"<p>The learning graph models prerequisite relationships so you can study in an order that minimizes confusion. It helps instructors and learners identify gateway concepts such as variables, conditionals, and functions that unlock later topics. For example, attempting object inheritance before class basics usually causes avoidable confusion. Use Learning Graph and Concept Taxonomy to plan your path.</p>"},{"location":"faq/#technical-detail-questions","title":"Technical Detail Questions","text":""},{"location":"faq/#what-is-short-circuit-evaluation","title":"What is short-circuit evaluation?","text":"<p>Short-circuit evaluation means Python stops evaluating a Boolean expression as soon as the result is determined. In <code>A and B</code>, if <code>A</code> is <code>False</code>, Python does not evaluate <code>B</code>. In <code>A or B</code>, if <code>A</code> is <code>True</code>, Python does not evaluate <code>B</code>. This can prevent unnecessary computation and avoid runtime errors. See Chapter 3 and glossary definitions in Glossary.</p>"},{"location":"faq/#what-is-variable-scope","title":"What is variable scope?","text":"<p>Scope defines where a variable name is visible and usable. Local variables exist inside functions, while global variables exist at module level. Misunderstanding scope often causes bugs where values appear unchanged or unexpectedly overwritten. For example, assigning inside a function creates a local name unless you intentionally reference module-level state. Scope rules and safe patterns are explained in Chapter 6.</p>"},{"location":"faq/#what-is-the-difference-between-mutable-and-immutable-types","title":"What is the difference between mutable and immutable types?","text":"<p>Mutable objects can change after creation, while immutable objects cannot. Lists and dictionaries are mutable; tuples and strings are immutable. This affects side effects, function behavior, and debugging. For example, appending to a list inside a function changes the original object, but modifying a string creates a new object. Review mutability examples in Chapter 5 and Chapter 8.</p>"},{"location":"faq/#what-are-list-comprehensions-and-when-should-i-use-them","title":"What are list comprehensions, and when should I use them?","text":"<p>List comprehensions are compact expressions for constructing lists from iterables with optional filtering. They improve readability when the transformation is simple and focused. For example, <code>[n*n for n in nums if n % 2 == 0]</code> is concise and clear for creating squared even values. Avoid deeply nested comprehensions that hide intent. Learn style and constraints in Chapter 8 and Chapter 20.</p>"},{"location":"faq/#what-does-big-o-notation-describe","title":"What does Big-O notation describe?","text":"<p>Big-O describes how time or space requirements grow as input size increases. It does not measure exact runtime; it captures growth trend and scalability. For example, <code>O(log n)</code> scales better than <code>O(n)</code> as data grows, which is why binary search is preferred on sorted collections. Use Big-O to compare algorithm choices pragmatically. See Chapter 19: Algorithm Analysis.</p>"},{"location":"faq/#what-is-polymorphism-in-python","title":"What is polymorphism in Python?","text":"<p>Polymorphism means different objects can respond to the same method name in type-specific ways. This supports extensible code by programming to interfaces rather than concrete classes. For example, both <code>Circle</code> and <code>Rectangle</code> objects can implement an <code>area()</code> method while using different formulas internally. This reduces conditional branching in client code. Explore examples in Chapter 13.</p>"},{"location":"faq/#what-is-defensive-programming","title":"What is defensive programming?","text":"<p>Defensive programming is writing code that anticipates bad inputs, invalid states, and misuse. It combines validation, clear errors, and safe defaults to keep software reliable. For example, checking a divisor before division avoids crashes and communicates intent early. Defensive habits are essential for maintainable systems and easier debugging. See Chapter 14: Errors and Exceptions and Chapter 17.</p>"},{"location":"faq/#how-do-file-read-and-write-workflows-typically-work","title":"How do file read and write workflows typically work?","text":"<p>Typical file workflows use context managers (<code>with</code>) to open files safely, process content, and ensure cleanup. Reading often involves line iteration or whole-file parsing; writing usually includes formatting and encoding considerations. For example, writing JSON output requires deterministic keys and robust error handling around malformed data. Core patterns are shown in Chapter 15: File Input and Output.</p>"},{"location":"faq/#which-core-terms-from-the-learning-graph-should-i-actively-master","title":"Which core terms from the learning graph should I actively master?","text":"<p>You should prioritize the course's highest-leverage terms so chapter reading and coding practice reinforce each other. A practical approach is to track mastery weekly and validate each term with a tiny code example or short explanation. For example, you can pair one concept like <code>Loop Patterns</code> with a script that demonstrates accumulator and counter behavior. Start with this high-value set and use Glossary plus Concept List for deeper definitions:</p> <p><code>Computer Science</code>, <code>Computational Thinking</code>, <code>Algorithms</code>, <code>Abstraction</code>, <code>Decomposition</code>, <code>Pattern Recognition</code>, <code>Stepwise Refinement</code>, <code>Problem Solving</code>, <code>Binary Number System</code>, <code>Bits and Bytes</code>, <code>Character Encoding</code>, <code>ASCII and Unicode</code></p> <p><code>Computer Hardware</code>, <code>CPU and Memory</code>, <code>Input and Output Devices</code>, <code>Operating Systems</code>, <code>Programming Languages</code>, <code>Compiled vs Interpreted</code>, <code>Python Language</code>, <code>Python Interpreter</code>, <code>Python REPL</code>, <code>Python Scripts</code>, <code>Comments in Code</code>, <code>Variables</code></p> <p><code>Variable Assignment</code>, <code>Variable Naming Rules</code>, <code>Data Types</code>, <code>Integer Type</code>, <code>Float Type</code>, <code>Boolean Type</code>, <code>String Type</code>, <code>Type Function</code>, <code>Type Conversion</code>, <code>Implicit Type Conversion</code>, <code>Explicit Type Casting</code>, <code>Arithmetic Operators</code></p> <p><code>Integer Division</code>, <code>Modulo Operator</code>, <code>Operator Precedence</code>, <code>String Concatenation</code>, <code>String Repetition</code>, <code>F-String Formatting</code>, <code>Print Function</code>, <code>Input Function</code>, <code>Multiple Assignment</code>, <code>Constants Convention</code>, <code>Augmented Assignment</code>, <code>Expressions</code></p> <p><code>Statements</code>, <code>Code Readability</code>, <code>Boolean Expressions</code>, <code>Comparison Operators</code>, <code>Equal and Not Equal</code>, <code>Greater and Less Than</code>, <code>Logical Operators</code>, <code>And Operator</code>, <code>Or Operator</code>, <code>Not Operator</code>, <code>Short-Circuit Evaluation</code>, <code>Truthiness and Falsiness</code></p> <p><code>Boolean Conversion</code>, <code>Chained Comparisons</code>, <code>Order of Operations</code>, <code>De Morgan's Laws</code>, <code>Truth Tables</code>, <code>Control Flow</code>, <code>Sequential Execution</code>, <code>Conditional Statements</code>, <code>If Statement</code>, <code>If-Else Statement</code>, <code>Elif Statement</code>, <code>Nested Conditionals</code></p> <p><code>Ternary Expression</code>, <code>Match Statement</code>, <code>Loops</code>, <code>For Loop</code>, <code>While Loop</code>, <code>Range Function</code>, <code>Loop Variable</code>, <code>Loop Body</code>, <code>Infinite Loops</code>, <code>Break Statement</code>, <code>Continue Statement</code>, <code>Nested Loops</code></p> <p><code>Loop Patterns</code>, <code>Accumulator Pattern</code>, <code>Counter Pattern</code>, <code>Sentinel Value Pattern</code>, <code>Flag Variable Pattern</code>, <code>Loop Else Clause</code>, <code>String Basics</code>, <code>String Indexing</code>, <code>Negative Indexing</code>, <code>String Slicing</code>, <code>Slice Notation</code>, <code>String Immutability</code></p> <p><code>String Length</code>, <code>String Methods</code>, <code>Upper and Lower Methods</code>, <code>Strip Method</code>, <code>Split Method</code>, <code>Join Method</code>, <code>Find and Replace Methods</code>, <code>Startswith and Endswith</code>, <code>String Iteration</code>, <code>String Comparison</code>, <code>Escape Characters</code>, <code>Raw Strings</code></p> <p><code>Multiline Strings</code>, <code>String Formatting</code>, <code>Format Method</code>, <code>String Validation Methods</code>, <code>In Operator for Strings</code>, <code>Character Methods</code>, <code>String Reversal</code>, <code>Functions</code>, <code>Function Definition</code>, <code>Function Call</code>, <code>Parameters</code>, <code>Arguments</code></p> <p><code>Return Statement</code>, <code>Return Values</code>, <code>None Type</code>, <code>Default Parameters</code>, <code>Keyword Arguments</code>, <code>Positional Arguments</code>, <code>Multiple Return Values</code>, <code>Variable Scope</code>, <code>Local Variables</code>, <code>Global Variables</code>, <code>Global Keyword</code>, <code>Docstrings</code></p> <p><code>Function Documentation</code>, <code>Helper Functions</code>, <code>Main Function Pattern</code>, <code>Name Equals Main</code>, <code>Lambda Functions</code>, <code>Higher-Order Functions</code>, <code>Map Function</code>, <code>Filter Function</code>, <code>Reduce Function</code>, <code>Function Composition</code>, <code>Recursion</code>, <code>Base Case</code></p> <p><code>Recursive Case</code></p>"},{"location":"faq/#which-additional-terms-should-i-review-to-complete-concept-coverage","title":"Which additional terms should I review to complete concept coverage?","text":"<p>After mastering the core set, review the following terms to close concept gaps and improve transfer across chapters. For example, pairing each term with one quick code sketch or trace exercise makes retention much stronger than passive reading. Use Glossary as your canonical definition source:</p> <p><code>Recursive Call Stack</code>, <code>Stack Overflow</code>, <code>Recursion vs Iteration</code>, <code>Recursive Patterns</code>, <code>Memoization</code>, <code>List Creation</code>, <code>List Indexing</code>, <code>List Slicing</code>, <code>List Mutability</code>, <code>List Methods</code>, <code>Append Method</code>, <code>Insert Method</code></p> <p><code>Remove Method</code>, <code>Pop Method</code>, <code>Sort Method</code>, <code>Reverse Method</code>, <code>List Comprehension</code>, <code>Nested Lists</code>, <code>List of Lists</code>, <code>List Traversal</code>, <code>For Loop with Lists</code>, <code>Enumerate Function</code>, <code>List Unpacking</code>, <code>Zip Function</code></p> <p><code>List Copying</code>, <code>Shallow Copy</code>, <code>Deep Copy</code>, <code>List Concatenation</code>, <code>List Repetition</code>, <code>In Operator for Lists</code>, <code>Index Method</code>, <code>Count Method</code>, <code>Min Max Sum Functions</code>, <code>Len Function for Lists</code>, <code>Sorted Function</code>, <code>List as Stack</code></p> <p><code>List as Queue</code>, <code>List Aliasing</code>, <code>Identity vs Equality</code>, <code>Tuple Creation</code>, <code>Tuple Immutability</code>, <code>Tuple Packing</code>, <code>Tuple Unpacking</code>, <code>Named Tuples</code>, <code>Tuple Methods</code>, <code>Tuples as Keys</code>, <code>Tuples vs Lists</code>, <code>Set Creation</code></p> <p><code>Set Operations</code>, <code>Set Union</code>, <code>Set Intersection</code>, <code>Set Difference</code>, <code>Set Symmetric Difference</code>, <code>Set Methods</code>, <code>Membership Testing</code>, <code>Frozenset</code>, <code>Removing Duplicates</code>, <code>Dictionary Creation</code>, <code>Key-Value Pairs</code>, <code>Dictionary Access</code></p> <p>Additional high-value terms to include in your spaced review set: <code>Dictionary Methods</code>, <code>Get Method</code>, <code>Keys Method</code>, <code>Values Method</code>, <code>Items Method</code>, <code>Dictionary Iteration</code>, <code>Dictionary Comprehension</code>, <code>Nested Dictionaries</code>, <code>Default Values</code>, <code>Update Method</code>, <code>Pop Method for Dicts</code>, <code>Dictionary Merging</code>, <code>Counting with Dicts</code>, <code>Grouping with Dicts</code>, <code>Dictionary as Cache</code>, <code>Hashable Keys</code>, <code>Dict vs List Lookup</code>, <code>JSON and Dictionaries</code>, <code>OrderedDict</code>, <code>DefaultDict</code>.</p>"},{"location":"faq/#common-challenges","title":"Common Challenges","text":""},{"location":"faq/#why-do-my-loops-run-forever","title":"Why do my loops run forever?","text":"<p>Infinite loops usually happen when loop conditions never become false or update logic is missing. In <code>while</code> loops, verify the variable controlling termination changes each iteration. In <code>for</code> loops, logic errors often come from early <code>continue</code> or incorrect break conditions. For example, forgetting to increment a counter in <code>while i &lt; n</code> causes non-termination. Debug loop state with small prints or a debugger in Chapter 4.</p>"},{"location":"faq/#why-am-i-getting-off-by-one-errors","title":"Why am I getting off-by-one errors?","text":"<p>Off-by-one errors occur when boundaries are misinterpreted, especially with <code>range</code>, indexing, and slicing. Python ranges are start-inclusive and stop-exclusive, so <code>range(0, n)</code> produces <code>n</code> values ending at <code>n-1</code>. For example, iterating to <code>len(items)</code> and indexing directly can raise an error at the final step. Recheck bounds and test edge inputs in Chapter 4 and Chapter 8.</p>"},{"location":"faq/#why-does-my-function-return-none-unexpectedly","title":"Why does my function return <code>None</code> unexpectedly?","text":"<p>A function returns <code>None</code> when execution reaches the end without an explicit <code>return</code> value. This often happens in branches where one path returns data and another path does not. For example, a validation function may return <code>True</code> on success but forget <code>False</code> on failure. Make all return paths explicit and test each branch. See return-value design in Chapter 6.</p>"},{"location":"faq/#why-does-recursion-fail-with-maximum-depth-errors","title":"Why does recursion fail with maximum depth errors?","text":"<p>Recursion depth errors usually mean the base case is missing, unreachable, or incorrect. Each recursive call must move closer to termination; otherwise the call stack grows until Python stops execution. For example, decrementing the wrong variable can prevent progress to the base case. Trace input transitions and validate base cases first. Use Chapter 7 for structured debugging strategies.</p>"},{"location":"faq/#why-do-dictionary-key-errors-happen","title":"Why do dictionary key errors happen?","text":"<p>A <code>KeyError</code> occurs when you access a key that is not present in a dictionary. This is common with user input, optional fields, or inconsistent data sources. For example, <code>record['email']</code> fails if <code>email</code> is missing, while <code>record.get('email')</code> handles absence gracefully. Add key checks or defaults where data is uncertain. Robust patterns appear in Chapter 11 and Chapter 14.</p>"},{"location":"faq/#why-do-tests-pass-locally-but-fail-later","title":"Why do tests pass locally but fail later?","text":"<p>Tests can pass locally yet fail later when they rely on hidden state, environment assumptions, or non-deterministic behavior. Common causes include shared mutable objects, time-dependent logic, and ordering assumptions in collections. For example, one test may mutate global state used by another test. Isolate test setup and teardown, and keep test inputs deterministic. See reliability practices in Chapter 17.</p>"},{"location":"faq/#best-practice-questions","title":"Best Practice Questions","text":""},{"location":"faq/#how-should-i-structure-a-medium-size-python-program","title":"How should I structure a medium-size Python program?","text":"<p>Structure programs with clear modules, single-purpose functions, and explicit data flow between components. Keep business logic separate from input/output so you can test core behavior independently. For example, compute results in pure functions and keep file or console interactions in thin wrapper functions. This pattern improves maintainability and reuse. Apply the approach from Chapter 16: Software Engineering and Chapter 6.</p>"},{"location":"faq/#when-should-i-choose-a-dictionary-over-a-list","title":"When should I choose a dictionary over a list?","text":"<p>Choose a dictionary when you need fast lookup by meaningful keys; choose a list when order and sequential processing are primary. For example, student records keyed by student ID fit a dictionary, while an ordered daily task queue fits a list. Choosing by access pattern prevents awkward code and reduces complexity. Compare use cases in Chapter 8 and Chapter 11.</p>"},{"location":"faq/#how-can-i-write-code-that-is-easy-to-debug","title":"How can I write code that is easy to debug?","text":"<p>Write small functions, name variables for intent, and add focused checks at boundaries where bad data enters. Keep side effects explicit and avoid deeply nested logic when possible. For example, returning early on invalid input simplifies the happy-path flow and makes failures obvious. Pair these habits with repeatable tests for confidence. Debuggable design is emphasized in Chapter 17 and Chapter 16.</p>"},{"location":"faq/#what-is-a-good-strategy-for-incremental-problem-solving","title":"What is a good strategy for incremental problem solving?","text":"<p>Use iterative refinement: start with a minimal working solution, verify correctness, then optimize only where needed. This reduces risk and keeps bugs localized to small changes. For example, first solve search with a simple linear method, then switch to binary search only after confirming sorted input assumptions. This strategy balances speed and reliability. See Chapter 1 and Chapter 19.</p>"},{"location":"faq/#how-do-i-balance-readability-and-performance","title":"How do I balance readability and performance?","text":"<p>Prioritize readable, correct code first, then optimize measured bottlenecks. Premature optimization increases complexity without proven benefit. For example, replacing clear loops with obscure micro-optimizations can hurt maintainability more than it helps runtime. Use profiling or timing for evidence before refactoring. Tradeoff analysis and practical optimization are covered in Chapter 19 and Chapter 16.</p>"},{"location":"faq/#what-documentation-should-accompany-my-code","title":"What documentation should accompany my code?","text":"<p>At minimum, include module purpose, function docstrings, parameter and return expectations, and examples for non-obvious behavior. Documentation should explain intent and constraints, not restate syntax. For example, a docstring for a parser should describe accepted format and failure modes. Good documentation lowers onboarding time and improves correctness in team settings. See conventions in Chapter 6.</p>"},{"location":"faq/#advanced-topics","title":"Advanced Topics","text":""},{"location":"faq/#how-should-i-choose-between-iterative-and-recursive-designs-in-production-code","title":"How should I choose between iterative and recursive designs in production code?","text":"<p>Use recursion when it best expresses the domain and depth is controlled; prefer iteration when depth may grow unpredictably or when performance and stack safety are priorities. For example, tree traversal is often clearer recursively, while large linear processing is usually safer iteratively. Evaluate maintainability, correctness, and resource constraints together. Compare implementations in Chapter 7 and Chapter 19.</p>"},{"location":"faq/#when-do-decorators-provide-real-value","title":"When do decorators provide real value?","text":"<p>Decorators are valuable when you need reusable cross-cutting behavior such as logging, timing, retries, access control, or caching without rewriting business logic. They keep core functions focused while adding standardized behavior externally. For example, a timing decorator can benchmark multiple algorithms with consistent instrumentation. Use decorators carefully to avoid hidden control flow that confuses beginners. Advanced usage appears in Chapter 20.</p>"},{"location":"faq/#how-can-i-design-for-extensibility-with-classes-and-polymorphism","title":"How can I design for extensibility with classes and polymorphism?","text":"<p>Design around stable interfaces and substitute implementations behind those interfaces. Keep shared contracts clear and avoid coupling client code to concrete class details. For example, a grading system can accept any object implementing <code>calculate_score()</code> rather than branching on class type. This reduces future rewrite costs when requirements grow. See architectural patterns in Chapter 13 and Chapter 16.</p>"},{"location":"faq/#what-are-practical-limits-of-big-o-in-real-projects","title":"What are practical limits of Big-O in real projects?","text":"<p>Big-O is essential for growth reasoning, but constants, memory locality, interpreter overhead, and input distribution also matter in practice. Two algorithms with the same Big-O can behave very differently on realistic data. For example, a theoretically optimal method may lose to a simpler one for small input sizes. Combine asymptotic analysis with measurement to choose responsibly. See Chapter 19.</p>"},{"location":"faq/#how-do-i-combine-testing-exceptions-and-logging-into-a-reliability-strategy","title":"How do I combine testing, exceptions, and logging into a reliability strategy?","text":"<p>Treat reliability as a system: tests catch regressions, exceptions enforce clear failure behavior, and logging preserves runtime evidence. For example, validate input early, raise precise exceptions, and log contextual details at failure boundaries. Then write tests for both success and failure paths. This integrated approach shortens incident diagnosis and stabilizes code changes over time. Combine practices from Chapter 14, Chapter 17, and Chapter 16.</p>"},{"location":"glossary/","title":"Glossary","text":""},{"location":"glossary/#glossary-of-terms","title":"Glossary of Terms","text":""},{"location":"glossary/#abstract-classes","title":"Abstract Classes","text":"<p>Classes that define required methods without providing full implementations.</p>"},{"location":"glossary/#abstraction","title":"Abstraction","text":"<p>The practice of hiding unnecessary detail to focus on the essential structure of a problem or system.</p> <p>See also: Decomposition, Pattern Recognition</p>"},{"location":"glossary/#accumulator-pattern","title":"Accumulator Pattern","text":"<p>A loop pattern that updates a running total or combined result across iterations.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#add-and-mul-methods","title":"Add and Mul Methods","text":"<p>The add and mul methods that define + and * behavior for objects.</p>"},{"location":"glossary/#algorithm-correctness","title":"Algorithm Correctness","text":"<p>The property that an algorithm always produces the correct result for valid inputs.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#algorithm-design","title":"Algorithm Design","text":"<p>The process of creating an algorithm to solve a problem efficiently.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#algorithm-tradeoffs","title":"Algorithm Tradeoffs","text":"<p>Balancing factors like speed, memory, and code simplicity when choosing an algorithm.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#algorithm-visualization","title":"Algorithm Visualization","text":"<p>Using visual tools or diagrams to illustrate how an algorithm works.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#algorithms","title":"Algorithms","text":"<p>Step-by-step procedures for solving a problem or performing a computation with well-defined inputs, outputs, and termination.</p>"},{"location":"glossary/#and-operator","title":"And Operator","text":"<p>The logical operator that returns True only when both operands are True.</p> <p>Example: result = a + b</p>"},{"location":"glossary/#append-method","title":"Append Method","text":"<p>In Python lists, the append method adds an item to the end.</p> <p>Example: nums.append(10)</p>"},{"location":"glossary/#args-and-kwargs","title":"Args and Kwargs","text":"<p>Conventions for accepting variable positional and keyword arguments in functions.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#arguments","title":"Arguments","text":"<p>Actual values passed into a function when it is called.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#arithmetic-operators","title":"Arithmetic Operators","text":"<p>Symbols that perform basic math operations like addition, subtraction, multiplication, and division.</p> <p>Example: result = a + b</p>"},{"location":"glossary/#ascii-and-unicode","title":"ASCII and Unicode","text":"<p>Standards for encoding characters as numbers, with Unicode covering far more symbols and languages than ASCII.</p>"},{"location":"glossary/#assert-statements","title":"Assert Statements","text":"<p>Statements used to verify conditions during testing or debugging.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#assertions","title":"Assertions","text":"<p>Statements that check assumptions and raise an error if the condition is false.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#augmented-assignment","title":"Augmented Assignment","text":"<p>A core concept in this course that supports understanding and writing Python programs.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#base-case","title":"Base Case","text":"<p>The terminating condition in a recursive function that does not make another recursive call.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#best-average-worst-case","title":"Best Average Worst Case","text":"<p>The range of performance outcomes for an algorithm under different inputs.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#big-o-notation","title":"Big-O Notation","text":"<p>Notation for describing how algorithm resource use grows with input size.</p> <p>Example: see chapter for usage</p> <p>See also: Time Complexity, Space Complexity</p>"},{"location":"glossary/#binary-number-system","title":"Binary Number System","text":"<p>A base-2 number system that represents values using only 0 and 1, fundamental to digital computation.</p>"},{"location":"glossary/#binary-search","title":"Binary Search","text":"<p>Searching a sorted list by repeatedly halving the search interval.</p> <p>Example: index = binary_search(sorted_list, target)</p> <p>Contrast with: Linear Search</p>"},{"location":"glossary/#bits-and-bytes","title":"Bits and Bytes","text":"<p>A bit is a single binary digit, and a byte is a group of eight bits used to represent data.</p>"},{"location":"glossary/#boolean-conversion","title":"Boolean Conversion","text":"<p>A core concept in this course that supports understanding and writing Python programs.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#boolean-expressions","title":"Boolean Expressions","text":"<p>Expressions that evaluate to True or False.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#boolean-type","title":"Boolean Type","text":"<p>A data type that represents boolean values and determines valid operations on them.</p> <p>Example: count = 3  # int</p>"},{"location":"glossary/#boundary-testing","title":"Boundary Testing","text":"<p>Testing at the edges of allowed input ranges.</p> <p>Example: assert add(2,3) == 5</p>"},{"location":"glossary/#break-statement","title":"Break Statement","text":"<p>A Python statement that controls program behavior using the break keyword.</p> <p>Example: if x &gt; 0: ...</p>"},{"location":"glossary/#breakpoints","title":"Breakpoints","text":"<p>Markers that pause program execution in a debugger.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#brute-force-approach","title":"Brute Force Approach","text":"<p>Solving a problem by trying all possibilities without optimization.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#chained-comparisons","title":"Chained Comparisons","text":"<p>A core concept in this course that supports understanding and writing Python programs.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#character-encoding","title":"Character Encoding","text":"<p>A mapping from characters to numeric codes so text can be stored and processed by computers.</p>"},{"location":"glossary/#character-methods","title":"Character Methods","text":"<p>Built-in operations attached to objects that perform a specific task.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#child-class","title":"Child Class","text":"<p>A class that inherits from a parent class.</p>"},{"location":"glossary/#class-attributes","title":"Class Attributes","text":"<p>Data stored on the class itself and shared by all instances.</p>"},{"location":"glossary/#class-definition","title":"Class Definition","text":"<p>The code block that declares a class, its attributes, and its methods.</p>"},{"location":"glossary/#class-hierarchies","title":"Class Hierarchies","text":"<p>The tree-like structure formed by inheritance relationships among classes.</p>"},{"location":"glossary/#class-instantiation","title":"Class Instantiation","text":"<p>Creating a new object from a class.</p>"},{"location":"glossary/#class-methods","title":"Class Methods","text":"<p>Methods that receive the class as the first argument, defined with the @classmethod decorator.</p>"},{"location":"glossary/#classes","title":"Classes","text":"<p>Blueprints for creating objects with shared structure and behavior.</p>"},{"location":"glossary/#closures","title":"Closures","text":"<p>Functions that remember and access variables from their defining scope.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#code-comments","title":"Code Comments","text":"<p>Notes in code that explain intent, reasoning, or usage.</p>"},{"location":"glossary/#code-organization","title":"Code Organization","text":"<p>Arranging files, functions, and classes for clarity and maintainability.</p>"},{"location":"glossary/#code-readability","title":"Code Readability","text":"<p>How easy it is for humans to understand code based on naming, structure, and clarity.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#code-review","title":"Code Review","text":"<p>Systematic examination of code by peers to improve quality.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#code-style","title":"Code Style","text":"<p>Consistent formatting and conventions that improve readability.</p>"},{"location":"glossary/#code-tracing","title":"Code Tracing","text":"<p>Following code execution manually or with tools to understand program flow.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#collections-module","title":"Collections Module","text":"<p>A Python standard library module that provides specialized container data types.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#comments-in-code","title":"Comments in Code","text":"<p>Text in source code intended for human readers that the interpreter ignores.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#comparison-operators","title":"Comparison Operators","text":"<p>Operators that compare two values and return a boolean result.</p> <p>Example: result = a + b</p>"},{"location":"glossary/#compiled-vs-interpreted","title":"Compiled vs Interpreted","text":"<p>A contrast between languages translated ahead of time into machine code and languages executed line-by-line by an interpreter.</p>"},{"location":"glossary/#composition","title":"Composition","text":"<p>A design principle where objects are built from other objects to reuse functionality.</p>"},{"location":"glossary/#comprehension-patterns","title":"Comprehension Patterns","text":"<p>Reusable structures for list, set, and dictionary comprehensions.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#computational-thinking","title":"Computational Thinking","text":"<p>A problem-solving approach that uses decomposition, pattern recognition, abstraction, and algorithms to create solutions that a computer can execute.</p>"},{"location":"glossary/#computer-hardware","title":"Computer Hardware","text":"<p>The physical components of a computer system, such as CPU, memory, storage, and input/output devices.</p>"},{"location":"glossary/#computer-science","title":"Computer Science","text":"<p>The study of how to represent information, design algorithms, and build software and systems that solve problems efficiently and reliably.</p>"},{"location":"glossary/#conditional-statements","title":"Conditional Statements","text":"<p>Statements that execute different blocks of code based on a boolean condition.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#constant-time-o1","title":"Constant Time O(1)","text":"<p>A time complexity where runtime does not grow with input size.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#constants-convention","title":"Constants Convention","text":"<p>The practice of using uppercase names for values intended to remain unchanged.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#constructor","title":"Constructor","text":"<p>A method used to initialize a new object, typically init in Python.</p>"},{"location":"glossary/#context-manager-protocol","title":"Context Manager Protocol","text":"<p>The protocol that defines enter and exit for use with the with statement.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#context-managers","title":"Context Managers","text":"<p>Objects that manage setup and cleanup using the with statement.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#continue-statement","title":"Continue Statement","text":"<p>A Python statement that controls program behavior using the continue keyword.</p> <p>Example: if x &gt; 0: ...</p>"},{"location":"glossary/#control-flow","title":"Control Flow","text":"<p>The order in which statements in a program are executed.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#count-method","title":"Count Method","text":"<p>In Python lists, the count method counts occurrences of a value.</p> <p>Example: n = nums.count(0)</p>"},{"location":"glossary/#counter-class","title":"Counter Class","text":"<p>A collections module class for counting hashable items.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#counter-pattern","title":"Counter Pattern","text":"<p>A loop pattern that increments or decrements a variable to track counts or iterations.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#counting-operations","title":"Counting Operations","text":"<p>Estimating time by counting key steps an algorithm performs.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#counting-with-dicts","title":"Counting with Dicts","text":"<p>Using a dictionary to count occurrences of items.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#cpu-and-memory","title":"CPU and Memory","text":"<p>The CPU executes instructions while memory stores data and instructions needed during execution.</p>"},{"location":"glossary/#csv-files","title":"CSV Files","text":"<p>A core concept in this course that supports understanding and writing Python programs.</p> <p>Example: with open('data.txt') as f: text = f.read()</p>"},{"location":"glossary/#custom-exceptions","title":"Custom Exceptions","text":"<p>User-defined exception classes for domain-specific errors.</p> <p>Example: try: x = int(s) except ValueError: ...</p>"},{"location":"glossary/#data-types","title":"Data Types","text":"<p>Classifications of values that determine how they are stored and what operations are valid.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#dataclasses","title":"Dataclasses","text":"<p>A decorator-based way to create classes with auto-generated boilerplate methods.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#de-morgans-laws","title":"De Morgan's Laws","text":"<p>Logical equivalences that describe how negation distributes over and/or operations.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#debugger-tools","title":"Debugger Tools","text":"<p>Software tools that allow stepping through code and inspecting variables.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#debugging","title":"Debugging","text":"<p>The process of finding and fixing defects in code.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#decomposition","title":"Decomposition","text":"<p>Breaking a complex problem into smaller, manageable parts that can be solved independently.</p>"},{"location":"glossary/#decorators","title":"Decorators","text":"<p>Functions that wrap other functions to add behavior without modifying their source.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#deep-copy","title":"Deep Copy","text":"<p>A copy that duplicates the container and all nested objects it contains.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#default-parameters","title":"Default Parameters","text":"<p>A core concept in this course that supports understanding and writing Python programs.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#default-values","title":"Default Values","text":"<p>Fallback values used when a key is missing in a dictionary.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#defaultdict","title":"DefaultDict","text":"<p>A dictionary subclass that supplies default values for missing keys automatically.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#defensive-programming","title":"Defensive Programming","text":"<p>Writing code that anticipates and safely handles invalid input or conditions.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#design-patterns-intro","title":"Design Patterns Intro","text":"<p>An introduction to common reusable solutions to recurring software design problems.</p>"},{"location":"glossary/#dict-vs-list-lookup","title":"Dict vs List Lookup","text":"<p>A comparison showing dictionary lookup is typically faster than searching a list.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#dictionaries","title":"Dictionaries","text":"<p>Unordered collections of key-value pairs used for fast lookup.</p> <p>Example: see chapter for usage</p> <p>See also: Key-Value Pairs, Hashable Keys</p>"},{"location":"glossary/#dictionary-access","title":"Dictionary Access","text":"<p>A dictionary-related concept that describes how to store, access, or manipulate dictionary data in Python.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#dictionary-as-cache","title":"Dictionary as Cache","text":"<p>Storing computed results in a dictionary to avoid repeated work.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#dictionary-comprehension","title":"Dictionary Comprehension","text":"<p>A concise syntax for building dictionaries from iterables.</p> <p>Example: sq = {x: x*x for x in nums}</p>"},{"location":"glossary/#dictionary-creation","title":"Dictionary Creation","text":"<p>A dictionary-related concept that describes how to store, access, or manipulate dictionary data in Python.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#dictionary-iteration","title":"Dictionary Iteration","text":"<p>Looping over keys, values, or items in a dictionary.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#dictionary-merging","title":"Dictionary Merging","text":"<p>Combining two or more dictionaries into one.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#dictionary-methods","title":"Dictionary Methods","text":"<p>Built-in operations attached to objects that perform a specific task.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#divide-and-conquer","title":"Divide and Conquer","text":"<p>Solving a problem by splitting it into smaller parts, solving each, and combining results.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#docstrings","title":"Docstrings","text":"<p>String literals used to document modules, classes, and functions in Python.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#documentation","title":"Documentation","text":"<p>Written explanations of how software works and how to use it.</p>"},{"location":"glossary/#dry-principle","title":"DRY Principle","text":"<p>Don't Repeat Yourself, a principle that avoids duplication in code.</p>"},{"location":"glossary/#duck-typing","title":"Duck Typing","text":"<p>A style where an object's suitability is determined by its behavior rather than its type.</p>"},{"location":"glossary/#dunder-methods","title":"Dunder Methods","text":"<p>Special methods with double underscores that define built-in behavior.</p>"},{"location":"glossary/#edge-cases","title":"Edge Cases","text":"<p>Unusual or extreme inputs that can reveal bugs.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#efficiency-vs-readability","title":"Efficiency vs Readability","text":"<p>A tradeoff between optimized performance and clear, maintainable code.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#elif-statement","title":"Elif Statement","text":"<p>A Python statement that controls program behavior using the elif keyword.</p> <p>Example: if x &gt; 0: ...</p>"},{"location":"glossary/#empirical-analysis","title":"Empirical Analysis","text":"<p>Measuring performance by running experiments rather than analyzing formulas.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#encapsulation","title":"Encapsulation","text":"<p>The practice of bundling data and methods together and restricting direct access to internal state.</p> <p>See also: Private Attributes, Property Decorator</p>"},{"location":"glossary/#enum-type","title":"Enum Type","text":"<p>A class that defines a fixed set of named constant values.</p> <p>Example: count = 3  # int</p>"},{"location":"glossary/#enumerate-function","title":"Enumerate Function","text":"<p>A built-in function that yields pairs of index and value from an iterable.</p> <p>Example: for i, v in enumerate(items): ...</p>"},{"location":"glossary/#eq-and-lt-methods","title":"Eq and Lt Methods","text":"<p>The eq and lt methods that define equality and less-than comparisons for objects.</p>"},{"location":"glossary/#equal-and-not-equal","title":"Equal and Not Equal","text":"<p>The == and != operators for testing equality or inequality.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#errors-and-exceptions","title":"Errors and Exceptions","text":"<p>Problems that occur during program execution and the objects used to represent them.</p> <p>Example: try: x = int(s) except ValueError: ...</p>"},{"location":"glossary/#escape-characters","title":"Escape Characters","text":"<p>A string-related concept that describes how to store, access, or manipulate string data in Python.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#exception-types","title":"Exception Types","text":"<p>Different categories of exceptions that signal specific error conditions.</p> <p>Example: try: x = int(s) except ValueError: ...</p>"},{"location":"glossary/#explicit-type-casting","title":"Explicit Type Casting","text":"<p>Manual conversion of a value from one type to another using functions like int(), float(), or str().</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#expressions","title":"Expressions","text":"<p>A combination of values, variables, and operators that produces a result when evaluated.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#f-string-formatting","title":"F-String Formatting","text":"<p>A core concept in this course that supports understanding and writing Python programs.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#file-exceptions","title":"File Exceptions","text":"<p>A core concept in this course that supports understanding and writing Python programs.</p> <p>Example: with open('data.txt') as f: text = f.read()</p>"},{"location":"glossary/#file-input-output","title":"File Input Output","text":"<p>Reading data from files and writing data to files.</p> <p>Example: with open('data.txt') as f: text = f.read()</p>"},{"location":"glossary/#file-modes","title":"File Modes","text":"<p>A core concept in this course that supports understanding and writing Python programs.</p> <p>Example: with open('data.txt') as f: text = f.read()</p>"},{"location":"glossary/#file-paths","title":"File Paths","text":"<p>Strings that specify file locations in a file system.</p> <p>Example: with open('data.txt') as f: text = f.read()</p>"},{"location":"glossary/#filter-function","title":"Filter Function","text":"<p>A function that keeps items from an iterable that satisfy a predicate function.</p> <p>Example: evens = list(filter(lambda x: x%2==0, nums))</p>"},{"location":"glossary/#finally-block","title":"Finally Block","text":"<p>A block that runs after try/except, whether or not an exception occurred.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#find-and-replace-methods","title":"Find and Replace Methods","text":"<p>Built-in operations attached to objects that perform a specific task.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#flag-variable-pattern","title":"Flag Variable Pattern","text":"<p>A loop pattern that uses a boolean variable to remember whether a condition has occurred.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#float-type","title":"Float Type","text":"<p>A data type that represents float values and determines valid operations on them.</p> <p>Example: count = 3  # int</p>"},{"location":"glossary/#flowcharts","title":"Flowcharts","text":"<p>Diagrams that show the steps and decision points in an algorithm or process.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#for-loop","title":"For Loop","text":"<p>A control structure that repeats a block of code, based on a condition or sequence.</p> <p>Example: for item in items: ...</p>"},{"location":"glossary/#for-loop-with-lists","title":"For Loop with Lists","text":"<p>A list-related concept that describes how to store, access, or manipulate list data in Python.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#format-method","title":"Format Method","text":"<p>Built-in operations attached to objects that perform a specific task.</p> <p>Example: s.upper()</p>"},{"location":"glossary/#frequency-counter-pattern","title":"Frequency Counter Pattern","text":"<p>An algorithm pattern that uses a dictionary to count occurrences for efficient comparison.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#frozenset","title":"Frozenset","text":"<p>An immutable version of a set that can be used as a dictionary key or set element.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#function-call","title":"Function Call","text":"<p>The act of executing a function using its name and arguments.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#function-composition","title":"Function Composition","text":"<p>A core concept in this course that supports understanding and writing Python programs.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#function-definition","title":"Function Definition","text":"<p>The code that specifies a function's name, parameters, and body.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#function-documentation","title":"Function Documentation","text":"<p>A core concept in this course that supports understanding and writing Python programs.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#functions","title":"Functions","text":"<p>Reusable blocks of code that perform a specific task and can return a value.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#functools-module","title":"Functools Module","text":"<p>A standard library module with higher-order functions and tools for function manipulation.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#generator-expressions","title":"Generator Expressions","text":"<p>Compact expressions that create generators without storing all results in memory.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#generators","title":"Generators","text":"<p>Functions that yield values lazily, producing items one at a time.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#get-method","title":"Get Method","text":"<p>In Python dictionaries, the get method returns a value for a key with a default.</p> <p>Example: age = d.get(\"age\", 0)</p>"},{"location":"glossary/#getter-methods","title":"Getter Methods","text":"<p>Methods used to access attribute values safely.</p>"},{"location":"glossary/#git-basics","title":"Git Basics","text":"<p>Core concepts and commands for using Git version control.</p>"},{"location":"glossary/#global-keyword","title":"Global Keyword","text":"<p>A Python keyword used to assign to a global variable inside a function.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#global-variables","title":"Global Variables","text":"<p>A variable-related concept describing how names store or track values during program execution.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#greater-and-less-than","title":"Greater and Less Than","text":"<p>The &lt;, &lt;=, &gt;, and &gt;= operators used for ordering comparisons.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#greedy-algorithms","title":"Greedy Algorithms","text":"<p>Algorithms that make the locally optimal choice at each step.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#grouping-with-dicts","title":"Grouping with Dicts","text":"<p>Using a dictionary to group items under shared keys.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#has-a-relationship","title":"Has-A Relationship","text":"<p>An object-oriented relationship where one object contains or uses another.</p>"},{"location":"glossary/#hashable-keys","title":"Hashable Keys","text":"<p>Keys that have a stable hash value, required for dictionary key usage.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#helper-functions","title":"Helper Functions","text":"<p>A core concept in this course that supports understanding and writing Python programs.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#higher-order-functions","title":"Higher-Order Functions","text":"<p>Functions that take other functions as arguments or return functions as results.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#identity-vs-equality","title":"Identity vs Equality","text":"<p>A distinction between two references pointing to the same object (identity) and two objects having the same value (equality).</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#if-statement","title":"If Statement","text":"<p>A Python statement that controls program behavior using the if keyword.</p> <p>Example: if x &gt; 0: ...</p>"},{"location":"glossary/#if-else-statement","title":"If-Else Statement","text":"<p>A Python statement that controls program behavior using the if-else keyword.</p> <p>Example: if x &gt; 0: ...</p>"},{"location":"glossary/#implicit-type-conversion","title":"Implicit Type Conversion","text":"<p>Automatic conversion performed by Python when combining compatible types, such as int to float.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#import-statements","title":"Import Statements","text":"<p>Statements that load modules so their functionality can be used.</p>"},{"location":"glossary/#in-operator-for-lists","title":"In Operator for Lists","text":"<p>The in operator used to test whether an item appears in a list.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#in-operator-for-strings","title":"In Operator for Strings","text":"<p>The in operator used to test whether a substring appears in a string.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#index-method","title":"Index Method","text":"<p>In Python lists, the index method returns the position of a value.</p> <p>Example: i = nums.index(42)</p>"},{"location":"glossary/#indexerror","title":"IndexError","text":"<p>An error-handling concept describing how programs detect, represent, or respond to problems.</p> <p>Example: try: x = int(s) except ValueError: ...</p>"},{"location":"glossary/#infinite-loops","title":"Infinite Loops","text":"<p>Loops that never terminate because their exit condition is never met.</p> <p>Example: for item in items: ...</p>"},{"location":"glossary/#inheritance","title":"Inheritance","text":"<p>An object-oriented mechanism where a class derives behavior and data from a parent class.</p> <p>See also: Parent Class, Child Class, Polymorphism</p>"},{"location":"glossary/#init-method","title":"Init Method","text":"<p>The special init method that initializes a new object after creation.</p>"},{"location":"glossary/#input-and-output-devices","title":"Input and Output Devices","text":"<p>Hardware used to provide data to a computer or receive results, such as keyboards, sensors, monitors, and printers.</p>"},{"location":"glossary/#input-function","title":"Input Function","text":"<p>A built-in function that reads a line of text from the user and returns it as a string.</p> <p>Example: name = input(\"Name? \")</p>"},{"location":"glossary/#input-validation","title":"Input Validation","text":"<p>Checking that input data meets expected constraints before processing.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#insert-method","title":"Insert Method","text":"<p>In Python lists, the insert method inserts an item at a specific position.</p> <p>Example: nums.insert(1, 42)</p>"},{"location":"glossary/#insertion-sort","title":"Insertion Sort","text":"<p>A sorting algorithm that builds a sorted list by inserting items in order.</p> <p>Example: sorted_list = insertion_sort(data)</p>"},{"location":"glossary/#instance-attributes","title":"Instance Attributes","text":"<p>Data stored on individual objects rather than shared across all instances.</p>"},{"location":"glossary/#instance-methods","title":"Instance Methods","text":"<p>Methods that receive the instance as the first parameter and operate on instance data.</p>"},{"location":"glossary/#integer-division","title":"Integer Division","text":"<p>Division that discards any fractional part, returning an integer result.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#integer-type","title":"Integer Type","text":"<p>A data type that represents integer values and determines valid operations on them.</p> <p>Example: count = 3  # int</p>"},{"location":"glossary/#is-a-relationship","title":"Is-A Relationship","text":"<p>An object-oriented relationship indicating a subclass is a specialized form of its parent.</p>"},{"location":"glossary/#items-method","title":"Items Method","text":"<p>In Python dictionaries, the items method returns key-value pairs.</p> <p>Example: for k, v in d.items(): ...</p>"},{"location":"glossary/#iterable-protocol","title":"Iterable Protocol","text":"<p>The requirement that an object implement iter or getitem to be iterable.</p>"},{"location":"glossary/#iterator-protocol","title":"Iterator Protocol","text":"<p>The requirement that an iterator implement iter and next.</p>"},{"location":"glossary/#itertools-module","title":"Itertools Module","text":"<p>A standard library module that provides efficient tools for iterator-based looping.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#join-method","title":"Join Method","text":"<p>In Python strings, the join method concatenates items with a separator and returns a new string.</p> <p>Example: \",\".join(words)</p>"},{"location":"glossary/#json-and-dictionaries","title":"JSON and Dictionaries","text":"<p>A relationship where JSON objects map naturally to Python dictionaries.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#json-files","title":"JSON Files","text":"<p>A core concept in this course that supports understanding and writing Python programs.</p> <p>Example: with open('data.txt') as f: text = f.read()</p>"},{"location":"glossary/#key-value-pairs","title":"Key-Value Pairs","text":"<p>Paired data where a key uniquely identifies a value.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#keyerror","title":"KeyError","text":"<p>An error-handling concept describing how programs detect, represent, or respond to problems.</p> <p>Example: try: x = int(s) except ValueError: ...</p>"},{"location":"glossary/#keys-method","title":"Keys Method","text":"<p>In Python dictionaries, the keys method returns a view of keys.</p> <p>Example: for k in d.keys(): ...</p>"},{"location":"glossary/#keyword-arguments","title":"Keyword Arguments","text":"<p>A core concept in this course that supports understanding and writing Python programs.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#kiss-principle","title":"KISS Principle","text":"<p>Keep It Simple, a principle that favors simple, clear solutions.</p>"},{"location":"glossary/#lambda-functions","title":"Lambda Functions","text":"<p>Small anonymous functions defined with the lambda keyword, typically for short, simple operations.</p> <p>Example: key=lambda x: x[1]</p>"},{"location":"glossary/#len-function-for-lists","title":"Len Function for Lists","text":"<p>A built-in function that returns the number of items in a list.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#linear-search","title":"Linear Search","text":"<p>Searching for a target by checking items one by one.</p> <p>Example: index = linear_search(data, target)</p>"},{"location":"glossary/#linear-time-on","title":"Linear Time O(n)","text":"<p>A time complexity where runtime grows proportionally to input size.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#linearithmic-time","title":"Linearithmic Time","text":"<p>A time complexity of O(n log n), common in efficient sorting algorithms.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#linting-tools","title":"Linting Tools","text":"<p>Programs that analyze code for style issues and potential bugs.</p>"},{"location":"glossary/#list-aliasing","title":"List Aliasing","text":"<p>When two variables reference the same list object, so changes via one name affect the other.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#list-as-queue","title":"List as Queue","text":"<p>Using a list with pop(0) or collections.deque to model first-in, first-out behavior.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#list-as-stack","title":"List as Stack","text":"<p>Using a list with append and pop to model last-in, first-out behavior.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#list-comprehension","title":"List Comprehension","text":"<p>A concise syntax for creating lists by transforming or filtering items from an iterable.</p> <p>Example: squares = [x*x for x in nums]</p>"},{"location":"glossary/#list-concatenation","title":"List Concatenation","text":"<p>A list-related concept that describes how to store, access, or manipulate list data in Python.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#list-copying","title":"List Copying","text":"<p>A list-related concept that describes how to store, access, or manipulate list data in Python.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#list-creation","title":"List Creation","text":"<p>A list-related concept that describes how to store, access, or manipulate list data in Python.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#list-indexing","title":"List Indexing","text":"<p>A list-related concept that describes how to store, access, or manipulate list data in Python.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#list-methods","title":"List Methods","text":"<p>Built-in operations attached to objects that perform a specific task.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#list-mutability","title":"List Mutability","text":"<p>The ability to change list contents in place after creation.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#list-of-lists","title":"List of Lists","text":"<p>A list-related concept that describes how to store, access, or manipulate list data in Python.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#list-repetition","title":"List Repetition","text":"<p>A list-related concept that describes how to store, access, or manipulate list data in Python.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#list-slicing","title":"List Slicing","text":"<p>A list-related concept that describes how to store, access, or manipulate list data in Python.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#list-traversal","title":"List Traversal","text":"<p>A list-related concept that describes how to store, access, or manipulate list data in Python.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#list-unpacking","title":"List Unpacking","text":"<p>A list-related concept that describes how to store, access, or manipulate list data in Python.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#list-vs-generator-memory","title":"List vs Generator Memory","text":"<p>A comparison of memory use when building full lists versus generating values lazily.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#lists","title":"Lists","text":"<p>Ordered, mutable collections of items in Python.</p> <p>Example: data = [1, 2, 3]</p> <p>See also: Tuples, Sets, Dictionaries</p>"},{"location":"glossary/#local-variables","title":"Local Variables","text":"<p>A variable-related concept describing how names store or track values during program execution.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#logarithmic-time-olog-n","title":"Logarithmic Time O(log n)","text":"<p>A time complexity where runtime grows slowly as input size increases by factors.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#logic-errors","title":"Logic Errors","text":"<p>Bugs where the program runs but produces incorrect results.</p> <p>Example: try: x = int(s) except ValueError: ...</p>"},{"location":"glossary/#logical-operators","title":"Logical Operators","text":"<p>Operators that combine or negate boolean expressions to form more complex logic.</p> <p>Example: result = a + b</p>"},{"location":"glossary/#loop-body","title":"Loop Body","text":"<p>A core concept in this course that supports understanding and writing Python programs.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#loop-else-clause","title":"Loop Else Clause","text":"<p>A core concept in this course that supports understanding and writing Python programs.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#loop-invariants","title":"Loop Invariants","text":"<p>Statements that remain true before and after each loop iteration, used in correctness proofs.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#loop-patterns","title":"Loop Patterns","text":"<p>Common ways of structuring loops to solve tasks such as counting, searching, or accumulating results.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#loop-variable","title":"Loop Variable","text":"<p>A variable-related concept describing how names store or track values during program execution.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#loops","title":"Loops","text":"<p>Control structures that repeat a block of code while a condition holds or for a sequence.</p> <p>Example: for item in items: ...</p>"},{"location":"glossary/#main-function-pattern","title":"Main Function Pattern","text":"<p>A reusable structure for solving a common programming problem in a consistent way.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#manual-testing","title":"Manual Testing","text":"<p>Testing by running a program and checking outputs by hand.</p> <p>Example: assert add(2,3) == 5</p>"},{"location":"glossary/#map-function","title":"Map Function","text":"<p>A function that applies another function to each item in an iterable.</p> <p>Example: squares = list(map(lambda x: x*x, nums))</p>"},{"location":"glossary/#match-statement","title":"Match Statement","text":"<p>A Python 3.10+ control structure for pattern-based branching.</p> <p>Example: if x &gt; 0: ...</p>"},{"location":"glossary/#membership-testing","title":"Membership Testing","text":"<p>A set-related concept that describes how to store, access, or manipulate set data in Python.</p> <p>Example: assert add(2,3) == 5</p>"},{"location":"glossary/#memoization","title":"Memoization","text":"<p>A technique that caches function results to avoid repeated computation.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#merge-sort","title":"Merge Sort","text":"<p>A divide-and-conquer sorting algorithm that merges sorted halves.</p> <p>Example: sorted_list = merge_sort(data)</p> <p>See also: Divide and Conquer</p>"},{"location":"glossary/#merge-sort-recursion","title":"Merge Sort Recursion","text":"<p>An algorithm concept describing a method, comparison, or analysis technique for solving problems.</p> <p>Example: sorted_list = insertion_sort(data)</p>"},{"location":"glossary/#method-overriding","title":"Method Overriding","text":"<p>Replacing a parent class method with a new implementation in a child class.</p>"},{"location":"glossary/#method-resolution-order","title":"Method Resolution Order","text":"<p>The rule Python uses to decide which parent method to call in multiple inheritance.</p>"},{"location":"glossary/#methods","title":"Methods","text":"<p>Functions defined inside a class that operate on objects or class state.</p>"},{"location":"glossary/#min-max-sum-functions","title":"Min Max Sum Functions","text":"<p>Built-in functions that compute the minimum, maximum, and sum of numeric values.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#modular-design","title":"Modular Design","text":"<p>Structuring software as independent, reusable components.</p>"},{"location":"glossary/#modulo-operator","title":"Modulo Operator","text":"<p>The % operator that returns the remainder of integer division.</p> <p>Example: result = a + b</p>"},{"location":"glossary/#multiline-strings","title":"Multiline Strings","text":"<p>A string-related concept that describes how to store, access, or manipulate string data in Python.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#multiple-assignment","title":"Multiple Assignment","text":"<p>A core concept in this course that supports understanding and writing Python programs.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#multiple-except-blocks","title":"Multiple Except Blocks","text":"<p>An error-handling concept describing how programs detect, represent, or respond to problems.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#multiple-inheritance","title":"Multiple Inheritance","text":"<p>A feature where a class inherits from more than one parent class.</p>"},{"location":"glossary/#multiple-return-values","title":"Multiple Return Values","text":"<p>A core concept in this course that supports understanding and writing Python programs.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#name-equals-main","title":"Name Equals Main","text":"<p>The Python pattern if name == 'main': used to run code only when a file is executed directly.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#named-tuples","title":"Named Tuples","text":"<p>Tuple-like objects with named fields for clearer access.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#negative-indexing","title":"Negative Indexing","text":"<p>A string-related concept that describes how to store, access, or manipulate string data in Python.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#nested-conditionals","title":"Nested Conditionals","text":"<p>A core concept in this course that supports understanding and writing Python programs.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#nested-dictionaries","title":"Nested Dictionaries","text":"<p>Dictionaries that store other dictionaries as values.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#nested-lists","title":"Nested Lists","text":"<p>Lists that contain other lists as elements.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#nested-loops","title":"Nested Loops","text":"<p>A control structure that repeats a block of code, based on a condition or sequence.</p> <p>Example: for item in items: ...</p>"},{"location":"glossary/#none-type","title":"None Type","text":"<p>The special type of the value None, used to represent the absence of a value.</p> <p>Example: count = 3  # int</p>"},{"location":"glossary/#not-operator","title":"Not Operator","text":"<p>The logical operator that negates a boolean value.</p> <p>Example: result = a + b</p>"},{"location":"glossary/#object-comparison","title":"Object Comparison","text":"<p>Comparing objects for equality or ordering using defined methods or operators.</p>"},{"location":"glossary/#object-identity","title":"Object Identity","text":"<p>The unique identity of an object in memory, accessible via id().</p>"},{"location":"glossary/#object-oriented-programming","title":"Object-Oriented Programming","text":"<p>A programming paradigm that organizes software around objects that combine data and behavior.</p>"},{"location":"glossary/#objects","title":"Objects","text":"<p>Instances of classes that store state and provide behavior through methods.</p>"},{"location":"glossary/#opening-files","title":"Opening Files","text":"<p>A core concept in this course that supports understanding and writing Python programs.</p> <p>Example: with open('data.txt') as f: text = f.read()</p>"},{"location":"glossary/#operating-systems","title":"Operating Systems","text":"<p>System software that manages hardware resources and provides services to applications.</p>"},{"location":"glossary/#operator-overloading","title":"Operator Overloading","text":"<p>Defining how built-in operators behave for user-defined classes.</p>"},{"location":"glossary/#operator-precedence","title":"Operator Precedence","text":"<p>The rules that determine the order in which operations are evaluated in an expression.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#or-operator","title":"Or Operator","text":"<p>The logical operator that returns True when at least one operand is True.</p> <p>Example: result = a + b</p>"},{"location":"glossary/#order-of-operations","title":"Order of Operations","text":"<p>A core concept in this course that supports understanding and writing Python programs.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#ordereddict","title":"OrderedDict","text":"<p>A dictionary type that remembers insertion order (now the default behavior in modern Python dicts).</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#parameters","title":"Parameters","text":"<p>Named variables in a function definition that receive input values.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#parent-class","title":"Parent Class","text":"<p>A class that provides attributes and methods to a subclass.</p>"},{"location":"glossary/#pattern-recognition","title":"Pattern Recognition","text":"<p>Identifying similarities or repeated structures in problems to reuse solutions or simplify reasoning.</p>"},{"location":"glossary/#pep-8-guidelines","title":"PEP 8 Guidelines","text":"<p>The official Python style guide that recommends formatting and naming conventions.</p>"},{"location":"glossary/#pip-package-manager","title":"Pip Package Manager","text":"<p>The tool used to install and manage third-party Python packages.</p>"},{"location":"glossary/#polymorphism","title":"Polymorphism","text":"<p>The ability to use different object types through a common interface.</p>"},{"location":"glossary/#pop-method","title":"Pop Method","text":"<p>In Python lists, the pop method removes and returns an item by index.</p> <p>Example: last = nums.pop()</p>"},{"location":"glossary/#pop-method-for-dicts","title":"Pop Method for Dicts","text":"<p>A dictionary-related concept that describes how to store, access, or manipulate dictionary data in Python.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#positional-arguments","title":"Positional Arguments","text":"<p>A core concept in this course that supports understanding and writing Python programs.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#print-debugging","title":"Print Debugging","text":"<p>Using print statements to inspect program state.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#print-function","title":"Print Function","text":"<p>A built-in function that outputs text or values to the console.</p> <p>Example: print(\"Hello, world!\")</p>"},{"location":"glossary/#private-attributes","title":"Private Attributes","text":"<p>Attributes intended for internal use, typically marked with a leading underscore.</p>"},{"location":"glossary/#problem-solving","title":"Problem Solving","text":"<p>The process of analyzing a task, designing a solution, implementing it, and evaluating the results.</p>"},{"location":"glossary/#program-planning","title":"Program Planning","text":"<p>Identifying requirements and designing a solution before coding.</p>"},{"location":"glossary/#programming-languages","title":"Programming Languages","text":"<p>Formal languages with rules for writing instructions that computers can interpret or compile into machine code.</p>"},{"location":"glossary/#property-decorator","title":"Property Decorator","text":"<p>The @property decorator that turns a method into a managed attribute.</p>"},{"location":"glossary/#pseudocode","title":"Pseudocode","text":"<p>A structured, language-agnostic description of an algorithm.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#python-best-practices","title":"Python Best Practices","text":"<p>Guidelines for writing clean, reliable, and maintainable Python code.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#python-interpreter","title":"Python Interpreter","text":"<p>The program that executes Python code by translating it into actions the computer can perform.</p>"},{"location":"glossary/#python-language","title":"Python Language","text":"<p>A high-level, interpreted programming language known for readability and a large standard library.</p>"},{"location":"glossary/#python-modules","title":"Python Modules","text":"<p>Files containing Python code that can be imported.</p>"},{"location":"glossary/#python-packages","title":"Python Packages","text":"<p>Collections of modules organized in a directory with an init.py file.</p>"},{"location":"glossary/#python-repl","title":"Python REPL","text":"<p>An interactive Python prompt that lets you enter and execute code one line at a time.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#python-scripts","title":"Python Scripts","text":"<p>Python programs saved in files and executed by the interpreter.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#quadratic-time-on2","title":"Quadratic Time O(n^2)","text":"<p>A time complexity where runtime grows with the square of input size.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#raising-exceptions","title":"Raising Exceptions","text":"<p>Using the raise statement to signal an error condition intentionally.</p> <p>Example: try: x = int(s) except ValueError: ...</p>"},{"location":"glossary/#range-function","title":"Range Function","text":"<p>A built-in function that produces a sequence of integers, commonly used in loops.</p> <p>Example: for i in range(5): ...</p>"},{"location":"glossary/#raw-strings","title":"Raw Strings","text":"<p>A string-related concept that describes how to store, access, or manipulate string data in Python.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#read-method","title":"Read Method","text":"<p>Built-in operations attached to objects that perform a specific task.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#readline-method","title":"Readline Method","text":"<p>Built-in operations attached to objects that perform a specific task.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#readlines-method","title":"Readlines Method","text":"<p>Built-in operations attached to objects that perform a specific task.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#recursion","title":"Recursion","text":"<p>A technique where a function solves a problem by calling itself with a smaller input until a base case is reached.</p> <p>Example: def fact(n): return 1 if n==0 else n*fact(n-1)</p> <p>See also: Base Case, Recursive Case, Recursive Call Stack</p>"},{"location":"glossary/#recursion-in-algorithms","title":"Recursion in Algorithms","text":"<p>Using recursion as part of algorithm design, often in divide-and-conquer solutions.</p> <p>Example: def fact(n): return 1 if n==0 else n*fact(n-1)</p>"},{"location":"glossary/#recursion-vs-iteration","title":"Recursion vs Iteration","text":"<p>A comparison between solving problems with self-calling functions and with loops.</p> <p>Example: def fact(n): return 1 if n==0 else n*fact(n-1)</p>"},{"location":"glossary/#recursive-call-stack","title":"Recursive Call Stack","text":"<p>The sequence of nested function calls created during recursion.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#recursive-case","title":"Recursive Case","text":"<p>The part of a recursive function that reduces the problem and calls itself again.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#recursive-patterns","title":"Recursive Patterns","text":"<p>A core concept in this course that supports understanding and writing Python programs.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#reduce-function","title":"Reduce Function","text":"<p>A function that combines items into a single value using a binary function.</p> <p>Example: total = reduce(lambda a,b: a+b, nums)</p>"},{"location":"glossary/#refactoring","title":"Refactoring","text":"<p>Improving code structure without changing its behavior.</p>"},{"location":"glossary/#regular-expressions","title":"Regular Expressions","text":"<p>Patterns used to match, search, or replace text.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#remove-method","title":"Remove Method","text":"<p>In Python lists, the remove method removes the first matching item.</p> <p>Example: nums.remove(42)</p>"},{"location":"glossary/#removing-duplicates","title":"Removing Duplicates","text":"<p>The process of eliminating repeated values, often by converting a list to a set and back.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#repr-method","title":"Repr Method","text":"<p>The repr method that defines an unambiguous string representation for debugging.</p>"},{"location":"glossary/#requirements-analysis","title":"Requirements Analysis","text":"<p>Determining what a program should do and the constraints it must satisfy.</p>"},{"location":"glossary/#return-statement","title":"Return Statement","text":"<p>A statement that exits a function and optionally provides a value to the caller.</p> <p>Example: if x &gt; 0: ...</p>"},{"location":"glossary/#return-values","title":"Return Values","text":"<p>A core concept in this course that supports understanding and writing Python programs.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#reverse-method","title":"Reverse Method","text":"<p>In Python lists, the reverse method reverses the order in place.</p> <p>Example: nums.reverse()</p>"},{"location":"glossary/#rubber-duck-debugging","title":"Rubber Duck Debugging","text":"<p>Explaining code aloud to clarify logic and expose mistakes.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#runtime-errors","title":"Runtime Errors","text":"<p>Errors that occur while a program is running.</p> <p>Example: try: x = int(s) except ValueError: ...</p>"},{"location":"glossary/#search-comparison","title":"Search Comparison","text":"<p>An algorithm concept describing a method, comparison, or analysis technique for solving problems.</p> <p>Example: index = linear_search(data, target)</p>"},{"location":"glossary/#selection-sort","title":"Selection Sort","text":"<p>A sorting algorithm that repeatedly selects the smallest remaining item.</p> <p>Example: sorted_list = insertion_sort(data)</p>"},{"location":"glossary/#sentinel-value-pattern","title":"Sentinel Value Pattern","text":"<p>A loop pattern that uses a special value to signal when to stop processing input.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#sequential-execution","title":"Sequential Execution","text":"<p>Running statements one after another in the order they appear.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#set-creation","title":"Set Creation","text":"<p>A set-related concept that describes how to store, access, or manipulate set data in Python.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#set-difference","title":"Set Difference","text":"<p>A set-related concept that describes how to store, access, or manipulate set data in Python.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#set-intersection","title":"Set Intersection","text":"<p>A set-related concept that describes how to store, access, or manipulate set data in Python.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#set-methods","title":"Set Methods","text":"<p>Built-in operations for adding, removing, and testing membership in sets.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#set-operations","title":"Set Operations","text":"<p>Mathematical set operations such as union, intersection, and difference.</p> <p>Example: union = a | b</p>"},{"location":"glossary/#set-symmetric-difference","title":"Set Symmetric Difference","text":"<p>A set-related concept that describes how to store, access, or manipulate set data in Python.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#set-union","title":"Set Union","text":"<p>A set-related concept that describes how to store, access, or manipulate set data in Python.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#sets","title":"Sets","text":"<p>Unordered collections of unique items in Python.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#setter-methods","title":"Setter Methods","text":"<p>Methods used to modify attribute values with validation.</p>"},{"location":"glossary/#shallow-copy","title":"Shallow Copy","text":"<p>A copy that duplicates the container but not the nested objects it references.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#short-circuit-evaluation","title":"Short-Circuit Evaluation","text":"<p>A logic evaluation strategy where the second operand is skipped if the first determines the result.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#slice-notation","title":"Slice Notation","text":"<p>A string-related concept that describes how to store, access, or manipulate string data in Python.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#sliding-window-pattern","title":"Sliding Window Pattern","text":"<p>An algorithm pattern that maintains a moving window over data to compute results efficiently.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#software-development","title":"Software Development","text":"<p>The process of planning, building, testing, and maintaining software.</p>"},{"location":"glossary/#sort-method","title":"Sort Method","text":"<p>In Python lists, the sort method reorders items in place.</p> <p>Example: nums.sort()</p>"},{"location":"glossary/#sorted-function","title":"Sorted Function","text":"<p>A built-in function that returns a new sorted list from any iterable.</p> <p>Example: ordered = sorted(scores)</p>"},{"location":"glossary/#sorting-comparison","title":"Sorting Comparison","text":"<p>An algorithm concept describing a method, comparison, or analysis technique for solving problems.</p> <p>Example: sorted_list = insertion_sort(data)</p>"},{"location":"glossary/#space-complexity","title":"Space Complexity","text":"<p>How the memory usage of an algorithm scales with input size.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#split-method","title":"Split Method","text":"<p>In Python strings, the split method splits text into a list of parts and returns a new string.</p> <p>Example: parts = s.split(',')</p>"},{"location":"glossary/#stable-vs-unstable-sort","title":"Stable vs Unstable Sort","text":"<p>An algorithm concept describing a method, comparison, or analysis technique for solving problems.</p> <p>Example: sorted_list = insertion_sort(data)</p>"},{"location":"glossary/#stack-overflow","title":"Stack Overflow","text":"<p>An error that occurs when too many function calls fill the call stack.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#startswith-and-endswith","title":"Startswith and Endswith","text":"<p>A string-related concept that describes how to store, access, or manipulate string data in Python.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#statements","title":"Statements","text":"<p>A core concept in this course that supports understanding and writing Python programs.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#static-methods","title":"Static Methods","text":"<p>Methods that do not use instance or class data, defined with the @staticmethod decorator.</p>"},{"location":"glossary/#step-through-code","title":"Step Through Code","text":"<p>Executing code line by line in a debugger to observe behavior.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#stepwise-refinement","title":"Stepwise Refinement","text":"<p>A design technique that starts with a high-level solution and progressively adds detail until it is implementable.</p>"},{"location":"glossary/#str-method","title":"Str Method","text":"<p>The str method that defines a readable string representation of an object.</p>"},{"location":"glossary/#string-basics","title":"String Basics","text":"<p>A string-related concept that describes how to store, access, or manipulate string data in Python.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#string-comparison","title":"String Comparison","text":"<p>A string-related concept that describes how to store, access, or manipulate string data in Python.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#string-concatenation","title":"String Concatenation","text":"<p>A core concept in this course that supports understanding and writing Python programs.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#string-formatting","title":"String Formatting","text":"<p>The process of inserting values into text to create readable output.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#string-immutability","title":"String Immutability","text":"<p>The property that string values cannot be changed in place; operations create new strings.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#string-indexing","title":"String Indexing","text":"<p>A string-related concept that describes how to store, access, or manipulate string data in Python.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#string-iteration","title":"String Iteration","text":"<p>A string-related concept that describes how to store, access, or manipulate string data in Python.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#string-length","title":"String Length","text":"<p>A string-related concept that describes how to store, access, or manipulate string data in Python.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#string-methods","title":"String Methods","text":"<p>Built-in operations attached to string objects for searching, formatting, and transforming text.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#string-repetition","title":"String Repetition","text":"<p>A core concept in this course that supports understanding and writing Python programs.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#string-reversal","title":"String Reversal","text":"<p>A string-related concept that describes how to store, access, or manipulate string data in Python.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#string-slicing","title":"String Slicing","text":"<p>A string-related concept that describes how to store, access, or manipulate string data in Python.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#string-type","title":"String Type","text":"<p>A data type that represents string values and determines valid operations on them.</p> <p>Example: count = 3  # int</p>"},{"location":"glossary/#string-validation-methods","title":"String Validation Methods","text":"<p>Built-in operations attached to objects that perform a specific task.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#strip-method","title":"Strip Method","text":"<p>In Python strings, the strip method removes leading and trailing whitespace and returns a new string.</p> <p>Example: clean = s.strip()</p>"},{"location":"glossary/#super-function","title":"Super Function","text":"<p>The super() function used to access methods of a parent class.</p>"},{"location":"glossary/#syntax-errors","title":"Syntax Errors","text":"<p>Errors caused by invalid Python syntax, detected before code runs.</p> <p>Example: try: x = int(s) except ValueError: ...</p>"},{"location":"glossary/#ternary-expression","title":"Ternary Expression","text":"<p>A combination of values, variables, and operators that produces a result when evaluated.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#test-cases","title":"Test Cases","text":"<p>Specific input and expected output pairs used to validate behavior.</p> <p>Example: assert add(2,3) == 5</p>"},{"location":"glossary/#test-functions","title":"Test Functions","text":"<p>Functions that contain assertions to verify behavior.</p> <p>Example: assert add(2,3) == 5</p>"},{"location":"glossary/#test-driven-development","title":"Test-Driven Development","text":"<p>A development process that writes tests before writing code.</p> <p>Example: Write a failing test, then implement the feature.</p>"},{"location":"glossary/#testing","title":"Testing","text":"<p>The process of verifying that software behaves as expected.</p> <p>Example: assert add(2,3) == 5</p>"},{"location":"glossary/#text-vs-binary-files","title":"Text vs Binary Files","text":"<p>A distinction between human-readable text files and raw binary data files.</p> <p>Example: with open('data.txt') as f: text = f.read()</p>"},{"location":"glossary/#the-self-parameter","title":"The Self Parameter","text":"<p>The first parameter of instance methods that refers to the current object.</p>"},{"location":"glossary/#time-complexity","title":"Time Complexity","text":"<p>How the runtime of an algorithm scales with input size.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#truth-tables","title":"Truth Tables","text":"<p>Tables that show all possible input combinations and the resulting boolean output.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#truthiness-and-falsiness","title":"Truthiness and Falsiness","text":"<p>The way Python treats non-boolean values as True or False in conditional contexts.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#try-except-block","title":"Try-Except Block","text":"<p>A control structure for catching and handling exceptions.</p> <p>Example: try: x = int(s) except ValueError: ...</p>"},{"location":"glossary/#tuple-creation","title":"Tuple Creation","text":"<p>A tuple-related concept that describes how to store, access, or manipulate tuple data in Python.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#tuple-immutability","title":"Tuple Immutability","text":"<p>The property that a tuple's elements cannot be changed after creation.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#tuple-methods","title":"Tuple Methods","text":"<p>Built-in operations attached to objects that perform a specific task.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#tuple-packing","title":"Tuple Packing","text":"<p>Creating a tuple by listing values separated by commas.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#tuple-unpacking","title":"Tuple Unpacking","text":"<p>Assigning elements of a tuple to multiple variables in a single statement.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#tuples","title":"Tuples","text":"<p>Ordered, immutable collections of items in Python.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#tuples-as-keys","title":"Tuples as Keys","text":"<p>Using tuples as dictionary keys because tuples are hashable when they contain immutable items.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#tuples-vs-lists","title":"Tuples vs Lists","text":"<p>A comparison between immutable tuples and mutable lists, including typical use cases.</p> <p>Example: data = [1, 2, 3]</p>"},{"location":"glossary/#two-pointer-technique","title":"Two Pointer Technique","text":"<p>An algorithm pattern that uses two indices moving through data to solve problems efficiently.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#type-annotations","title":"Type Annotations","text":"<p>Explicit type hints written in code to clarify expected types.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#type-conversion","title":"Type Conversion","text":"<p>A core concept in this course that supports understanding and writing Python programs.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#type-function","title":"Type Function","text":"<p>A built-in function that returns the type of a value or object.</p> <p>Example: result = func(x)</p>"},{"location":"glossary/#type-hints","title":"Type Hints","text":"<p>Optional annotations that describe expected types of variables and function parameters.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#typeerror","title":"TypeError","text":"<p>An error-handling concept describing how programs detect, represent, or respond to problems.</p> <p>Example: try: x = int(s) except ValueError: ...</p>"},{"location":"glossary/#uml-class-diagrams","title":"UML Class Diagrams","text":"<p>Visual diagrams that show classes, attributes, methods, and relationships.</p>"},{"location":"glossary/#unit-testing","title":"Unit Testing","text":"<p>Testing individual functions or components in isolation.</p> <p>Example: def test_add(): assert add(2,3)==5</p>"},{"location":"glossary/#unittest-module","title":"Unittest Module","text":"<p>Python's built-in unit testing framework.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#unpacking-operators","title":"Unpacking Operators","text":"<p>The * and ** operators used to unpack iterables or dictionaries into arguments or values.</p> <p>Example: result = a + b</p>"},{"location":"glossary/#update-method","title":"Update Method","text":"<p>In Python dictionaries, the update method merges in new key-value pairs.</p> <p>Example: d.update({\"x\": 1})</p>"},{"location":"glossary/#upper-and-lower-methods","title":"Upper and Lower Methods","text":"<p>Built-in operations attached to objects that perform a specific task.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#valueerror","title":"ValueError","text":"<p>An error-handling concept describing how programs detect, represent, or respond to problems.</p> <p>Example: try: x = int(s) except ValueError: ...</p>"},{"location":"glossary/#values-method","title":"Values Method","text":"<p>In Python dictionaries, the values method returns a view of values.</p> <p>Example: total = sum(d.values())</p>"},{"location":"glossary/#variable-assignment","title":"Variable Assignment","text":"<p>The operation of binding a name to a value in memory.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#variable-naming-rules","title":"Variable Naming Rules","text":"<p>Conventions and syntactic rules for creating valid and readable variable names in Python.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#variable-scope","title":"Variable Scope","text":"<p>The region of a program where a variable name is accessible.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#variables","title":"Variables","text":"<p>Named references to values stored in memory that can change during program execution.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#version-control-intro","title":"Version Control Intro","text":"<p>An introduction to systems that track changes to code over time.</p>"},{"location":"glossary/#virtual-environments","title":"Virtual Environments","text":"<p>Isolated Python environments that keep project dependencies separate.</p>"},{"location":"glossary/#walrus-operator","title":"Walrus Operator","text":"<p>The := operator that assigns and returns a value within an expression.</p> <p>Example: if (n := len(items)) &gt; 0: ...</p>"},{"location":"glossary/#while-loop","title":"While Loop","text":"<p>A control structure that repeats a block of code, based on a condition or sequence.</p> <p>Example: for item in items: ...</p>"},{"location":"glossary/#with-statement","title":"With Statement","text":"<p>A statement that ensures resources are cleaned up, commonly used with files.</p> <p>Example: with open(path) as f: data = f.read()</p>"},{"location":"glossary/#write-method","title":"Write Method","text":"<p>Built-in operations attached to objects that perform a specific task.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#writelines-method","title":"Writelines Method","text":"<p>Built-in operations attached to objects that perform a specific task.</p> <p>Example: see chapter for usage</p>"},{"location":"glossary/#yield-statement","title":"Yield Statement","text":"<p>The statement that produces a value from a generator and pauses its execution.</p> <p>Example: if x &gt; 0: ...</p>"},{"location":"glossary/#zip-function","title":"Zip Function","text":"<p>A built-in function that pairs items from multiple iterables into tuples.</p> <p>Example: pairs = list(zip(a, b))</p>"},{"location":"license/","title":"License","text":""},{"location":"license/#creative-commons-license","title":"Creative Commons License","text":"<p>All content in this repository is governed by the following license agreement:</p>"},{"location":"license/#license-type","title":"License Type","text":"<p>Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0 DEED)</p>"},{"location":"license/#link-to-license-agreement","title":"Link to License Agreement","text":"<p>https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en</p>"},{"location":"license/#your-rights","title":"Your Rights","text":"<p>You are free to:</p> <ul> <li>Share \u2014 copy and redistribute the material in any medium or format</li> <li>Adapt \u2014 remix, transform, and build upon the material</li> </ul> <p>The licensor cannot revoke these freedoms as long as you follow the license terms.</p>"},{"location":"license/#restrictions","title":"Restrictions","text":"<ul> <li>Attribution \u2014 You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.</li> <li>NonCommercial \u2014 You may not use the material for commercial purposes.</li> <li>ShareAlike \u2014 If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original.</li> <li>No additional restrictions \u2014 You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits.</li> </ul> <p>Notices</p> <p>You do not have to comply with the license for elements of the material in the public domain or where your use is permitted by an applicable exception or limitation.</p> <p>No warranties are given. The license may not give you all of the permissions necessary for your intended use. For example, other rights such as publicity, privacy, or moral rights may limit how you use the material.</p> <p>This deed highlights only some of the key features and terms of the actual license. It is not a license and has no legal value. You should carefully review all of the terms and conditions of the actual license before using the licensed material.</p>"},{"location":"license/#commercial-licensing","title":"Commercial Licensing","text":"<p>Commercial rights are reserved by the copyright holder. For commercial licensing, publication inquiries, or permission to use this work in commercial contexts, please contact Dan McCreary on LinkedIn.</p>"},{"location":"chapters/","title":"Overview","text":""},{"location":"chapters/#chapters","title":"Chapters","text":"<p>This textbook is organized into 20 chapters covering 400 concepts for the AP Computer Science (Python Version) course.</p>"},{"location":"chapters/#chapter-overview","title":"Chapter Overview","text":"<ol> <li>Introduction to Computer Science - Foundational concepts including computational thinking, hardware basics, binary numbers, and programming languages.</li> <li>Python Fundamentals - Core Python basics from variables and data types through arithmetic operators, input/output, and expressions.</li> <li>Boolean Logic and Comparisons - Boolean expressions, comparison and logical operators, short-circuit evaluation, and truth tables.</li> <li>Control Flow - Conditional statements, for and while loops, break/continue, and common iteration patterns.</li> <li>Working with Strings - String indexing, slicing, methods, formatting, iteration, and text manipulation.</li> <li>Functions and Modular Design - Function definition, parameters, return values, variable scope, and docstrings.</li> <li>Higher-Order Functions and Recursion - Lambda functions, map/filter/reduce, recursive thinking, base cases, and call stacks.</li> <li>Lists - List creation, indexing, slicing, mutability, methods, comprehensions, and traversal.</li> <li>Advanced List Operations - List copying, sorting, min/max/sum, lists as stacks/queues, aliasing, and identity vs equality.</li> <li>Tuples and Sets - Tuple immutability, packing/unpacking, set operations, membership testing, and frozensets.</li> <li>Dictionaries - Dictionary creation, methods, iteration, comprehensions, and common patterns like counting and grouping.</li> <li>Classes and Objects - Class definition, instantiation, attributes, constructors, methods, and encapsulation.</li> <li>Inheritance and Polymorphism - Inheritance hierarchies, method overriding, polymorphism, operator overloading, and UML diagrams.</li> <li>Errors and Exceptions - Exception types, try-except blocks, raising and custom exceptions, and assertions.</li> <li>File Input and Output - Reading/writing files, context managers, file paths, CSV and JSON file handling.</li> <li>Software Engineering Practices - Modules, packages, version control, PEP 8 style, refactoring, and documentation.</li> <li>Testing and Debugging - Unit testing, test cases, debugging strategies, breakpoints, and defensive programming.</li> <li>Searching and Sorting - Linear/binary search, selection/insertion/merge sort, Big-O notation, and complexity basics.</li> <li>Algorithm Analysis and Problem Solving - Complexity classes, divide and conquer, greedy algorithms, memoization, and algorithmic patterns.</li> <li>Advanced Python Features - Generators, decorators, type hints, dataclasses, and standard library modules.</li> </ol>"},{"location":"chapters/#how-to-use-this-textbook","title":"How to Use This Textbook","text":"<p>Chapters are designed to be read in order, as each chapter builds on concepts from previous ones. The learning graph ensures that all prerequisite concepts are covered before they are needed. If you are already familiar with certain topics, you can skip ahead, but be sure to review the concept list in each chapter to confirm you have the prerequisite knowledge.</p>"},{"location":"chapters/01-intro-to-computer-science/","title":"Introduction to Computer Science","text":""},{"location":"chapters/01-intro-to-computer-science/#introduction-to-computer-science","title":"Introduction to Computer Science","text":""},{"location":"chapters/01-intro-to-computer-science/#summary","title":"Summary","text":"<p>This chapter introduces the foundational concepts of computer science that form the basis for all programming work. Students will learn about computational thinking, including decomposition, pattern recognition, and abstraction. The chapter also covers hardware basics, binary number systems, character encoding, and provides an overview of programming languages with a focus on how Python fits into the landscape.</p>"},{"location":"chapters/01-intro-to-computer-science/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 20 concepts from the learning graph:</p> <ol> <li>Computer Science</li> <li>Computational Thinking</li> <li>Algorithms</li> <li>Abstraction</li> <li>Decomposition</li> <li>Pattern Recognition</li> <li>Stepwise Refinement</li> <li>Problem Solving</li> <li>Binary Number System</li> <li>Bits and Bytes</li> <li>Character Encoding</li> <li>ASCII and Unicode</li> <li>Computer Hardware</li> <li>CPU and Memory</li> <li>Input and Output Devices</li> <li>Operating Systems</li> <li>Programming Languages</li> <li>Compiled vs Interpreted</li> <li>Python Language</li> <li>Python Interpreter</li> </ol>"},{"location":"chapters/01-intro-to-computer-science/#prerequisites","title":"Prerequisites","text":"<p>This chapter assumes only the prerequisites listed in the course description. No prior programming experience is required.</p> <p>Monty says: Let's code this!</p> <p> Welcome, coders! You're about to take your first step into the world of computer science. Don't worry if everything feels brand new \u2014 that's exactly where you're supposed to be. By the end of this chapter, you'll understand how computers think, how they store information, and why Python is a fantastic language to learn first. Let's do this!</p>"},{"location":"chapters/01-intro-to-computer-science/#what-is-computer-science","title":"What Is Computer Science?","text":"<p>You might think computer science is all about typing code on a screen. That's definitely part of it, but it's a lot bigger than that. Computer science is the study of how to solve problems using computation. It's about figuring out the right steps to take, organizing information, and getting a machine to do the heavy lifting for you.</p> <p>Think of it this way: a chef follows a recipe, a pilot follows a flight plan, and a computer follows instructions that you write. Computer science is the art and science of writing those instructions \u2014 and writing them well.</p> <p>Computer science shows up in places you might not expect:</p> <ul> <li>Medicine: Analyzing medical images to detect diseases</li> <li>Music: Generating playlists based on your listening habits</li> <li>Sports: Tracking player stats and predicting game outcomes</li> <li>Gaming: Building the virtual worlds you explore on your console</li> <li>Climate science: Modeling weather patterns and forecasting storms</li> </ul> <p>No matter what career path interests you, computer science skills will give you a superpower: the ability to automate repetitive tasks, analyze massive amounts of data, and build tools that help people.</p>"},{"location":"chapters/01-intro-to-computer-science/#computational-thinking","title":"Computational Thinking","text":"<p>Before you can tell a computer what to do, you need to think like one \u2014 sort of. Computational thinking is a problem-solving approach that breaks big, messy problems into smaller, manageable pieces. It's not just for computers. You use computational thinking every day without realizing it.</p> <p>Imagine you're planning a birthday party. You don't just think \"have a party\" and hope for the best. You break it down: choose a date, pick a venue, make a guest list, plan food, set up decorations. That process of breaking a big task into smaller steps? That's computational thinking in action.</p> <p>Computational thinking has four main pillars:</p> Pillar What It Means Party Example Decomposition Break a big problem into smaller parts \"Plan food\" becomes: choose menu, buy ingredients, cook, set up the table Pattern Recognition Spot similarities and repeating patterns \"Last year we ran out of pizza \u2014 let's order more this time\" Abstraction Focus on what matters, ignore what doesn't \"I don't need to know the exact cheese brand \u2014 I just need 'pizza for 20'\" Algorithms Create step-by-step instructions \"First set up tables, then put out plates, then bring out food\" <p>Let's look at each of these more closely.</p>"},{"location":"chapters/01-intro-to-computer-science/#decomposition","title":"Decomposition","text":"<p>Decomposition means taking a complex problem and splitting it into smaller, easier-to-solve pieces. It's like eating a pizza \u2014 you don't try to shove the whole thing in your mouth at once (please don't). You cut it into slices.</p> <p>In computer science, we decompose problems all the time. Building a video game? That decomposes into: drawing graphics, handling player input, tracking scores, playing sound effects, and managing game levels. Each of those pieces can be worked on separately, and when you put them all together, you've got a working game.</p>"},{"location":"chapters/01-intro-to-computer-science/#pattern-recognition","title":"Pattern Recognition","text":"<p>Pattern recognition is about spotting things that repeat or look similar. Once you see a pattern, you can reuse a solution instead of starting from scratch.</p> <p>Think about your morning routine. You probably do roughly the same things every school day: wake up, get dressed, eat breakfast, grab your backpack. That's a pattern. If someone asked you to plan your morning for next Tuesday, you wouldn't have to invent a whole new routine \u2014 you'd follow the pattern.</p> <p>In computing, patterns are everywhere. If you're building an app that displays a list of songs, a list of contacts, and a list of homework assignments, you might notice that \"display a list of items\" is a repeating pattern. Write the solution once, and reuse it.</p> <p>Monty says: You've got this!</p> <p> Here's a fun pattern to spot: every chapter in this book starts with simple ideas and builds to more complex ones. Once you notice that pattern, you'll know what to expect \u2014 and you can plan your study time accordingly!</p>"},{"location":"chapters/01-intro-to-computer-science/#abstraction","title":"Abstraction","text":"<p>Abstraction means stripping away the details you don't need so you can focus on what really matters. A map is a perfect example. A real city has millions of details \u2014 trees, fire hydrants, stray cats. But a subway map only shows you the train lines and stops. It abstracts away everything else so you can figure out how to get from point A to point B.</p> <p>In computer science, abstraction lets you work at different levels. When you're driving a car, you don't need to understand how every piston fires in the engine. You just need the steering wheel, pedals, and gear shift. The car's designers abstracted the engine complexity behind a simple interface.</p>"},{"location":"chapters/01-intro-to-computer-science/#algorithms","title":"Algorithms","text":"<p>An algorithm is a step-by-step set of instructions for solving a problem. You follow algorithms all the time:</p> <ul> <li>A recipe for baking cookies is an algorithm</li> <li>Directions from your house to school are an algorithm</li> <li>The steps for solving a math equation are an algorithm</li> </ul> <p>What makes a good algorithm? It needs to be:</p> <ol> <li>Clear \u2014 Each step is unambiguous</li> <li>Ordered \u2014 The steps happen in a specific sequence</li> <li>Finite \u2014 It eventually stops (no infinite loops of cookie baking, as tempting as that sounds)</li> <li>Effective \u2014 Each step can actually be carried out</li> </ol> <p>Here's a simple algorithm for making a peanut butter and jelly sandwich:</p> <ol> <li>Get two slices of bread</li> <li>Open the peanut butter jar</li> <li>Spread peanut butter on one slice</li> <li>Open the jelly jar</li> <li>Spread jelly on the other slice</li> <li>Press the two slices together</li> <li>Enjoy!</li> </ol> <p>Seems obvious, right? But try telling a computer to \"make a sandwich\" without those steps, and you'll get nowhere. Computers are incredibly literal \u2014 they do exactly what you tell them, nothing more, nothing less.</p>"},{"location":"chapters/01-intro-to-computer-science/#diagram-computational-thinking-pillars","title":"Diagram: Computational Thinking Pillars","text":"Computational Thinking Pillars Interactive Infographic <p>Type: infographic sim-id: computational-thinking-pillars Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: classify, explain</p> <p>Learning Objective: Students will be able to identify and explain the four pillars of computational thinking (decomposition, pattern recognition, abstraction, algorithms) and describe how they work together to solve problems.</p> <p>Purpose: Present the four pillars of computational thinking as an interactive concept map where students can hover over each pillar to see its definition, a real-world analogy, and a computing example.</p> <p>Layout: - Central node labeled \"Computational Thinking\" in the middle of the canvas - Four surrounding nodes for each pillar, arranged in a diamond pattern - Connecting lines from center to each pillar</p> <p>Nodes:</p> <ol> <li>Center: \"Computational Thinking\" (green, larger)</li> <li>Top: \"Decomposition\" (blue)</li> <li>Hover text: \"Break big problems into smaller parts. Like cutting a pizza into slices before eating it.\"</li> <li>Computing example: \"Building a game = graphics + input + scoring + sound\"</li> <li>Right: \"Pattern Recognition\" (orange)</li> <li>Hover text: \"Spot repeating similarities. Like noticing your morning routine is the same each day.\"</li> <li>Computing example: \"Reusing 'display a list' code for songs, contacts, and tasks\"</li> <li>Bottom: \"Abstraction\" (purple)</li> <li>Hover text: \"Focus on what matters, ignore what doesn't. Like a subway map hiding city details.\"</li> <li>Computing example: \"Using a function without knowing how it works inside\"</li> <li>Left: \"Algorithms\" (red)</li> <li>Hover text: \"Step-by-step instructions to solve a problem. Like a recipe for cookies.\"</li> <li>Computing example: \"The exact steps to sort a list of numbers from smallest to largest\"</li> </ol> <p>Interactive elements: - Hover over any pillar node to display a tooltip with definition, analogy, and computing example - Click a pillar node to highlight it and show a brief animation connecting it to the center - All four pillars pulse gently to invite interaction</p> <p>Visual style: Clean, modern with rounded rectangles for nodes, soft connecting lines Color scheme: Each pillar gets a distinct color; center node is green Responsive: Canvas resizes with window; nodes reposition proportionally</p> <p>Instructional Rationale: Hover-to-reveal interaction supports the Understand level by letting students explore each pillar at their own pace and connect definitions to concrete examples. The spatial layout reinforces that these four pillars work together as parts of a unified approach.</p>"},{"location":"chapters/01-intro-to-computer-science/#stepwise-refinement","title":"Stepwise Refinement","text":"<p>Stepwise refinement takes decomposition one level deeper. Once you've broken a problem into parts, you break each part into even smaller parts until every piece is simple enough to solve directly.</p> <p>Think of it like zooming in on a map. First you see the whole country. Then you zoom into your state. Then your city. Then your neighborhood. Then your street. Each zoom gives you more detail.</p> <p>For example, \"plan food for the party\" might refine into:</p> <ol> <li>Decide on pizza</li> <li>Count the guests (20 people)</li> <li>Estimate 3 slices per person (60 slices total)</li> <li>Each pizza has 8 slices, so order 8 pizzas</li> <li>Call the pizza place and place the order</li> </ol> <p>Each step is concrete and doable. That's the power of stepwise refinement \u2014 it turns a vague idea into a clear action plan.</p>"},{"location":"chapters/01-intro-to-computer-science/#problem-solving","title":"Problem Solving","text":"<p>All of these techniques \u2014 decomposition, pattern recognition, abstraction, algorithms, and stepwise refinement \u2014 come together under the umbrella of problem solving. In computer science, problem solving isn't about guessing or being lucky. It's a systematic process:</p> <ol> <li>Understand the problem \u2014 What are you trying to do?</li> <li>Plan your approach \u2014 Which techniques will you use?</li> <li>Execute your plan \u2014 Write out the steps (or eventually, write code)</li> <li>Review your solution \u2014 Does it actually work? Can you improve it?</li> </ol> <p>This four-step process works whether you're planning a party, solving a math problem, or writing a computer program. You'll use it throughout this entire course.</p>"},{"location":"chapters/01-intro-to-computer-science/#how-computers-work-hardware-basics","title":"How Computers Work: Hardware Basics","text":"<p>Now that you know how to think about problems, let's look at the machine that will actually solve them for you. Time to peek under the hood.</p>"},{"location":"chapters/01-intro-to-computer-science/#computer-hardware","title":"Computer Hardware","text":"<p>Computer hardware is the physical stuff you can touch: the keyboard you type on, the screen you're reading right now, the chips inside the case. Hardware is the body of the computer \u2014 without it, software has nowhere to live.</p> <p>Every computer, from a massive server in a data center to the phone in your pocket, has the same basic components:</p> Component What It Does Everyday Analogy CPU Processes instructions The brain Memory (RAM) Stores data temporarily while working A desk where you spread out papers Storage (SSD/HDD) Stores data permanently A filing cabinet Input devices Send information to the computer Your ears and eyes Output devices Display results from the computer Your mouth and hands"},{"location":"chapters/01-intro-to-computer-science/#cpu-and-memory","title":"CPU and Memory","text":"<p>The CPU (Central Processing Unit) is the brain of the computer. It's a tiny chip \u2014 smaller than a postage stamp \u2014 but it can perform billions of calculations every second. When you hear someone talk about a \"fast computer,\" they're usually talking about the CPU.</p> <p>The CPU doesn't work alone, though. It needs memory (also called RAM, or Random Access Memory) to hold the data it's currently working with. Think of RAM like your desk. When you're doing homework, you spread your textbook, notebook, and calculator on the desk for easy access. When you're done, you put everything back in your backpack (that's storage). RAM is fast but temporary \u2014 when you turn off the computer, everything in RAM disappears.</p> <p>Why not just use storage for everything? Because storage (your hard drive or SSD) is much slower than RAM. It's the difference between grabbing a book off your desk versus walking to the library to check it out.</p>"},{"location":"chapters/01-intro-to-computer-science/#input-and-output-devices","title":"Input and Output Devices","text":"<p>Input devices let you send information into the computer:</p> <ul> <li>Keyboard (typing text)</li> <li>Mouse or trackpad (pointing and clicking)</li> <li>Microphone (voice input)</li> <li>Camera (photos and video)</li> <li>Touchscreen (tapping and swiping)</li> </ul> <p>Output devices let the computer send information back to you:</p> <ul> <li>Monitor/screen (visual display)</li> <li>Speakers (audio)</li> <li>Printer (paper output)</li> </ul> <p>Some devices do both! A touchscreen is both input (you tap it) and output (it shows you images). Pretty clever.</p>"},{"location":"chapters/01-intro-to-computer-science/#diagram-inside-a-computer","title":"Diagram: Inside a Computer","text":"Inside a Computer Interactive Diagram <p>Type: diagram sim-id: inside-a-computer Library: p5.js Status: Specified</p> <p>Bloom Level: Remember (L1) Bloom Verb: identify, label</p> <p>Learning Objective: Students will be able to identify the main hardware components of a computer (CPU, RAM, storage, input devices, output devices) and describe the role of each.</p> <p>Purpose: Interactive block diagram showing the major components inside a computer and how data flows between them.</p> <p>Layout: - Center: CPU chip (large, prominent) - Connected above: RAM (memory sticks) - Connected below: Storage (SSD/HDD icon) - Left side: Input devices group (keyboard, mouse, microphone icons) - Right side: Output devices group (monitor, speaker, printer icons) - Arrows showing data flow direction between components</p> <p>Interactive elements: - Hover over any component to see its name, description, and everyday analogy - Click a component to highlight all data flow arrows connected to it - A \"Show Data Flow\" button animates colored dots traveling along the arrows to show how information moves: input \u2192 CPU \u2192 RAM \u2194 Storage \u2192 output</p> <p>Hover text content: - CPU: \"The brain \u2014 processes billions of instructions per second\" - RAM: \"The desk \u2014 fast, temporary workspace for active tasks\" - Storage: \"The filing cabinet \u2014 permanent storage that survives power off\" - Input devices: \"How you talk to the computer \u2014 keyboard, mouse, mic\" - Output devices: \"How the computer talks back \u2014 screen, speakers, printer\"</p> <p>Color scheme: - CPU: gold/yellow - RAM: blue - Storage: green - Input devices: light purple - Output devices: orange - Data flow arrows: gray, animated dots in red</p> <p>Visual style: Clean icons with rounded rectangles, soft shadows Responsive: Reposition components on window resize; maintain proportional spacing</p> <p>Instructional Rationale: Label-and-identify interaction supports the Remember level. Hover-to-reveal definitions help students associate component names with functions. The animated data flow builds a mental model of how parts work together.</p>"},{"location":"chapters/01-intro-to-computer-science/#operating-systems","title":"Operating Systems","text":"<p>With all these hardware components, something needs to coordinate them \u2014 like a traffic cop directing cars at a busy intersection. That's the job of the operating system (OS).</p> <p>The operating system is software that manages your computer's hardware and provides a platform for other programs to run. When you click an icon to open an app, the OS loads it into memory. When you save a file, the OS writes it to storage. When you press a key, the OS figures out which program should receive that input.</p> <p>Popular operating systems include:</p> <ul> <li>Windows \u2014 The most common OS for PCs</li> <li>macOS \u2014 Apple's operating system for Mac computers</li> <li>Linux \u2014 A free, open-source OS popular with developers and servers</li> <li>ChromeOS \u2014 Google's lightweight OS for Chromebooks</li> <li>Android and iOS \u2014 Mobile operating systems for phones and tablets</li> </ul> <p>You don't need to know the details of how an operating system works for this course. Just know that it's the invisible layer between you and the hardware, making everything run smoothly.</p>"},{"location":"chapters/01-intro-to-computer-science/#speaking-in-ones-and-zeros-binary-and-data","title":"Speaking in Ones and Zeros: Binary and Data","text":"<p>Here's something that might blow your mind: deep down, your computer only understands two things \u2014 1 and 0. That's it. Every photo you've ever taken, every song you've streamed, every text message you've sent \u2014 all of it boils down to enormous sequences of ones and zeros.</p>"},{"location":"chapters/01-intro-to-computer-science/#the-binary-number-system","title":"The Binary Number System","text":"<p>Humans use the decimal system (base 10), which has ten digits: 0 through 9. We probably use base 10 because we have ten fingers. (Thanks, evolution!)</p> <p>Computers use the binary number system (base 2), which has only two digits: 0 and 1. Why? Because electronic circuits have two natural states: on (electricity flowing) and off (no electricity). It's like a light switch \u2014 it's either up or down, on or off, 1 or 0.</p> <p>Here's how binary counting compares to decimal:</p> Decimal Binary How to Read It 0 0000 Zero 1 0001 One 2 0010 Two 3 0011 Three 4 0100 Four 5 0101 Five 6 0110 Six 7 0111 Seven 8 1000 Eight <p>Notice the pattern? Each position in a binary number represents a power of 2 (just like each position in a decimal number represents a power of 10). The rightmost digit is the 1s place, then the 2s place, then the 4s place, then the 8s place, and so on.</p> <p>So binary <code>0110</code> means: (0 x 8) + (1 x 4) + (1 x 2) + (0 x 1) = 6</p>"},{"location":"chapters/01-intro-to-computer-science/#bits-and-bytes","title":"Bits and Bytes","text":"<p>A single binary digit (a 0 or a 1) is called a bit. It's the smallest unit of data a computer can handle. One bit alone isn't very useful \u2014 it can only represent two values.</p> <p>But group bits together, and things get interesting. A group of 8 bits is called a byte. One byte can represent (2^8 = 256) different values (0 through 255). That's enough to store a single letter, a small number, or a color value.</p> <p>Here's how data sizes scale up:</p> Unit Size What It Can Hold 1 Bit 1 or 0 A single yes/no answer 1 Byte 8 bits One character (like the letter 'A') 1 Kilobyte (KB) ~1,000 bytes A short email 1 Megabyte (MB) ~1,000 KB A high-quality photo 1 Gigabyte (GB) ~1,000 MB About 250 songs 1 Terabyte (TB) ~1,000 GB About 500 hours of video <p>Monty says: Let's debug this together!</p> <p> Here's a handy trick: to figure out how many values N bits can represent, just calculate 2 raised to the power of N. So 8 bits = 256 values, 16 bits = 65,536 values, and 32 bits = over 4 billion values. Bits add up fast!</p>"},{"location":"chapters/01-intro-to-computer-science/#diagram-binary-number-explorer","title":"Diagram: Binary Number Explorer","text":"Binary Number Explorer MicroSim <p>Type: microsim sim-id: binary-number-explorer Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: calculate, demonstrate</p> <p>Learning Objective: Students will be able to convert between binary and decimal representations by toggling individual bits and observing the resulting decimal value.</p> <p>Purpose: An interactive binary-to-decimal converter that lets students click individual bits to toggle them on/off and immediately see the decimal equivalent update.</p> <p>Canvas layout: - Top section: Title \"Binary Number Explorer\" - Middle section: 8 large toggle switches representing 8 bits, arranged left to right from most significant bit (128) to least significant bit (1) - Above each switch: The place value label (128, 64, 32, 16, 8, 4, 2, 1) - Below the switches: The current binary string (e.g., \"01000001\") - Bottom section: Large display showing the decimal equivalent (e.g., \"= 65\") - Below that: The calculation breakdown (e.g., \"0\u00d7128 + 1\u00d764 + 0\u00d732 + 0\u00d716 + 0\u00d78 + 0\u00d74 + 0\u00d72 + 1\u00d71 = 65\")</p> <p>Interactive controls: - Click any bit to toggle it between 0 (off/gray) and 1 (on/green) - \"Random\" button: Sets a random binary number for the student to interpret - \"Reset\" button: Sets all bits to 0 - \"Challenge Mode\" button: Shows a target decimal number and asks the student to set the correct binary bits</p> <p>Visual elements: - Each bit displayed as a large toggle switch or clickable circle - ON bits glow green with \"1\" label - OFF bits are gray with \"0\" label - Place values shown above in a lighter font - Calculation breakdown updates in real-time - In Challenge Mode, a target number appears and turns green when matched correctly</p> <p>Default state: All bits set to 0 (decimal 0)</p> <p>Behavior: - Toggling any bit immediately recalculates and displays the decimal value - The calculation breakdown updates to show which place values are active - In Challenge Mode, display a congratulations message when the student matches the target number</p> <p>Responsive: Canvas width adjusts to window; bit switches scale proportionally</p> <p>Instructional Rationale: Direct manipulation of individual bits supports the Apply level by requiring students to actively calculate binary-to-decimal conversions. Immediate visual feedback on each toggle helps build fluency with place values. Challenge Mode adds a goal-oriented practice dimension.</p>"},{"location":"chapters/01-intro-to-computer-science/#character-encoding","title":"Character Encoding","text":"<p>So computers store everything as numbers. But how do they handle text? After all, you're reading words right now, not numbers. The answer is character encoding \u2014 a system that assigns a unique number to every letter, digit, and symbol.</p> <p>Think of it like a secret code book. The letter 'A' might be assigned the number 65. The letter 'B' gets 66. A space is 32. When you type \"Hi!\" on your keyboard, the computer actually stores the numbers 72, 105, 33.</p>"},{"location":"chapters/01-intro-to-computer-science/#ascii-and-unicode","title":"ASCII and Unicode","text":"<p>The first widely used character encoding was ASCII (American Standard Code for Information Interchange), created in the 1960s. ASCII uses 7 bits to represent 128 characters, including:</p> <ul> <li>Uppercase letters (A-Z): numbers 65-90</li> <li>Lowercase letters (a-z): numbers 97-122</li> <li>Digits (0-9): numbers 48-57</li> <li>Punctuation and special characters: !, @, #, etc.</li> <li>Control characters: things like \"new line\" and \"tab\"</li> </ul> <p>ASCII worked great for English, but what about other languages? Chinese has thousands of characters. Arabic reads right to left. Japanese uses multiple writing systems. ASCII couldn't handle any of that.</p> <p>Enter Unicode, the modern standard that assigns a unique number to over 150,000 characters from virtually every writing system on Earth \u2014 plus emoji! That smiley face you send in texts (\ud83d\ude0a) has a Unicode number just like the letter 'A' does.</p> <p>Here are some examples:</p> Character ASCII Value Unicode Name A 65 Latin Capital Letter A a 97 Latin Small Letter A 0 48 Digit Zero ! 33 Exclamation Mark \u2014 N/A Em Dash (Unicode only) \ud83d\ude0a N/A Smiling Face with Smiling Eyes (Unicode only) <p>The most common Unicode encoding is called UTF-8. It's cleverly designed to be backward compatible with ASCII \u2014 so all the old ASCII characters still work \u2014 while also supporting the full range of Unicode characters. Most websites and modern software use UTF-8.</p>"},{"location":"chapters/01-intro-to-computer-science/#diagram-ascii-character-map","title":"Diagram: ASCII Character Map","text":"ASCII Character Map Interactive Explorer <p>Type: infographic sim-id: ascii-character-map Library: p5.js Status: Specified</p> <p>Bloom Level: Remember (L1) Bloom Verb: identify, recall</p> <p>Learning Objective: Students will be able to look up the ASCII numeric value for common characters and recognize the pattern of how letters and digits are organized in the ASCII table.</p> <p>Purpose: An interactive grid showing the printable ASCII characters (codes 32-126) where students can hover over any character to see its decimal value, binary representation, and category.</p> <p>Layout: - Grid of cells, approximately 16 columns x 6 rows, showing printable ASCII characters - Each cell displays the character in a large font - Color-coded by category: uppercase letters (blue), lowercase letters (green), digits (orange), punctuation/symbols (purple), space (gray)</p> <p>Interactive elements: - Hover over any cell to see a tooltip showing:   - The character   - Decimal ASCII value   - Binary representation (8-bit)   - Category (letter, digit, symbol) - A search box at the top: type a character to highlight it in the grid - A \"Show Decimal Values\" toggle: when on, each cell shows the number below the character</p> <p>Color scheme: - Uppercase A-Z: light blue background - Lowercase a-z: light green background - Digits 0-9: light orange background - Symbols/punctuation: light purple background - Space: light gray</p> <p>Visual style: Clean grid with rounded cell borders, soft shadows on hover Responsive: Grid adjusts column count based on window width</p> <p>Instructional Rationale: A visual grid layout supports the Remember level by letting students browse and locate characters spatially. Color-coding by category reveals the organizational structure of ASCII. The hover-to-reveal interaction encourages active exploration rather than passive reading of a table.</p>"},{"location":"chapters/01-intro-to-computer-science/#programming-languages-talking-to-computers","title":"Programming Languages: Talking to Computers","text":"<p>You now know that computers only understand binary \u2014 ones and zeros. But no one wants to write programs as long strings of 1s and 0s. (Trust me, people tried in the early days. It was not fun.) That's why we have programming languages.</p> <p>A programming language is a structured way to write instructions that a computer can understand. It sits somewhere between human language (which is flexible and messy) and machine language (which is rigid and binary). Programming languages let you express ideas like \"add these two numbers\" or \"repeat this action 100 times\" in a way that's readable by both you and the computer.</p> <p>There are hundreds of programming languages, each designed for different purposes:</p> Language Common Use Fun Fact Python General purpose, AI, data science Named after Monty Python, not the snake! JavaScript Web development Runs in every web browser on Earth Java Enterprise software, Android apps \"Write once, run anywhere\" C Operating systems, embedded systems Created in 1972 and still going strong Scratch Learning to code (visual blocks) Developed at MIT for beginners Swift iPhone and Mac apps Apple's modern replacement for Objective-C"},{"location":"chapters/01-intro-to-computer-science/#compiled-vs-interpreted","title":"Compiled vs. Interpreted","text":"<p>Programming languages generally fall into two categories based on how they turn your code into something the computer can run:</p> <p>Compiled languages (like C and Java) use a special program called a compiler to translate your entire source code into machine code before the program runs. It's like translating a whole book from English to Spanish before giving it to a Spanish reader. The translation takes time, but once it's done, the Spanish reader can read it very quickly.</p> <p>Interpreted languages (like Python and JavaScript) use an interpreter that translates and runs your code one line at a time. It's like having a live translator at a conference \u2014 they translate each sentence as the speaker says it. This is more flexible (you can change things on the fly), but it can be a bit slower since the translation happens while the program is running.</p> <p>Here's a quick comparison:</p> Feature Compiled Interpreted Translation All at once, before running Line by line, while running Speed Generally faster execution Generally slower execution Flexibility Must recompile after changes Changes take effect immediately Error detection Catches many errors before running Errors found when that line runs Examples C, C++, Go, Rust Python, JavaScript, Ruby <p>Monty says: Let's debug this together!</p> <p> Here's an analogy that might stick: A compiled language is like baking a whole cake before serving it. An interpreted language is like making pancakes \u2014 you cook and serve them one at a time. Both give you something delicious, just in different ways!</p>"},{"location":"chapters/01-intro-to-computer-science/#why-python","title":"Why Python?","text":"<p>Out of all those programming languages, why are we learning Python? Great question. Here's why Python is an excellent first language:</p> <ul> <li>Readable: Python code looks almost like English. When you read a Python program, you can often guess what it does even if you've never coded before.</li> <li>Beginner-friendly: Python has a gentler learning curve than most languages. Less punctuation, less boilerplate, fewer things to memorize.</li> <li>Powerful: Despite being easy to learn, Python is used by professionals at Google, NASA, Netflix, Instagram, and countless other organizations.</li> <li>Versatile: Python is used for web development, data analysis, artificial intelligence, scientific computing, automation, and much more.</li> <li>Huge community: Millions of Python developers worldwide means tons of tutorials, libraries, and help when you get stuck.</li> </ul> <p>Python was created in 1991 by Guido van Rossum, who named it after the British comedy group Monty Python's Flying Circus (not the snake \u2014 though snakes have become the unofficial mascot). Van Rossum wanted a language that was fun to use, and he succeeded.</p>"},{"location":"chapters/01-intro-to-computer-science/#the-python-interpreter","title":"The Python Interpreter","text":"<p>Since Python is an interpreted language, it uses the Python interpreter to run your code. The interpreter reads your Python instructions, translates them into something the computer understands, and executes them.</p> <p>You can think of the Python interpreter as a very obedient (but very literal) assistant. It will do exactly what you ask \u2014 no more, no less. If you give it perfect instructions, it will produce perfect results. If your instructions have a mistake, it will tell you (sometimes cryptically, but it tries).</p> <p>The interpreter can work in two modes:</p> <ol> <li>Interactive mode \u2014 You type one command at a time, and the interpreter responds immediately. Great for experimenting and testing ideas quickly.</li> <li>Script mode \u2014 You write all your commands in a file (a \"script\"), and the interpreter runs the whole file from top to bottom. This is how real programs are built.</li> </ol> <p>We'll explore both modes hands-on in the next chapter when we start writing actual Python code.</p>"},{"location":"chapters/01-intro-to-computer-science/#diagram-compiled-vs-interpreted-languages","title":"Diagram: Compiled vs. Interpreted Languages","text":"Compiled vs Interpreted Languages Comparison MicroSim <p>Type: microsim sim-id: compiled-vs-interpreted Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: compare, explain</p> <p>Learning Objective: Students will be able to compare compiled and interpreted language execution models by stepping through a visual side-by-side demonstration of how source code is translated and run.</p> <p>Purpose: A side-by-side animated comparison showing how compiled and interpreted languages process the same simple program, making the abstract concept of compilation vs interpretation concrete and visible.</p> <p>Canvas layout: - Split screen: left half labeled \"Compiled (e.g., C)\", right half labeled \"Interpreted (e.g., Python)\" - Each side shows a 3-stage pipeline:   - Stage 1: Source code (a simple 3-line pseudocode program)   - Stage 2: Translation step (compiler on left, interpreter on right)   - Stage 3: Execution/output</p> <p>Data Visibility Requirements: - Stage 1: Show identical source code on both sides:   - Line 1: \"x = 5\"   - Line 2: \"y = 10\"   - Line 3: \"print x + y\" - Stage 2 (Compiled): Show ALL lines being translated at once into machine code, then a \"Ready to run\" indicator - Stage 2 (Interpreted): Show ONLY the current line being translated, with a \"Translating line N...\" indicator - Stage 3 (Compiled): After full translation, show rapid execution of all lines, output appears: \"15\" - Stage 3 (Interpreted): After each line is translated, it immediately executes before moving to the next line. Output \"15\" appears after the last line.</p> <p>Interactive controls: - \"Step\" button: Advance the demonstration one step at a time - \"Auto Play\" button: Animate all steps automatically with a 1-second delay - \"Reset\" button: Return to the starting state - Speed slider: Adjust auto-play speed (0.5s to 2s per step)</p> <p>Visual elements: - Source code lines highlighted in yellow when being processed - Compiled side: all lines glow simultaneously during compilation - Interpreted side: one line glows at a time - Arrow animations show flow from source \u2192 translation \u2192 execution - A step counter shows \"Step N of M\" in the footer</p> <p>Instructional Rationale: Step-through with worked examples is appropriate because the Understand/compare objective requires learners to observe the different sequencing of translation and execution. Side-by-side layout makes the structural difference immediately visible. Step controls let students pause and reflect at each stage rather than watching a continuous animation.</p>"},{"location":"chapters/01-intro-to-computer-science/#putting-it-all-together","title":"Putting It All Together","text":"<p>Let's step back and see how everything in this chapter connects. You've learned that:</p> <ol> <li>Computer science is about solving problems with computation</li> <li>Computational thinking gives you a toolkit: decomposition, pattern recognition, abstraction, and algorithms</li> <li>Hardware provides the physical machinery: CPU, memory, storage, and I/O devices</li> <li>Binary is the language computers actually speak (ones and zeros)</li> <li>Character encoding (ASCII and Unicode) maps human-readable text to binary numbers</li> <li>Programming languages let you write instructions in a human-friendly way</li> <li>Python is a beginner-friendly, powerful, interpreted language \u2014 and it's what we'll use throughout this course</li> </ol> <p>These concepts build on each other like floors of a building. Hardware is the foundation. Binary is how data is stored in that hardware. Character encoding turns human text into binary. Programming languages let you write instructions without worrying about binary. And computational thinking helps you write good instructions.</p> <p>Monty says: You've got this!</p> <p> You just finished your first chapter \u2014 nice work, coder! You now know more about how computers think and work than most people ever learn. In the next chapter, we'll get our hands dirty with actual Python code. Get ready to write your first program!</p>"},{"location":"chapters/01-intro-to-computer-science/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Computer science is the study of solving problems using computation \u2014 it shows up in every field from medicine to music.</li> <li>Computational thinking has four pillars: decomposition, pattern recognition, abstraction, and algorithms.</li> <li>Stepwise refinement means breaking problems down again and again until each piece is simple.</li> <li>Computer hardware includes the CPU (brain), RAM (desk), storage (filing cabinet), and input/output devices.</li> <li>Binary uses only 1s and 0s. A bit is a single binary digit; a byte is 8 bits.</li> <li>ASCII encodes 128 characters; Unicode encodes 150,000+ characters from every writing system (including emoji!).</li> <li>Operating systems manage hardware and run your programs.</li> <li>Programming languages let you write instructions the computer can follow. They can be compiled (all-at-once translation) or interpreted (line-by-line translation).</li> <li>Python is an interpreted, readable, versatile language \u2014 and it's your new best friend for this course.</li> </ul> Check Your Understanding: What binary number equals decimal 13? <p>Binary 1101 = (1 \u00d7 8) + (1 \u00d7 4) + (0 \u00d7 2) + (1 \u00d7 1) = 8 + 4 + 0 + 1 = 13</p> Check Your Understanding: Which pillar of computational thinking means 'focus on what matters and ignore details'? <p>Abstraction! It's the skill of stripping away unnecessary details so you can focus on the big picture \u2014 like a subway map that only shows you the lines and stops, not every building in the city.</p> Check Your Understanding: Is Python compiled or interpreted? <p>Python is an interpreted language. The Python interpreter translates and runs your code one line at a time, which makes it great for experimenting and learning.</p>"},{"location":"chapters/02-python-fundamentals/","title":"Python Fundamentals","text":""},{"location":"chapters/02-python-fundamentals/#python-fundamentals","title":"Python Fundamentals","text":""},{"location":"chapters/02-python-fundamentals/#summary","title":"Summary","text":"<p>This chapter covers the essential building blocks of Python programming. Students will learn to use the Python REPL and write scripts, work with variables and data types (integers, floats, booleans, strings), perform arithmetic operations, handle type conversions, and use basic input/output. By the end of this chapter, students will be able to write simple Python programs that process data and produce output.</p>"},{"location":"chapters/02-python-fundamentals/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 30 concepts from the learning graph:</p> <ol> <li>Python REPL</li> <li>Python Scripts</li> <li>Comments in Code</li> <li>Variables</li> <li>Variable Assignment</li> <li>Variable Naming Rules</li> <li>Data Types</li> <li>Integer Type</li> <li>Float Type</li> <li>Boolean Type</li> <li>String Type</li> <li>Type Function</li> <li>Type Conversion</li> <li>Implicit Type Conversion</li> <li>Explicit Type Casting</li> <li>Arithmetic Operators</li> <li>Integer Division</li> <li>Modulo Operator</li> <li>Operator Precedence</li> <li>String Concatenation</li> <li>String Repetition</li> <li>F-String Formatting</li> <li>Print Function</li> <li>Input Function</li> <li>Multiple Assignment</li> <li>Constants Convention</li> <li>Augmented Assignment</li> <li>Expressions</li> <li>Statements</li> <li>Code Readability</li> </ol>"},{"location":"chapters/02-python-fundamentals/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 1: Introduction to Computer Science</li> </ul> <p>Monty says: Let's code this!</p> <p> Welcome back, coders! Last chapter you learned how computers think. Now it's time to make them do things. You're about to write your very first Python code, work with variables, crunch numbers, and build small programs. By the end of this chapter, you'll be speaking Python. Let's code this!</p>"},{"location":"chapters/02-python-fundamentals/#two-ways-to-run-python","title":"Two Ways to Run Python","text":"<p>Before we write any code, let's talk about where that code runs. Python gives you two ways to work: the REPL and scripts. Think of them like a calculator versus a word processor. One is great for quick answers; the other is for building something you want to keep.</p>"},{"location":"chapters/02-python-fundamentals/#the-python-repl","title":"The Python REPL","text":"<p>The Python REPL stands for Read, Evaluate, Print, Loop. It's Python's interactive mode \u2014 you type a command, Python reads it, evaluates it (figures out the answer), prints the result, and then loops back, waiting for your next command.</p> <p>To start the REPL, open a terminal and type <code>python</code> (or <code>python3</code> on some systems). You'll see something like this:</p> <pre><code>&gt;&gt;&gt; 2 + 3\n5\n&gt;&gt;&gt; \"Hello, world!\"\n'Hello, world!'\n</code></pre> <p>The <code>&gt;&gt;&gt;</code> is Python's prompt, telling you it's ready for input. The REPL is perfect for experimenting. Want to know what <code>7 * 8</code> is? Just type it in and hit Enter. Want to test whether a piece of code works? Try it in the REPL first. It's your coding sandbox.</p>"},{"location":"chapters/02-python-fundamentals/#python-scripts","title":"Python Scripts","text":"<p>The REPL is great for quick experiments, but what if you want to save your work and run it again later? That's where Python scripts come in. A script is just a plain text file (ending in <code>.py</code>) that contains Python code. When you run the script, Python executes every line from top to bottom.</p> <p>Here's a simple script saved as <code>hello.py</code>:</p> <pre><code># My first Python script\nname = \"Monty\"\nprint(\"Hello, \" + name + \"!\")\nprint(\"Welcome to Python!\")\n</code></pre> <p>You run it from the terminal with:</p> <pre><code>python hello.py\n</code></pre> <p>And the output is:</p> <pre><code>Hello, Monty!\nWelcome to Python!\n</code></pre> <p>Scripts are how real programs are built. You write the code, save it, test it, fix any bugs, and run it again. Throughout this course, you'll write plenty of scripts.</p>"},{"location":"chapters/02-python-fundamentals/#comments-in-code","title":"Comments in Code","text":"<p>Did you notice the line that starts with <code>#</code> in the script above? That's a comment. Comments are notes you write for humans \u2014 Python ignores them completely. They're like sticky notes on your code, explaining what's happening and why.</p> <pre><code># This is a comment \u2014 Python skips this line\nprint(\"This runs!\")  # You can also put comments at the end of a line\n</code></pre> <p>Good comments explain why you did something, not just what you did. Compare these:</p> <pre><code># Bad comment \u2014 just restates the code\nx = 10  # set x to 10\n\n# Good comment \u2014 explains the purpose\nx = 10  # starting score for a new player\n</code></pre> <p>Write comments for your future self. Trust us \u2014 when you look at your code two weeks from now, you'll be glad you left some notes.</p>"},{"location":"chapters/02-python-fundamentals/#diagram-python-repl-vs-scripts","title":"Diagram: Python REPL vs. Scripts","text":"Python REPL vs. Scripts Interactive Comparison <p>Type: microsim sim-id: repl-vs-scripts Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: compare, distinguish</p> <p>Learning Objective: Students will be able to distinguish between interactive REPL mode and script mode, understanding when to use each approach.</p> <p>Layout: - Split screen: left half labeled \"REPL (Interactive Mode)\", right half labeled \"Script Mode\" - Left side: simulated terminal with <code>&gt;&gt;&gt;</code> prompt where students can type simple expressions and see immediate output - Right side: a mini code editor area showing a multi-line script, with a \"Run\" button that executes all lines sequentially and shows output below</p> <p>Interactive elements: - Left (REPL): A text input field with <code>&gt;&gt;&gt;</code> prompt. Students type simple expressions (e.g., <code>2+3</code>, <code>\"hello\"</code>) and see the result appear below, then a new prompt appears - Right (Script): A pre-loaded 4-line script. Students click \"Run\" to see lines highlight one by one as they execute, with output appearing in a console panel below - \"Switch Example\" button cycles through 3 different example scripts - A comparison table at the bottom highlights key differences (immediate feedback vs. saved &amp; reusable, experimenting vs. building programs)</p> <p>Visual style: Terminal-like dark background with green/white text on REPL side; light editor theme with syntax highlighting on script side Responsive: Both panels stack vertically on narrow screens</p> <p>Instructional Rationale: Side-by-side interaction lets students directly experience the difference between REPL and script execution models. Typing in the simulated REPL reinforces the read-evaluate-print-loop concept, while watching sequential script execution builds understanding of top-to-bottom program flow.</p>"},{"location":"chapters/02-python-fundamentals/#variables-labeled-boxes-for-your-data","title":"Variables: Labeled Boxes for Your Data","text":"<p>Now let's talk about one of the most important ideas in programming: variables. A variable is like a labeled box where you store a value. You give it a name \u2014 like <code>score</code> or <code>player_name</code> \u2014 and Python remembers what's inside. You can peek at the value, change it, or use it in calculations.</p>"},{"location":"chapters/02-python-fundamentals/#variable-assignment","title":"Variable Assignment","text":"<p>Creating a variable is called variable assignment. You use the <code>=</code> sign (called the assignment operator) to put a value into a variable:</p> <pre><code>score = 100\nplayer_name = \"Ada\"\nis_playing = True\n</code></pre> <p>After these lines run, Python has three labeled boxes in memory:</p> <ul> <li><code>score</code> contains <code>100</code></li> <li><code>player_name</code> contains <code>\"Ada\"</code></li> <li><code>is_playing</code> contains <code>True</code></li> </ul> <p>You can change what's in a variable at any time \u2014 just assign it a new value:</p> <pre><code>score = 100\nprint(score)   # Output: 100\nscore = 250\nprint(score)   # Output: 250\n</code></pre> <p>The old value (100) is gone, replaced by 250. Variables are variable \u2014 they can change. (Who would have guessed?)</p>"},{"location":"chapters/02-python-fundamentals/#variable-naming-rules","title":"Variable Naming Rules","text":"<p>Not just any name will work. Python has variable naming rules you need to follow:</p> Rule Valid Example Invalid Example Why It Fails Must start with a letter or underscore <code>score</code>, <code>_count</code> <code>2fast</code> Starts with a digit Can contain letters, digits, underscores <code>player_1</code>, <code>high_score</code> <code>my-name</code> Hyphens not allowed Case-sensitive <code>Score</code> and <code>score</code> are different \u2014 \u2014 Can't be a Python keyword <code>total</code> <code>class</code>, <code>if</code>, <code>for</code> These are reserved words <p>Python conventions also recommend:</p> <ul> <li>Use <code>snake_case</code> for variable names: <code>player_score</code>, not <code>playerScore</code> or <code>PlayerScore</code></li> <li>Choose descriptive names: <code>temperature</code> is better than <code>t</code></li> <li>Avoid single-letter names (except in short loops \u2014 we'll get to those later)</li> </ul> <p>Monty says: Watch out!</p> <p> A common beginner mistake is confusing <code>=</code> (assignment) with <code>==</code> (equality check). Writing <code>score = 100</code> stores 100 in score. Writing <code>score == 100</code> asks \"is score equal to 100?\" They look similar but do very different things!</p>"},{"location":"chapters/02-python-fundamentals/#multiple-assignment","title":"Multiple Assignment","text":"<p>Python has a neat shortcut called multiple assignment that lets you assign values to several variables in one line:</p> <pre><code>x, y, z = 10, 20, 30\n</code></pre> <p>This creates three variables at once: <code>x</code> is 10, <code>y</code> is 20, and <code>z</code> is 30. You can even swap two variables without a temporary variable:</p> <pre><code>a, b = 5, 10\na, b = b, a    # Now a is 10 and b is 5 \u2014 Python magic!\n</code></pre> <p>In most other languages, swapping two variables requires three lines and a temporary variable. Python makes it a one-liner. Pretty slick.</p>"},{"location":"chapters/02-python-fundamentals/#constants-convention","title":"Constants Convention","text":"<p>Sometimes you have a value that should never change \u2014 like the speed of light or the number of lives in a game. In Python, there's no way to truly lock a variable, but there is a constants convention: name it in ALL_CAPS with underscores.</p> <pre><code>MAX_LIVES = 3\nPI = 3.14159\nGRAVITY = 9.8\n</code></pre> <p>When other programmers (or your future self) see <code>MAX_LIVES</code>, they know: \"Don't change this value.\" It's a social contract, not a technical enforcement. Python trusts you. Don't break that trust.</p>"},{"location":"chapters/02-python-fundamentals/#data-types-what-kind-of-stuff-is-in-the-box","title":"Data Types: What Kind of Stuff Is in the Box?","text":"<p>Every value in Python has a data type that tells Python what kind of thing it is. Just like you wouldn't store soup in a paper bag, Python needs to know whether it's dealing with a number, some text, or a true/false value.</p> <p>Python has several built-in data types, but we'll focus on the four most important ones for now:</p> Data Type Python Name Example Values What It Stores Integer <code>int</code> <code>42</code>, <code>-7</code>, <code>0</code> Whole numbers Float <code>float</code> <code>3.14</code>, <code>-0.5</code>, <code>2.0</code> Decimal numbers Boolean <code>bool</code> <code>True</code>, <code>False</code> Yes/no values String <code>str</code> <code>\"hello\"</code>, <code>'Python'</code> Text"},{"location":"chapters/02-python-fundamentals/#integer-type","title":"Integer Type","text":"<p>The integer type (<code>int</code>) stores whole numbers \u2014 no decimal point. Integers can be positive, negative, or zero:</p> <pre><code>age = 16\ntemperature = -5\ncount = 0\nreally_big = 1000000000    # Python handles big numbers just fine\n</code></pre> <p>Python integers have no size limit. You can store numbers with hundreds of digits if you need to. (You probably won't, but it's nice to know.)</p>"},{"location":"chapters/02-python-fundamentals/#float-type","title":"Float Type","text":"<p>The float type (<code>float</code>) stores numbers with a decimal point. The name \"float\" comes from \"floating point,\" which is how computers represent decimal numbers internally.</p> <pre><code>price = 9.99\npi = 3.14159\nnegative_temp = -40.0\n</code></pre> <p>One important gotcha: floating-point arithmetic isn't always perfectly precise. Try this in the REPL:</p> <pre><code>&gt;&gt;&gt; 0.1 + 0.2\n0.30000000000000004\n</code></pre> <p>Wait, what? That's not 0.3! This happens because computers store decimals in binary, and some decimal fractions (like 0.1) can't be represented exactly in binary. It's like trying to write 1/3 in decimal \u2014 you get 0.333333... forever. For this course, you usually won't notice this, but it's good to know it exists.</p>"},{"location":"chapters/02-python-fundamentals/#boolean-type","title":"Boolean Type","text":"<p>The boolean type (<code>bool</code>) has only two possible values: <code>True</code> and <code>False</code>. (Note the capital T and F \u2014 Python is picky about that.)</p> <pre><code>is_sunny = True\ngame_over = False\nhas_permission = True\n</code></pre> <p>Booleans are named after George Boole, a mathematician who developed the algebra of logic in the 1800s. We'll use booleans a lot in Chapter 3 when we cover Boolean logic. For now, just know they represent yes/no, on/off, true/false answers.</p>"},{"location":"chapters/02-python-fundamentals/#string-type","title":"String Type","text":"<p>The string type (<code>str</code>) stores text \u2014 any sequence of characters. You create a string by wrapping text in quotes (either single or double quotes):</p> <pre><code>greeting = \"Hello, world!\"\nname = 'Monty'\nempty = \"\"                  # An empty string is still a string\nlong_text = \"Python is fun and I'm learning a lot!\"\n</code></pre> <p>Strings can contain letters, digits, spaces, punctuation \u2014 anything you can type. We'll do much more with strings later (Chapter 5 is all about them), but for now, just know they're how Python handles text.</p>"},{"location":"chapters/02-python-fundamentals/#diagram-python-data-types-overview","title":"Diagram: Python Data Types Overview","text":"Python Data Types Interactive Overview <p>Type: infographic sim-id: python-data-types Library: p5.js Status: Specified</p> <p>Bloom Level: Remember (L1) Bloom Verb: identify, classify</p> <p>Learning Objective: Students will be able to identify the four fundamental Python data types (int, float, bool, str) and classify example values into the correct type.</p> <p>Layout: - Four large colored cards arranged in a 2x2 grid, one for each data type - Each card shows: type name, Python keyword, 3-4 example values, a real-world analogy icon - Below the cards: a \"Type Sorter\" challenge area</p> <p>Cards: 1. Integer (blue): <code>int</code> \u2014 examples: <code>42</code>, <code>-7</code>, <code>0</code>, <code>1000</code> \u2014 icon: counting blocks 2. Float (green): <code>float</code> \u2014 examples: <code>3.14</code>, <code>-0.5</code>, <code>2.0</code>, <code>99.99</code> \u2014 icon: ruler with tick marks 3. Boolean (orange): <code>bool</code> \u2014 examples: <code>True</code>, <code>False</code> \u2014 icon: light switch 4. String (purple): <code>str</code> \u2014 examples: <code>\"hello\"</code>, <code>'Python'</code>, <code>\"\"</code>, <code>\"42\"</code> \u2014 icon: speech bubble</p> <p>Interactive elements: - Hover over any card to see it enlarge slightly and display a more detailed description - \"Type Sorter\" challenge: 8 random values appear at the bottom. Students drag each value to the correct type card. Correct placements glow green; incorrect placements bounce back with a hint - \"New Round\" button generates a new set of values for the challenge - Score counter tracks correct placements</p> <p>Visual style: Rounded cards with soft shadows, clean typography, color-coded borders Responsive: Cards stack in a single column on narrow screens; challenge area adjusts accordingly</p> <p>Instructional Rationale: Card-based visual categorization supports the Remember level by associating type names with concrete examples. The drag-and-drop sorting activity provides immediate feedback and active recall practice, which is more effective than passive reading.</p>"},{"location":"chapters/02-python-fundamentals/#the-type-function","title":"The Type Function","text":"<p>How do you check what type a value is? Use the type function:</p> <pre><code>&gt;&gt;&gt; type(42)\n&lt;class 'int'&gt;\n&gt;&gt;&gt; type(3.14)\n&lt;class 'float'&gt;\n&gt;&gt;&gt; type(True)\n&lt;class 'bool'&gt;\n&gt;&gt;&gt; type(\"hello\")\n&lt;class 'str'&gt;\n</code></pre> <p>The <code>type()</code> function is like asking Python, \"Hey, what kind of thing is this?\" It's especially useful when debugging \u2014 if your code isn't working, checking types can help you figure out what went wrong.</p> <p>You can also use <code>type()</code> on variables:</p> <pre><code>score = 100\nprint(type(score))    # Output: &lt;class 'int'&gt;\n</code></pre> <p>Monty says: You've got this!</p> <p> Here's something sneaky: <code>\"42\"</code> and <code>42</code> look similar but are totally different types. <code>\"42\"</code> is a string (text that happens to contain digits), while <code>42</code> is an integer (an actual number you can do math with). Try <code>type(\"42\")</code> in the REPL \u2014 you'll see it's <code>str</code>, not <code>int</code>!</p>"},{"location":"chapters/02-python-fundamentals/#type-conversion-changing-one-type-to-another","title":"Type Conversion: Changing One Type to Another","text":"<p>Sometimes you need to change a value from one type to another. This is called type conversion, and Python handles it in two ways.</p>"},{"location":"chapters/02-python-fundamentals/#implicit-type-conversion","title":"Implicit Type Conversion","text":"<p>Implicit type conversion happens automatically when Python needs to. For example, if you add an integer and a float, Python automatically converts the integer to a float:</p> <pre><code>&gt;&gt;&gt; 5 + 2.0\n7.0\n</code></pre> <p>Python implicitly converted <code>5</code> (an int) to <code>5.0</code> (a float) before doing the addition. It chose float because float can hold more information (decimal places) without losing anything. This is also called \"type promotion\" \u2014 the smaller type gets promoted to the bigger type.</p>"},{"location":"chapters/02-python-fundamentals/#explicit-type-casting","title":"Explicit Type Casting","text":"<p>Explicit type casting is when you tell Python to convert a value. You use the type name as a function:</p> <pre><code># String to integer\nage_text = \"16\"\nage_number = int(age_text)     # Now it's the integer 16\n\n# Integer to float\nwhole = 7\ndecimal = float(whole)          # Now it's 7.0\n\n# Number to string\nscore = 100\nscore_text = str(score)         # Now it's the string \"100\"\n\n# String to float\nprice_text = \"9.99\"\nprice = float(price_text)       # Now it's the float 9.99\n</code></pre> <p>Type casting is essential when working with user input (since the <code>input()</code> function always returns a string \u2014 more on that soon).</p> <p>Be careful, though \u2014 not every conversion makes sense:</p> <pre><code>&gt;&gt;&gt; int(\"hello\")\nValueError: invalid literal for int() with base 10: 'hello'\n</code></pre> <p>Python can't turn the word \"hello\" into a number. When a conversion fails, Python raises an error. We'll learn how to handle errors gracefully in Chapter 14.</p>"},{"location":"chapters/02-python-fundamentals/#arithmetic-operators-python-as-a-calculator","title":"Arithmetic Operators: Python as a Calculator","text":"<p>One of the first things most people do with Python is math. Python supports all the standard arithmetic operators you'd expect, plus a couple of extras.</p> Operator Name Example Result <code>+</code> Addition <code>7 + 3</code> <code>10</code> <code>-</code> Subtraction <code>7 - 3</code> <code>4</code> <code>*</code> Multiplication <code>7 * 3</code> <code>21</code> <code>/</code> Division <code>7 / 3</code> <code>2.3333...</code> <code>//</code> Integer Division <code>7 // 3</code> <code>2</code> <code>%</code> Modulo <code>7 % 3</code> <code>1</code> <code>**</code> Exponentiation <code>7 ** 3</code> <code>343</code> <p>The first four should look familiar from math class. Let's dig into the ones that might be new.</p>"},{"location":"chapters/02-python-fundamentals/#integer-division","title":"Integer Division","text":"<p>Regular division (<code>/</code>) always gives you a float result, even if it divides evenly:</p> <pre><code>&gt;&gt;&gt; 10 / 2\n5.0\n</code></pre> <p>But integer division (<code>//</code>) chops off the decimal part and gives you a whole number:</p> <pre><code>&gt;&gt;&gt; 7 // 3\n2\n&gt;&gt;&gt; 10 // 3\n3\n&gt;&gt;&gt; -7 // 2\n-4\n</code></pre> <p>Think of integer division as asking: \"How many whole times does 3 fit into 7?\" The answer is 2 (with some left over). Integer division is useful when you need whole-number results, like figuring out how many full teams of 5 you can make from 23 students.</p>"},{"location":"chapters/02-python-fundamentals/#modulo-operator","title":"Modulo Operator","text":"<p>The modulo operator (<code>%</code>) gives you the remainder after integer division:</p> <pre><code>&gt;&gt;&gt; 7 % 3\n1\n&gt;&gt;&gt; 10 % 3\n1\n&gt;&gt;&gt; 12 % 4\n0\n</code></pre> <p>Modulo is incredibly useful. Here are some common tricks:</p> <ul> <li>Check if a number is even: <code>number % 2 == 0</code> (if the remainder when dividing by 2 is 0, it's even)</li> <li>Check if a number is odd: <code>number % 2 == 1</code></li> <li>Wrap around: If you have 12 hours on a clock and add 5 hours to 10 o'clock, you get <code>(10 + 5) % 12 = 3</code> o'clock</li> </ul> <p>Integer division and modulo are partners. They answer: \"How many full groups, and how many left over?\"</p> <pre><code>students = 23\nteam_size = 5\nfull_teams = students // team_size    # 4 full teams\nleftover = students % team_size       # 3 students left over\n</code></pre>"},{"location":"chapters/02-python-fundamentals/#diagram-arithmetic-operators-explorer","title":"Diagram: Arithmetic Operators Explorer","text":"Arithmetic Operators Interactive Explorer <p>Type: microsim sim-id: arithmetic-operators Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: calculate, use</p> <p>Learning Objective: Students will be able to apply Python's seven arithmetic operators to compute correct results, with special attention to integer division and modulo.</p> <p>Layout: - Top section: Two number input fields (A and B) with a dropdown to select an operator (+, -, , /, //, %, *) - Middle section: A large display showing the expression and result (e.g., \"7 // 3 = 2\") - Below that: A visual explanation area that changes based on the operator selected - Bottom section: A \"Challenge Mode\" with random arithmetic problems for students to solve</p> <p>Operator-specific visual explanations: - For <code>//</code> (integer division): Show a bar divided into groups, highlighting full groups and leftover - For <code>%</code> (modulo): Show the same bar but highlight the remainder portion - For <code>**</code> (exponentiation): Show repeated multiplication (e.g., 2**3 = 2 x 2 x 2 = 8) - For <code>/</code> (division): Show decimal result on a number line</p> <p>Interactive elements: - Adjust A and B using number inputs or up/down buttons - Select operator from dropdown - Result updates in real-time as inputs change - \"Challenge Mode\" button: presents a random expression and asks the student to predict the result before revealing the answer - Score counter for challenge mode</p> <p>Visual style: Calculator-inspired layout with large, readable digits; color-coded operators Responsive: Single-column layout on narrow screens</p> <p>Instructional Rationale: Direct manipulation of operands and operators supports the Apply level by letting students experiment with different combinations and immediately observe results. The visual explanation for integer division and modulo addresses the most common confusion points. Challenge mode promotes active recall.</p>"},{"location":"chapters/02-python-fundamentals/#operator-precedence","title":"Operator Precedence","text":"<p>When you have an expression with multiple operators, Python follows operator precedence rules (just like math class). Here's the order from highest to lowest:</p> Priority Operator Description 1 (highest) <code>**</code> Exponentiation 2 <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code> Multiplication, Division, Integer Division, Modulo 3 (lowest) <code>+</code>, <code>-</code> Addition, Subtraction <p>Operators with the same priority are evaluated left to right.</p> <pre><code>&gt;&gt;&gt; 2 + 3 * 4\n14        # Multiplication first: 3*4=12, then 2+12=14\n\n&gt;&gt;&gt; (2 + 3) * 4\n20        # Parentheses override precedence: 2+3=5, then 5*4=20\n\n&gt;&gt;&gt; 2 ** 3 ** 2\n512       # Exponentiation is right-to-left: 3**2=9, then 2**9=512\n</code></pre> <p>When in doubt, use parentheses! They make your code clearer and ensure Python does the math in the order you expect. Even if they're technically unnecessary, parentheses can make your code easier to read:</p> <pre><code># Both are correct, but the second is clearer\nresult = a * b + c / d\nresult = (a * b) + (c / d)\n</code></pre>"},{"location":"chapters/02-python-fundamentals/#augmented-assignment","title":"Augmented Assignment","text":"<p>Once you start doing math with variables, you'll often want to update a variable based on its current value. Python provides augmented assignment operators as a shortcut:</p> <pre><code>score = 100\n\n# The long way\nscore = score + 10    # score is now 110\n\n# The shortcut (augmented assignment)\nscore += 10           # score is now 120\n\n# Works with other operators too\nscore -= 5            # score is now 115\nscore *= 2            # score is now 230\nscore //= 10          # score is now 23\n</code></pre> <p>Here's the full list:</p> Augmented Equivalent To <code>x += 5</code> <code>x = x + 5</code> <code>x -= 5</code> <code>x = x - 5</code> <code>x *= 5</code> <code>x = x * 5</code> <code>x /= 5</code> <code>x = x / 5</code> <code>x //= 5</code> <code>x = x // 5</code> <code>x %= 5</code> <code>x = x % 5</code> <code>x **= 5</code> <code>x = x ** 5</code> <p>Augmented assignment saves typing and makes your intentions clearer. When you see <code>score += 10</code>, you instantly know \"add 10 to the score.\"</p>"},{"location":"chapters/02-python-fundamentals/#working-with-strings","title":"Working with Strings","text":"<p>Numbers are great, but programs also need to work with text. Let's look at some fun things you can do with strings.</p>"},{"location":"chapters/02-python-fundamentals/#string-concatenation","title":"String Concatenation","text":"<p>String concatenation means joining two strings together using the <code>+</code> operator:</p> <pre><code>first = \"Hello\"\nsecond = \"World\"\ngreeting = first + \" \" + second\nprint(greeting)    # Output: Hello World\n</code></pre> <p>Notice we added <code>\" \"</code> (a space) in the middle. Without it, we'd get <code>\"HelloWorld\"</code> \u2014 the strings are glued together exactly as-is.</p> <p>You can't concatenate a string and a number directly \u2014 Python will complain:</p> <pre><code>&gt;&gt;&gt; \"Score: \" + 100\nTypeError: can only concatenate str (not \"int\") to str\n</code></pre> <p>You need to convert the number to a string first using <code>str()</code>:</p> <pre><code>print(\"Score: \" + str(100))    # Output: Score: 100\n</code></pre>"},{"location":"chapters/02-python-fundamentals/#string-repetition","title":"String Repetition","text":"<p>String repetition uses the <code>*</code> operator to repeat a string:</p> <pre><code>&gt;&gt;&gt; \"ha\" * 3\n'hahaha'\n&gt;&gt;&gt; \"-\" * 40\n'----------------------------------------'\n</code></pre> <p>This is surprisingly useful for creating visual separators, padding, or just making your output look nice.</p>"},{"location":"chapters/02-python-fundamentals/#f-string-formatting","title":"F-String Formatting","text":"<p>Converting types manually with <code>str()</code> gets tedious. Python's f-string formatting is a much cleaner way to mix variables and text. Just put an <code>f</code> before the opening quote and wrap variables in curly braces <code>{}</code>:</p> <pre><code>name = \"Ada\"\nscore = 95\nprint(f\"Player {name} scored {score} points!\")\n# Output: Player Ada scored 95 points!\n</code></pre> <p>F-strings automatically handle type conversion \u2014 you don't need to call <code>str()</code>. You can even put expressions inside the braces:</p> <pre><code>price = 19.99\ntax_rate = 0.08\nprint(f\"Total: ${price * (1 + tax_rate):.2f}\")\n# Output: Total: $21.59\n</code></pre> <p>The <code>:.2f</code> part is a format specifier that rounds to 2 decimal places \u2014 handy for money! F-strings are the modern, preferred way to format strings in Python. You'll use them constantly.</p>"},{"location":"chapters/02-python-fundamentals/#diagram-string-operations-playground","title":"Diagram: String Operations Playground","text":"String Operations Interactive Playground <p>Type: microsim sim-id: string-operations Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: construct, demonstrate</p> <p>Learning Objective: Students will be able to construct string expressions using concatenation, repetition, and f-string formatting, and predict the output of string operations.</p> <p>Layout: - Top section: Two text input fields labeled \"String A\" and \"String B\" with default values \"Hello\" and \"World\" - Middle section: Three operation panels side by side:   - Panel 1 \"Concatenation\": Shows <code>A + \" \" + B</code> and result   - Panel 2 \"Repetition\": Shows <code>A * N</code> with a slider for N (1-10) and result   - Panel 3 \"F-String\": Shows <code>f\"Dear {A}, welcome to {B}!\"</code> and result - Bottom section: A \"Build Your Own\" text area where students can type string expressions and see live results</p> <p>Interactive elements: - Editing String A or String B immediately updates all three panels - Repetition slider changes the repeat count in real-time - \"Build Your Own\" area: students type expressions like <code>\"ha\" * 5</code> or <code>A + \"!\" * 3</code> and click \"Evaluate\" to see the result - A gallery of 5 example expressions students can click to load into the \"Build Your Own\" area</p> <p>Visual style: Clean panels with colored borders (green for concatenation, blue for repetition, purple for f-strings); string values displayed in monospace font Responsive: Panels stack vertically on narrow screens</p> <p>Instructional Rationale: Immediate visual feedback when editing input strings supports the Apply level by letting students experiment freely. Three operations shown simultaneously helps students compare and contrast them. The \"Build Your Own\" area encourages creative exploration beyond the provided examples.</p>"},{"location":"chapters/02-python-fundamentals/#input-and-output-talking-to-the-user","title":"Input and Output: Talking to the User","text":"<p>Programs need to communicate. The print function sends information out to the user, and the input function brings information in from the user.</p>"},{"location":"chapters/02-python-fundamentals/#the-print-function","title":"The Print Function","text":"<p>You've already seen <code>print()</code> in action. The print function displays text on the screen:</p> <pre><code>print(\"Hello!\")                   # Output: Hello!\nprint(42)                         # Output: 42\nprint(\"Score:\", 100)              # Output: Score: 100\nprint(\"A\", \"B\", \"C\")             # Output: A B C\n</code></pre> <p>Notice that when you pass multiple values separated by commas, <code>print()</code> puts a space between each one. You can change the separator and the ending character:</p> <pre><code>print(\"2025\", \"02\", \"11\", sep=\"-\")    # Output: 2025-02-11\nprint(\"Loading\", end=\"...\")            # Output: Loading...  (no newline)\n</code></pre>"},{"location":"chapters/02-python-fundamentals/#the-input-function","title":"The Input Function","text":"<p>The input function pauses your program and waits for the user to type something. Whatever they type becomes a string:</p> <pre><code>name = input(\"What's your name? \")\nprint(f\"Nice to meet you, {name}!\")\n</code></pre> <p>When this runs, the user sees:</p> <pre><code>What's your name? Ada\nNice to meet you, Ada!\n</code></pre> <p>Here's the critical thing to remember: <code>input()</code> always returns a string, even if the user types a number. If you want to do math with the input, you need to convert it:</p> <pre><code>age_text = input(\"How old are you? \")    # This is a string like \"16\"\nage = int(age_text)                       # Now it's the integer 16\nnext_year = age + 1\nprint(f\"Next year you'll be {next_year}!\")\n</code></pre> <p>Or you can do it in one line:</p> <pre><code>age = int(input(\"How old are you? \"))\n</code></pre> <p>Monty says: Let's debug this together!</p> <p> Here's a common debugging trick: if your math isn't working, check whether your variable is accidentally a string. Use <code>type()</code> to verify. If <code>type(age)</code> shows <code>&lt;class 'str'&gt;</code>, you forgot to convert!</p>"},{"location":"chapters/02-python-fundamentals/#expressions-and-statements","title":"Expressions and Statements","text":"<p>Let's step back and learn two important vocabulary words that programmers use all the time.</p> <p>An expression is any piece of code that produces a value. Think of it like a question that Python answers:</p> <pre><code>2 + 3             # Expression that produces 5\nx * 10            # Expression that produces x times 10\nlen(\"hello\")      # Expression that produces 5\nscore &gt; 100       # Expression that produces True or False\n</code></pre> <p>A statement is a complete instruction that Python carries out. It does something rather than just producing a value:</p> <pre><code>x = 10                    # Assignment statement\nprint(\"Hello!\")           # Print statement\nname = input(\"Name? \")    # Statement that assigns user input\n</code></pre> <p>Here's the easy way to remember: expressions produce values, statements perform actions. Some statements contain expressions. For example, <code>x = 2 + 3</code> is a statement that contains the expression <code>2 + 3</code>.</p>"},{"location":"chapters/02-python-fundamentals/#diagram-expressions-vs-statements","title":"Diagram: Expressions vs. Statements","text":"Expressions vs Statements Sorting Activity <p>Type: microsim sim-id: expressions-vs-statements Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: classify, distinguish</p> <p>Learning Objective: Students will be able to classify Python code fragments as expressions (produce a value) or statements (perform an action) and explain the difference.</p> <p>Layout: - Top: Title and brief definition reminders (\"Expression = produces a value\" / \"Statement = performs an action\") - Middle: A queue of 10 code fragments displayed as draggable cards, one at a time - Bottom: Two labeled drop zones \u2014 \"Expression\" (left, blue) and \"Statement\" (right, green)</p> <p>Code fragment examples: 1. <code>2 + 3</code> (expression) 2. <code>x = 10</code> (statement) 3. <code>print(\"hi\")</code> (statement) 4. <code>len(\"hello\")</code> (expression) 5. <code>score &gt; 100</code> (expression) 6. <code>name = input(\"?\")</code> (statement) 7. <code>7 * 8</code> (expression) 8. <code>x += 1</code> (statement) 9. <code>True</code> (expression) 10. <code>\"hello\" + \" world\"</code> (expression)</p> <p>Interactive elements: - Drag each card to the correct zone - Correct placement: card slots in with a green checkmark and a one-line explanation - Incorrect placement: card bounces back with a hint (e.g., \"This produces a value \u2014 it's an expression!\") - Progress bar shows how many of 10 are classified - \"Reset\" button to start over - Final score and summary displayed after all 10 are classified</p> <p>Visual style: Card-based UI with code in monospace font; blue and green drop zones with dashed borders Responsive: Cards and zones stack vertically on narrow screens</p> <p>Instructional Rationale: A sorting/classification activity directly targets the Understand level by requiring students to apply the definition to concrete examples. Immediate feedback with explanations reinforces correct mental models. Seeing many examples helps students build intuition about the expression/statement distinction.</p>"},{"location":"chapters/02-python-fundamentals/#code-readability-writing-code-humans-can-read","title":"Code Readability: Writing Code Humans Can Read","text":"<p>Here's a truth that surprises many beginners: code is read far more often than it's written. You write a line of code once, but you (and others) might read it dozens of times. That's why code readability matters so much.</p> <p>Python was designed with readability as a core value. Its creator, Guido van Rossum, famously said: \"Code is read much more often than it is written.\" Here are some guidelines to keep your code clean and readable:</p> <p>Use meaningful variable names:</p> <pre><code># Hard to read \u2014 what do these mean?\nx = 16\ny = 5.5\nz = x * y\n\n# Easy to read \u2014 names tell the story\nage = 16\nhourly_wage = 5.5\nweekly_pay = age * hourly_wage   # Hmm, actually this formula doesn't make sense...\n# See? Good names help you spot logic errors too!\n</code></pre> <p>Add whitespace around operators:</p> <pre><code># Cramped and hard to read\nresult=a*b+c/d-e\n\n# Spacious and clear\nresult = a * b + c / d - e\n</code></pre> <p>Use blank lines to separate logical sections:</p> <pre><code># Get user information\nname = input(\"Name: \")\nage = int(input(\"Age: \"))\n\n# Calculate result\nbirth_year = 2026 - age\n\n# Display output\nprint(f\"{name}, you were born around {birth_year}.\")\n</code></pre> <p>Keep lines short (under 79 characters is the Python convention) and write comments that explain why, not what.</p> <p>Good readability isn't just being nice to other people \u2014 it's being nice to yourself. Future You will thank Present You for writing clear code.</p>"},{"location":"chapters/02-python-fundamentals/#diagram-code-readability-comparison","title":"Diagram: Code Readability Comparison","text":"Code Readability Before-and-After Comparison <p>Type: infographic sim-id: code-readability Library: p5.js Status: Specified</p> <p>Bloom Level: Evaluate (L5) Bloom Verb: critique, improve</p> <p>Learning Objective: Students will be able to evaluate Python code for readability and identify specific improvements (naming, spacing, comments, structure).</p> <p>Layout: - Split screen: left side \"Before\" (poorly written code), right side \"After\" (improved version) - Below: a checklist of readability improvements applied - Navigation: \"Next Example\" button cycles through 4 before/after pairs</p> <p>Example pairs: 1. Variable naming: <code>x = 16</code> vs <code>student_age = 16</code> 2. Spacing: <code>result=a*b+c</code> vs <code>result = a * b + c</code> 3. Comments: No comments vs helpful comments explaining why 4. Structure: One long block vs logically separated sections with blank lines</p> <p>Interactive elements: - Hover over any highlighted difference to see a tooltip explaining the improvement - \"Show Differences\" toggle highlights the changes between before and after in yellow - \"Next Example\" button cycles through the 4 pairs - A \"Try It Yourself\" panel at the bottom shows a messy code snippet and lets students type an improved version, with a \"Check\" button that compares against the clean version</p> <p>Visual style: Code editor theme with syntax highlighting; left side has a slight red tint (bad), right side has a slight green tint (good) Responsive: Before/After panels stack vertically on narrow screens</p> <p>Instructional Rationale: Side-by-side comparison directly supports the Evaluate level by asking students to identify and judge code quality differences. The \"Try It Yourself\" component promotes transfer from observation to practice. Multiple examples cover the main readability dimensions (naming, spacing, comments, structure).</p>"},{"location":"chapters/02-python-fundamentals/#putting-it-all-together-a-complete-program","title":"Putting It All Together: A Complete Program","text":"<p>Let's combine everything from this chapter into a complete program. This script asks the user for information, does some calculations, and displays the results using f-strings:</p> <pre><code># Temperature Converter: Fahrenheit to Celsius\n# Formula: C = (F - 32) * 5/9\n\n# Constants\nFREEZING_POINT = 32\nCONVERSION_FACTOR = 5 / 9\n\n# Get input from the user\nfahrenheit = float(input(\"Enter temperature in Fahrenheit: \"))\n\n# Calculate Celsius\ncelsius = (fahrenheit - FREEZING_POINT) * CONVERSION_FACTOR\n\n# Display the result\nprint(f\"{fahrenheit}\u00b0F is equal to {celsius:.1f}\u00b0C\")\n\n# Bonus: Tell the user if water would freeze\nif celsius &lt;= 0:\n    print(\"Brrr! Water would freeze at this temperature!\")\nelse:\n    print(\"Above freezing \u2014 no ice today!\")\n</code></pre> <p>Look at how many concepts from this chapter appear in just this small program:</p> <ul> <li>Comments explaining the purpose</li> <li>Constants in ALL_CAPS (<code>FREEZING_POINT</code>, <code>CONVERSION_FACTOR</code>)</li> <li>Input function getting data from the user</li> <li>Explicit type casting with <code>float()</code></li> <li>Variables with descriptive names</li> <li>Arithmetic operators (<code>-</code>, <code>*</code>, <code>/</code>)</li> <li>F-string formatting with <code>:.1f</code> for one decimal place</li> <li>Print function for output</li> <li>Code readability through spacing, comments, and logical sections</li> </ul> <p>That's the power of Python fundamentals \u2014 a handful of building blocks can create real, useful programs.</p> <p>Monty says: You've got this!</p> <p> Amazing work, coder! You just learned the essential building blocks of Python \u2014 variables, data types, operators, input, output, and more. These fundamentals are the foundation for everything we'll build in this course. Next chapter, we'll dive into Boolean logic and making decisions in code. See you there!</p>"},{"location":"chapters/02-python-fundamentals/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>The Python REPL lets you experiment interactively; scripts let you save and run programs from files.</li> <li>Comments (<code>#</code>) explain your code to humans \u2014 Python ignores them.</li> <li>Variables store values. Use variable assignment (<code>=</code>) to create them, and follow variable naming rules (start with a letter/underscore, use <code>snake_case</code>).</li> <li>Python has four core data types: integers (<code>int</code>), floats (<code>float</code>), booleans (<code>bool</code>), and strings (<code>str</code>).</li> <li>Use the type function (<code>type()</code>) to check a value's type.</li> <li>Type conversion can happen implicitly (Python does it automatically) or explicitly (you use <code>int()</code>, <code>float()</code>, <code>str()</code>).</li> <li>Arithmetic operators include <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code> (integer division), <code>%</code> (modulo), and <code>**</code> (exponentiation).</li> <li>Operator precedence follows math rules: exponentiation first, then multiplication/division, then addition/subtraction. Use parentheses to be clear.</li> <li>String concatenation (<code>+</code>) joins strings, string repetition (<code>*</code>) repeats them, and f-strings (<code>f\"...\"</code>) let you embed variables and expressions.</li> <li>The print function displays output; the input function reads text from the user (always returns a string!).</li> <li>Multiple assignment lets you set several variables in one line. Augmented assignment (<code>+=</code>, <code>-=</code>, etc.) updates a variable based on its current value.</li> <li>Constants use ALL_CAPS names by convention. Expressions produce values; statements perform actions.</li> <li>Code readability matters \u2014 use descriptive names, add spaces, write helpful comments, and organize your code into logical sections.</li> </ul> Check Your Understanding: What is the result of <code>17 // 5</code> and <code>17 % 5</code>? <p><code>17 // 5</code> equals 3 (17 divided by 5 is 3 with a remainder). <code>17 % 5</code> equals 2 (the remainder when 17 is divided by 5). Together they tell you: 5 fits into 17 three full times with 2 left over.</p> Check Your Understanding: Why does <code>input()</code> always return a string, and what should you do about it? <p>The <code>input()</code> function returns a string because it captures raw text from the keyboard \u2014 it has no way to know if the user intended to type a number or actual text. If you need a number, you must explicitly cast it using <code>int()</code> or <code>float()</code>. For example: <code>age = int(input(\"Age: \"))</code>.</p> Check Your Understanding: What's the difference between <code>=</code> and <code>==</code> in Python? <p><code>=</code> is the assignment operator \u2014 it stores a value in a variable (e.g., <code>score = 100</code> puts 100 into score). <code>==</code> is the equality operator \u2014 it checks whether two values are equal and produces a boolean result (e.g., <code>score == 100</code> evaluates to <code>True</code> or <code>False</code>). Mixing them up is one of the most common beginner mistakes!</p>"},{"location":"chapters/03-boolean-logic/","title":"Boolean Logic and Comparisons","text":""},{"location":"chapters/03-boolean-logic/#boolean-logic-and-comparisons","title":"Boolean Logic and Comparisons","text":""},{"location":"chapters/03-boolean-logic/#summary","title":"Summary","text":"<p>This chapter explores Boolean logic, the foundation of all decision-making in programming. Students will learn about Boolean expressions, comparison operators, logical operators (and, or, not), short-circuit evaluation, and truthiness in Python. The chapter also covers De Morgan's Laws and truth tables, providing the logical reasoning skills needed for control flow programming.</p>"},{"location":"chapters/03-boolean-logic/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 15 concepts from the learning graph:</p> <ol> <li>Boolean Expressions</li> <li>Comparison Operators</li> <li>Equal and Not Equal</li> <li>Greater and Less Than</li> <li>Logical Operators</li> <li>And Operator</li> <li>Or Operator</li> <li>Not Operator</li> <li>Short-Circuit Evaluation</li> <li>Truthiness and Falsiness</li> <li>Boolean Conversion</li> <li>Chained Comparisons</li> <li>Order of Operations</li> <li>De Morgan's Laws</li> <li>Truth Tables</li> </ol>"},{"location":"chapters/03-boolean-logic/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 2: Python Fundamentals</li> </ul> <p>Monty says: Let's code this!</p> <p> Welcome back, coders! Get ready for a chapter that's all about decisions. Every time a computer checks your password, filters your search results, or decides whether an enemy in a video game should attack \u2014 it's using Boolean logic. By the end of this chapter, you'll be thinking in <code>True</code> and <code>False</code> like a pro. Let's do this!</p>"},{"location":"chapters/03-boolean-logic/#true-or-false-the-world-of-boolean-expressions","title":"True or False: The World of Boolean Expressions","text":"<p>Every day, you make decisions based on yes-or-no questions. \"Is it raining?\" \"Did I finish my homework?\" \"Is it past midnight?\" Each of these questions has exactly two possible answers: yes or no. In programming, we call these answers <code>True</code> and <code>False</code>, and the questions that produce them are called Boolean expressions.</p> <p>A Boolean expression is any expression that evaluates to either <code>True</code> or <code>False</code>. That's it \u2014 no \"maybe,\" no \"sort of,\" no \"I'll think about it.\" Just two options. Computers love this simplicity because, as you learned in Chapter 1, they're built on binary \u2014 ones and zeros, on and off, true and false.</p> <p>The name \"Boolean\" comes from George Boole, a 19th-century mathematician who figured out that logic could be treated as algebra. Thanks, George! Your work powers every <code>if</code> statement, every search engine, and every spam filter on the planet.</p> <p>In Python, the Boolean data type is called <code>bool</code>, and it has exactly two values:</p> <pre><code>&gt;&gt;&gt; type(True)\n&lt;class 'bool'&gt;\n&gt;&gt;&gt; type(False)\n&lt;class 'bool'&gt;\n</code></pre> <p>Notice that <code>True</code> and <code>False</code> are capitalized in Python. Writing <code>true</code> or <code>FALSE</code> will give you an error. Python is picky about this.</p>"},{"location":"chapters/03-boolean-logic/#comparison-operators-asking-questions","title":"Comparison Operators: Asking Questions","text":"<p>So how do you create Boolean expressions? The most common way is with comparison operators. These are symbols that compare two values and return <code>True</code> or <code>False</code>.</p> <p>Think of comparison operators like a judge at a talent show. You hand the judge two contestants, and the judge answers a specific question: \"Is this one better than that one?\" \"Are they tied?\" The answer is always yes or no.</p> <p>Here are Python's six comparison operators:</p> Operator Meaning Example Result <code>==</code> Equal to <code>5 == 5</code> <code>True</code> <code>!=</code> Not equal to <code>5 != 3</code> <code>True</code> <code>&gt;</code> Greater than <code>7 &gt; 4</code> <code>True</code> <code>&lt;</code> Less than <code>3 &lt; 8</code> <code>True</code> <code>&gt;=</code> Greater than or equal to <code>5 &gt;= 5</code> <code>True</code> <code>&lt;=</code> Less than or equal to <code>4 &lt;= 3</code> <code>False</code> <p>Let's try them out in Python:</p> <pre><code>&gt;&gt;&gt; 10 == 10\nTrue\n&gt;&gt;&gt; 10 == 7\nFalse\n&gt;&gt;&gt; \"hello\" == \"hello\"\nTrue\n&gt;&gt;&gt; 3.14 &gt; 2.71\nTrue\n</code></pre>"},{"location":"chapters/03-boolean-logic/#equal-and-not-equal","title":"Equal and Not Equal","text":"<p>The equal operator (<code>==</code>) checks whether two values are the same. The not equal operator (<code>!=</code>) checks whether they're different. These are probably the two operators you'll use most often.</p> <pre><code>&gt;&gt;&gt; password = \"secret123\"\n&gt;&gt;&gt; password == \"secret123\"\nTrue\n&gt;&gt;&gt; password != \"wrong_guess\"\nTrue\n&gt;&gt;&gt; 42 == 42.0\nTrue\n</code></pre> <p>Wait \u2014 did you catch that last one? <code>42 == 42.0</code> is <code>True</code> because Python compares the values, and the integer 42 and the float 42.0 represent the same number.</p> <p>Monty says: Let's debug this together!</p> <p> The number one beginner mistake with Booleans: using a single <code>=</code> when you mean <code>==</code>. Remember, a single <code>=</code> is the assignment operator (it stores a value in a variable). A double <code>==</code> is the comparison operator (it checks if two values are equal). Mixing them up is like confusing \"put this in the box\" with \"is this in the box?\"</p>"},{"location":"chapters/03-boolean-logic/#greater-and-less-than","title":"Greater and Less Than","text":"<p>The greater than (<code>&gt;</code>) and less than (<code>&lt;</code>) operators work exactly like they do in math class. The greater than or equal to (<code>&gt;=</code>) and less than or equal to (<code>&lt;=</code>) operators add the \"or equal\" condition.</p> <pre><code>&gt;&gt;&gt; age = 16\n&gt;&gt;&gt; age &gt; 13\nTrue\n&gt;&gt;&gt; age &lt; 18\nTrue\n&gt;&gt;&gt; age &gt;= 16\nTrue\n&gt;&gt;&gt; age &lt;= 15\nFalse\n</code></pre> <p>These operators aren't limited to numbers. You can compare strings too! Python compares strings alphabetically (technically, it uses Unicode values, but the effect is the same for English letters):</p> <pre><code>&gt;&gt;&gt; \"apple\" &lt; \"banana\"\nTrue\n&gt;&gt;&gt; \"cat\" &gt; \"car\"\nTrue\n&gt;&gt;&gt; \"A\" &lt; \"a\"\nTrue\n</code></pre> <p>That last one might surprise you. Capital letters come before lowercase letters in Unicode, so <code>\"A\"</code> is \"less than\" <code>\"a\"</code>. Keep that in mind when comparing strings.</p>"},{"location":"chapters/03-boolean-logic/#diagram-comparison-operator-explorer","title":"Diagram: Comparison Operator Explorer","text":"Comparison Operator Explorer MicroSim <p>Type: microsim sim-id: comparison-operator-explorer Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: experiment, predict</p> <p>Learning Objective: Students will be able to predict and verify the result of comparison expressions by selecting operators and values, then checking the Boolean output.</p> <p>Purpose: An interactive sandbox where students can choose two values and a comparison operator, predict the result (True or False), and then reveal the answer.</p> <p>Layout: - Top section: Title \"Comparison Operator Explorer\" - Middle section: Two input fields (left value and right value) with a dropdown menu between them showing all six comparison operators (==, !=, &gt;, &lt;, &gt;=, &lt;=) - Below: A \"Predict\" section with True/False buttons for the student to guess - Bottom: A \"Reveal\" button that shows the actual result, with green (correct) or red (incorrect) feedback</p> <p>Interactive controls: - Left value input: text field accepting numbers or quoted strings - Operator dropdown: ==, !=, &gt;, &lt;, &gt;=, &lt;= - Right value input: text field accepting numbers or quoted strings - \"True\" and \"False\" prediction buttons - \"Reveal Answer\" button - \"New Challenge\" button: generates a random comparison for the student to evaluate - Score tracker: shows correct/total in the corner</p> <p>Visual elements: - The expression is displayed in a large, code-styled font (e.g., <code>5 &gt; 3</code>) - True result glows green; False result glows red - Correct predictions trigger a brief celebration animation - Incorrect predictions show the correct answer with an explanation</p> <p>Behavior: - Student selects or enters values and operator - Student predicts True or False - Clicking Reveal shows the actual result and updates the score - New Challenge mode generates random integer pairs and random operators</p> <p>Responsive: Canvas resizes with window; input fields and buttons scale proportionally</p> <p>Instructional Rationale: Predict-then-reveal interaction supports the Apply level by requiring students to mentally evaluate expressions before checking answers. The score tracker adds a gamification element that encourages repeated practice, building fluency with comparison operators.</p>"},{"location":"chapters/03-boolean-logic/#logical-operators-combining-conditions","title":"Logical Operators: Combining Conditions","text":"<p>Comparison operators are great for asking one question at a time. But real-world decisions often involve multiple conditions. \"Can I go to the movies?\" might depend on: \"Do I have enough money?\" and \"Is it before 10 PM?\" and \"Did I finish my homework?\"</p> <p>That's where logical operators come in. Python has three logical operators that let you combine Boolean expressions:</p> Operator Meaning Example <code>and</code> Both must be True <code>True and True</code> returns <code>True</code> <code>or</code> At least one must be True <code>False or True</code> returns <code>True</code> <code>not</code> Flips True to False (and vice versa) <code>not False</code> returns <code>True</code> <p>Let's look at each one.</p>"},{"location":"chapters/03-boolean-logic/#the-and-operator","title":"The And Operator","text":"<p>The <code>and</code> operator returns <code>True</code> only when both conditions are <code>True</code>. If either one is <code>False</code>, the whole expression is <code>False</code>.</p> <p>Think of it like a bouncer at a club with two rules: you must be on the guest list and you must be wearing shoes. If you fail either rule, you don't get in.</p> <pre><code>&gt;&gt;&gt; age = 16\n&gt;&gt;&gt; has_permit = True\n&gt;&gt;&gt; age &gt;= 16 and has_permit\nTrue\n&gt;&gt;&gt; age &gt;= 18 and has_permit\nFalse\n</code></pre> <p>Here's the truth table for <code>and</code>:</p> A B A and B <code>True</code> <code>True</code> <code>True</code> <code>True</code> <code>False</code> <code>False</code> <code>False</code> <code>True</code> <code>False</code> <code>False</code> <code>False</code> <code>False</code> <p>Notice the pattern: <code>and</code> is strict. Only one combination out of four gives you <code>True</code>.</p>"},{"location":"chapters/03-boolean-logic/#the-or-operator","title":"The Or Operator","text":"<p>The <code>or</code> operator returns <code>True</code> when at least one condition is <code>True</code>. It only returns <code>False</code> when both conditions are <code>False</code>.</p> <p>Think of it like choosing a movie: \"I'll watch it if it has good reviews or if my friend recommends it.\" You only skip it if neither is true.</p> <pre><code>&gt;&gt;&gt; is_weekend = True\n&gt;&gt;&gt; is_holiday = False\n&gt;&gt;&gt; is_weekend or is_holiday\nTrue\n&gt;&gt;&gt; is_weekend = False\n&gt;&gt;&gt; is_weekend or is_holiday\nFalse\n</code></pre> <p>Here's the truth table for <code>or</code>:</p> A B A or B <code>True</code> <code>True</code> <code>True</code> <code>True</code> <code>False</code> <code>True</code> <code>False</code> <code>True</code> <code>True</code> <code>False</code> <code>False</code> <code>False</code> <p>The <code>or</code> operator is generous \u2014 three out of four combinations give you <code>True</code>.</p>"},{"location":"chapters/03-boolean-logic/#the-not-operator","title":"The Not Operator","text":"<p>The <code>not</code> operator is the simplest of the three. It takes a single Boolean value and flips it. <code>True</code> becomes <code>False</code>, and <code>False</code> becomes <code>True</code>. It's the Boolean equivalent of saying \"opposite day!\"</p> <pre><code>&gt;&gt;&gt; is_raining = False\n&gt;&gt;&gt; not is_raining\nTrue\n&gt;&gt;&gt; not True\nFalse\n&gt;&gt;&gt; not (5 &gt; 10)\nTrue\n</code></pre> <p>Here's the truth table for <code>not</code>:</p> A not A <code>True</code> <code>False</code> <code>False</code> <code>True</code> <p>Monty says: You've got this!</p> <p> Here's a brain teaser: what does <code>not not True</code> evaluate to? If you guessed <code>True</code>, you're right! <code>not True</code> gives <code>False</code>, and <code>not False</code> gives <code>True</code> again. Two negatives cancel out, just like in English when you say \"I'm not unhappy\" (meaning you are happy).</p>"},{"location":"chapters/03-boolean-logic/#diagram-logical-operator-venn-diagrams","title":"Diagram: Logical Operator Venn Diagrams","text":"Logical Operator Venn Diagrams MicroSim <p>Type: microsim sim-id: logical-operator-venn Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: illustrate, interpret</p> <p>Learning Objective: Students will be able to visualize the behavior of <code>and</code>, <code>or</code>, and <code>not</code> operators using Venn diagrams and predict the result of combined Boolean expressions.</p> <p>Purpose: An interactive Venn diagram visualization that shows how <code>and</code>, <code>or</code>, and <code>not</code> work by highlighting different regions of overlapping circles.</p> <p>Layout: - Top: Title \"Logical Operators as Venn Diagrams\" - Center: Two overlapping circles labeled \"A\" (left, blue) and \"B\" (right, orange) - Below circles: Three buttons labeled \"A and B\", \"A or B\", \"not A\" - Bottom: Text display showing the Boolean expression and which region is highlighted</p> <p>Interactive elements: - Click \"A and B\": Highlight only the overlapping (intersection) region in green - Click \"A or B\": Highlight the entire area covered by either circle (union) in green - Click \"not A\": Highlight everything outside circle A in green - Hover over any region to see its Boolean description (e.g., \"A is True, B is False\") - Toggle switches for A (True/False) and B (True/False) that update a results panel showing the value of <code>A and B</code>, <code>A or B</code>, <code>not A</code>, and <code>not B</code></p> <p>Visual elements: - Circle A: semi-transparent blue - Circle B: semi-transparent orange - Highlighted region: bright green overlay - Non-highlighted regions: dimmed gray - Smooth transitions when switching between operators</p> <p>Color scheme: Blue for A, orange for B, green for result region, gray for inactive Responsive: Circles scale and reposition with window size</p> <p>Instructional Rationale: Venn diagrams provide a familiar visual metaphor for set operations that maps directly to Boolean logic. The interactive highlighting makes abstract operator behavior concrete and spatial, supporting the Understand level. Toggle switches bridge the gap between the visual representation and actual True/False evaluation.</p>"},{"location":"chapters/03-boolean-logic/#truth-tables-the-complete-picture","title":"Truth Tables: The Complete Picture","text":"<p>A truth table is a chart that shows every possible combination of inputs and the resulting output for a logical expression. You've already seen individual truth tables for <code>and</code>, <code>or</code>, and <code>not</code>. Truth tables are like cheat sheets for logic \u2014 they lay out all possibilities so nothing is left to guesswork.</p> <p>Why do truth tables matter? Because when you write programs with complex conditions, you need to be absolutely sure about what happens in every scenario. A truth table guarantees you've thought through every case.</p> <p>Here's a combined truth table showing all three operators at once:</p> A B A and B A or B not A not B <code>True</code> <code>True</code> <code>True</code> <code>True</code> <code>False</code> <code>False</code> <code>True</code> <code>False</code> <code>False</code> <code>True</code> <code>False</code> <code>True</code> <code>False</code> <code>True</code> <code>False</code> <code>True</code> <code>True</code> <code>False</code> <code>False</code> <code>False</code> <code>False</code> <code>False</code> <code>True</code> <code>True</code> <p>When you have two variables, there are (2^2 = 4) rows. Three variables? (2^3 = 8) rows. Four variables? (2^4 = 16) rows. The number of rows doubles with every new variable. That's exponential growth!</p> <p>Let's build a truth table for a slightly more complex expression: <code>(A and B) or C</code>.</p> A B C A and B (A and B) or C T T T T T T T F T T T F T F T T F F F F F T T F T F T F F F F F T F T F F F F F <p>With three variables we need 8 rows to cover every combination. This might seem like a lot of work, but it's the only way to be 100% sure your logic is correct.</p>"},{"location":"chapters/03-boolean-logic/#diagram-interactive-truth-table-builder","title":"Diagram: Interactive Truth Table Builder","text":"Interactive Truth Table Builder MicroSim <p>Type: microsim sim-id: truth-table-builder Library: p5.js Status: Specified</p> <p>Bloom Level: Analyze (L4) Bloom Verb: construct, evaluate</p> <p>Learning Objective: Students will be able to construct truth tables for compound Boolean expressions and evaluate whether two expressions are logically equivalent.</p> <p>Purpose: An interactive tool where students can type a Boolean expression and see the automatically generated truth table, or build a truth table row by row to verify their understanding.</p> <p>Layout: - Top: Title \"Truth Table Builder\" - Input area: Text field where students type a Boolean expression using variables A, B, C and operators <code>and</code>, <code>or</code>, <code>not</code> - Below: Auto-generated truth table showing all input combinations and the result for each row - Right panel: A \"Practice Mode\" where students fill in the result column themselves before revealing answers</p> <p>Interactive controls: - Expression input field: accepts expressions like <code>A and B</code>, <code>not A or B</code>, <code>(A and B) or (not C)</code> - \"Generate Table\" button: creates the truth table for the expression - \"Practice Mode\" toggle: hides the result column and lets students click True/False for each row - \"Check Answers\" button: in Practice Mode, reveals correct answers and highlights errors in red - \"Compare\" button: enter two expressions to see if they produce identical truth tables (useful for De Morgan's Laws) - Variable count selector: 2 variables (A, B) or 3 variables (A, B, C)</p> <p>Visual elements: - Truth table rendered as a clean grid with alternating row colors - True values shown in green text; False values in red text - Correct answers in Practice Mode glow green; incorrect answers flash red - When comparing two equivalent expressions, both tables highlight in gold</p> <p>Behavior: - Parsing engine recognizes: <code>and</code>, <code>or</code>, <code>not</code>, parentheses, and variables A, B, C - Automatically generates all 2^n rows for n variables - Practice Mode allows students to test their understanding before seeing the answer - Compare mode shows two truth tables side by side</p> <p>Responsive: Table columns adjust width based on canvas size; scrollable if needed Default state: Expression field shows <code>A and B</code> with its truth table displayed</p> <p>Instructional Rationale: Building truth tables supports the Analyze level by requiring students to decompose complex expressions into constituent parts and systematically evaluate each combination. Practice Mode adds an active recall dimension. The Compare feature directly supports learning De Morgan's Laws by letting students verify equivalences experimentally.</p>"},{"location":"chapters/03-boolean-logic/#short-circuit-evaluation","title":"Short-Circuit Evaluation","text":"<p>Python is clever about evaluating Boolean expressions. It doesn't always need to check every part of an expression to know the answer. This behavior is called short-circuit evaluation.</p> <p>Here's the key insight:</p> <ul> <li>With <code>and</code>: If the first condition is <code>False</code>, Python stops immediately and returns <code>False</code>. Why bother checking the second condition? If the first one already failed, the whole <code>and</code> expression can't possibly be <code>True</code>.</li> <li>With <code>or</code>: If the first condition is <code>True</code>, Python stops immediately and returns <code>True</code>. Why check the second condition? One <code>True</code> is all <code>or</code> needs.</li> </ul> <pre><code>&gt;&gt;&gt; False and (1 / 0 &gt; 0)  # Never evaluates 1/0 -- no error!\nFalse\n&gt;&gt;&gt; True or (1 / 0 &gt; 0)    # Never evaluates 1/0 -- no error!\nTrue\n</code></pre> <p>Whoa! <code>1 / 0</code> would normally cause a <code>ZeroDivisionError</code>, but Python never even gets to it. The first operand already determined the result, so Python short-circuits and skips the rest.</p> <p>This isn't just a fun trick \u2014 it's genuinely useful. You can write \"guard\" conditions to prevent errors:</p> <pre><code>&gt;&gt;&gt; x = 0\n&gt;&gt;&gt; x != 0 and 100 / x &gt; 10  # Safe! Short-circuits when x is 0\nFalse\n</code></pre> <p>Without short-circuit evaluation, <code>100 / x</code> would crash when <code>x</code> is zero. But because <code>x != 0</code> is <code>False</code>, Python never reaches the division. Smart!</p> <p>Here's a summary of when short-circuiting happens:</p> Expression First value Short-circuits? Result <code>False and ???</code> <code>False</code> Yes <code>False</code> <code>True and ???</code> <code>True</code> No (must check <code>???</code>) Depends on <code>???</code> <code>True or ???</code> <code>True</code> Yes <code>True</code> <code>False or ???</code> <code>False</code> No (must check <code>???</code>) Depends on <code>???</code>"},{"location":"chapters/03-boolean-logic/#truthiness-and-falsiness","title":"Truthiness and Falsiness","text":"<p>Here's where Python gets a little philosophical. You know that <code>True</code> and <code>False</code> are Boolean values. But did you know that Python treats many non-Boolean values as if they were <code>True</code> or <code>False</code>?</p> <p>This concept is called truthiness and falsiness. In Python, every value has an inherent \"truthiness\" \u2014 it's either considered truthy (acts like <code>True</code>) or falsy (acts like <code>False</code>) when used in a Boolean context.</p> <p>The falsy values in Python are:</p> <ul> <li><code>False</code> (obviously)</li> <li><code>0</code> (zero, the integer)</li> <li><code>0.0</code> (zero, the float)</li> <li><code>\"\"</code> (empty string)</li> <li><code>[]</code> (empty list)</li> <li><code>()</code> (empty tuple)</li> <li><code>{}</code> (empty dictionary)</li> <li><code>None</code> (Python's \"nothing\" value)</li> </ul> <p>Everything else is truthy. Non-zero numbers, non-empty strings, non-empty lists \u2014 all truthy.</p> <pre><code>&gt;&gt;&gt; bool(42)\nTrue\n&gt;&gt;&gt; bool(0)\nFalse\n&gt;&gt;&gt; bool(\"hello\")\nTrue\n&gt;&gt;&gt; bool(\"\")\nFalse\n&gt;&gt;&gt; bool([1, 2, 3])\nTrue\n&gt;&gt;&gt; bool([])\nFalse\n</code></pre> <p>Here's a handy way to remember it: empty and zero are falsy; everything else is truthy.</p> <p>Monty says: Let's debug this together!</p> <p> A super common Python pattern is checking if a list has items: <code>if my_list:</code> is the same as <code>if len(my_list) &gt; 0:</code>, but shorter and more \"Pythonic.\" Experienced Python programmers use truthiness all the time to write cleaner code!</p>"},{"location":"chapters/03-boolean-logic/#boolean-conversion","title":"Boolean Conversion","text":"<p>You can explicitly convert any value to a Boolean using the <code>bool()</code> function. This is called Boolean conversion (sometimes called \"casting to bool\").</p> <pre><code>&gt;&gt;&gt; bool(1)\nTrue\n&gt;&gt;&gt; bool(0)\nFalse\n&gt;&gt;&gt; bool(\"Python\")\nTrue\n&gt;&gt;&gt; bool(\"\")\nFalse\n&gt;&gt;&gt; bool(None)\nFalse\n&gt;&gt;&gt; bool(-5)\nTrue\n</code></pre> <p>Notice that <code>-5</code> is truthy. Any non-zero number is truthy, even negative numbers. Only zero itself is falsy.</p> <p>Here's a reference table for Boolean conversion:</p> Value <code>bool()</code> result Why? <code>1</code> <code>True</code> Non-zero integer <code>0</code> <code>False</code> Zero <code>-3.14</code> <code>True</code> Non-zero float <code>0.0</code> <code>False</code> Zero float <code>\"hi\"</code> <code>True</code> Non-empty string <code>\"\"</code> <code>False</code> Empty string <code>[1,2]</code> <code>True</code> Non-empty list <code>[]</code> <code>False</code> Empty list <code>None</code> <code>False</code> Python's \"nothing\""},{"location":"chapters/03-boolean-logic/#diagram-truthiness-tester","title":"Diagram: Truthiness Tester","text":"Truthiness Tester MicroSim <p>Type: microsim sim-id: truthiness-tester Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: classify, predict</p> <p>Learning Objective: Students will be able to classify Python values as truthy or falsy and predict the result of <code>bool()</code> conversion.</p> <p>Purpose: A sorting game where students drag Python values into \"Truthy\" and \"Falsy\" bins, reinforcing their understanding of which values Python treats as True and which as False.</p> <p>Layout: - Top: Title \"Truthiness Tester: Truthy or Falsy?\" - Center: A row of draggable cards, each showing a Python value (e.g., <code>0</code>, <code>\"\"</code>, <code>42</code>, <code>\"hello\"</code>, <code>None</code>, <code>[]</code>, <code>[1]</code>, <code>-7</code>, <code>0.0</code>, <code>\"False\"</code>) - Bottom: Two labeled bins \u2014 \"Truthy\" (green, left) and \"Falsy\" (red, right) - Score area: Shows correct/total after each submission</p> <p>Interactive controls: - Drag any value card into the Truthy or Falsy bin - \"Check\" button: evaluates all placed cards and shows correct/incorrect - \"New Round\" button: generates a new set of 8-10 random values - \"Hint\" button: highlights one incorrectly placed card without revealing the answer</p> <p>Value pool (randomly selected per round): - Falsy: <code>0</code>, <code>0.0</code>, <code>\"\"</code>, <code>False</code>, <code>None</code>, <code>[]</code>, <code>()</code>, <code>{}</code> - Truthy: <code>1</code>, <code>-1</code>, <code>42</code>, <code>3.14</code>, <code>\"hello\"</code>, <code>\"0\"</code>, <code>\" \"</code>, <code>[0]</code>, <code>True</code>, <code>\"False\"</code>, <code>\"None\"</code></p> <p>Tricky values (intentional learning moments): - <code>\"0\"</code> is truthy (it's a non-empty string, even though the content is \"0\") - <code>\"False\"</code> is truthy (it's a non-empty string, not the Boolean False) - <code>\" \"</code> (space) is truthy (it's a non-empty string) - <code>[0]</code> is truthy (it's a non-empty list, even though it contains zero)</p> <p>Visual elements: - Cards have a code-style font - Correct placements glow green; incorrect placements glow red and bounce back - Running score displayed prominently - Brief explanation appears for each card on Check (\"'0' is truthy because it's a non-empty string\")</p> <p>Responsive: Cards and bins resize with window; cards wrap to multiple rows on narrow screens</p> <p>Instructional Rationale: A sorting/classification game supports the Apply level by requiring students to actively categorize values rather than passively reading a list. The \"tricky\" values (like <code>\"0\"</code> and <code>\"False\"</code>) directly address common misconceptions. Immediate feedback with explanations turns mistakes into learning moments.</p>"},{"location":"chapters/03-boolean-logic/#chained-comparisons","title":"Chained Comparisons","text":"<p>Python has a neat feature that most programming languages don't: chained comparisons. Instead of writing two separate comparisons joined by <code>and</code>, you can chain them together naturally \u2014 just like you would in math.</p> <p>In math, you write: (0 \\leq x \\leq 100)</p> <p>In Python, you can write:</p> <pre><code>&gt;&gt;&gt; x = 50\n&gt;&gt;&gt; 0 &lt;= x &lt;= 100\nTrue\n&gt;&gt;&gt; x = 150\n&gt;&gt;&gt; 0 &lt;= x &lt;= 100\nFalse\n</code></pre> <p>This is equivalent to writing <code>0 &lt;= x and x &lt;= 100</code>, but the chained version is cleaner and easier to read. Python evaluates it left to right, checking each comparison in order.</p> <p>You can chain as many comparisons as you want:</p> <pre><code>&gt;&gt;&gt; a, b, c = 1, 2, 3\n&gt;&gt;&gt; a &lt; b &lt; c\nTrue\n&gt;&gt;&gt; 1 &lt; 2 &lt; 3 &lt; 4 &lt; 5\nTrue\n&gt;&gt;&gt; 1 &lt; 2 &gt; 0 &lt; 5\nTrue\n</code></pre> <p>That last example is technically valid, but mixing directions like <code>&lt;</code> and <code>&gt;</code> in the same chain can be confusing. Stick to one direction for readability.</p>"},{"location":"chapters/03-boolean-logic/#order-of-operations-for-booleans","title":"Order of Operations for Booleans","text":"<p>Just like arithmetic has an order of operations (PEMDAS, anyone?), Boolean logic has its own order of operations. When Python evaluates an expression with multiple operators, it follows this priority:</p> Priority Operator Description 1 (highest) <code>()</code> Parentheses \u2014 always evaluated first 2 <code>not</code> Boolean NOT 3 <code>and</code> Boolean AND 4 (lowest) <code>or</code> Boolean OR <p>This means <code>not</code> binds tighter than <code>and</code>, which binds tighter than <code>or</code>. Consider this expression:</p> <pre><code>&gt;&gt;&gt; True or False and False\nTrue\n</code></pre> <p>Without knowing the order of operations, you might read this left to right and get <code>False</code>. But Python evaluates <code>and</code> before <code>or</code>, so it's actually:</p> <pre><code>&gt;&gt;&gt; True or (False and False)  # and is evaluated first\nTrue\n</code></pre> <p>Here's another example:</p> <pre><code>&gt;&gt;&gt; not False or True\nTrue\n&gt;&gt;&gt; not (False or True)  # Parentheses change the result!\nFalse\n</code></pre> <p>In the first line, <code>not False</code> is evaluated first (giving <code>True</code>), then <code>True or True</code> gives <code>True</code>. In the second line, the parentheses force <code>False or True</code> to evaluate first (giving <code>True</code>), then <code>not True</code> gives <code>False</code>.</p> <p>Pro tip: When in doubt, use parentheses! Even if they're technically unnecessary, parentheses make your code easier to read. Writing <code>(A and B) or C</code> is much clearer than <code>A and B or C</code>, even though they mean the same thing. Your future self (and your classmates) will thank you.</p> <p>Here's a complete example showing how Python evaluates a complex expression step by step:</p> <pre><code># Expression: not True or False and True\n\n# Step 1: Evaluate 'not True'\n# not True \u2192 False\n\n# Step 2: Evaluate 'False and True'\n# False and True \u2192 False\n\n# Step 3: Evaluate 'False or False'\n# False or False \u2192 False\n\n&gt;&gt;&gt; not True or False and True\nFalse\n</code></pre> <p>The full priority order, including comparison and arithmetic operators, is:</p> Priority Category Operators 1 (highest) Parentheses <code>()</code> 2 Arithmetic <code>**</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>+</code>, <code>-</code> 3 Comparison <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code> 4 Boolean NOT <code>not</code> 5 Boolean AND <code>and</code> 6 (lowest) Boolean OR <code>or</code> <p>This means you can write expressions like <code>x + 1 &gt; 5 and y * 2 &lt; 10</code> and Python will handle the arithmetic first, then the comparisons, then the <code>and</code>.</p>"},{"location":"chapters/03-boolean-logic/#diagram-order-of-operations-visualizer","title":"Diagram: Order of Operations Visualizer","text":"Boolean Order of Operations Visualizer MicroSim <p>Type: microsim sim-id: boolean-order-of-ops Library: p5.js Status: Specified</p> <p>Bloom Level: Analyze (L4) Bloom Verb: trace, differentiate</p> <p>Learning Objective: Students will be able to trace the step-by-step evaluation of complex Boolean expressions by applying the correct order of operations.</p> <p>Purpose: A step-through visualizer that takes a compound Boolean expression and shows each evaluation step in order, highlighting which sub-expression is being evaluated at each stage.</p> <p>Layout: - Top: Title \"Boolean Order of Operations\" - Expression display: Large code-styled text showing the full expression - Step area: Below the expression, each step is shown as the expression is progressively simplified - Bottom: Controls for stepping through</p> <p>Interactive controls: - Dropdown to select from preset expressions:   - <code>not True or False and True</code>   - <code>True and False or not False</code>   - <code>not (True and False) or True</code>   - <code>(True or False) and (not True or False)</code> - \"Step\" button: advances one evaluation step - \"Auto Play\" button: animates all steps with 1.5s delay - \"Reset\" button: returns to the original expression - Custom expression input field for student-entered expressions</p> <p>Visual elements: - The sub-expression being evaluated at each step is highlighted with a colored box - After evaluation, the sub-expression is replaced by its result (True/False) with an animation - Color coding: <code>not</code> operations in purple, <code>and</code> operations in blue, <code>or</code> operations in orange - A sidebar shows the priority rules as a reminder - Step counter: \"Step N of M\"</p> <p>Evaluation example for <code>not True or False and True</code>: 1. Highlight <code>not True</code> \u2192 replace with <code>False</code> \u2192 display: <code>False or False and True</code> 2. Highlight <code>False and True</code> \u2192 replace with <code>False</code> \u2192 display: <code>False or False</code> 3. Highlight <code>False or False</code> \u2192 replace with <code>False</code> \u2192 Final result: <code>False</code></p> <p>Responsive: Expression text scales with window width; steps stack vertically Default state: Shows <code>not True or False and True</code> ready to step through</p> <p>Instructional Rationale: Step-through tracing is ideal for the Analyze level because students must decompose complex expressions into sub-expressions and track the order in which they're evaluated. The visual replacement animation makes the abstract evaluation process concrete and sequential. Color-coding by operator type reinforces the priority hierarchy.</p>"},{"location":"chapters/03-boolean-logic/#de-morgans-laws-the-logic-flip","title":"De Morgan's Laws: The Logic Flip","text":"<p>Now for one of the coolest (and most useful) rules in Boolean logic: De Morgan's Laws. Named after mathematician Augustus De Morgan, these laws tell you how to \"flip\" an expression involving <code>and</code>, <code>or</code>, and <code>not</code>.</p> <p>De Morgan's Laws state:</p> <ul> <li>Law 1: <code>not (A and B)</code> is the same as <code>(not A) or (not B)</code></li> <li>Law 2: <code>not (A or B)</code> is the same as <code>(not A) and (not B)</code></li> </ul> <p>In plain English:</p> <ul> <li>\"It's NOT the case that both A and B are true\" = \"Either A is false, or B is false (or both)\"</li> <li>\"It's NOT the case that A or B is true\" = \"Both A and B are false\"</li> </ul> <p>Here's a real-world example. Say you're checking if someone is not eligible for a discount. The discount requires being a student and being under 25:</p> <pre><code># These two expressions are equivalent:\nnot (is_student and age &lt; 25)\n(not is_student) or (age &gt;= 25)\n</code></pre> <p>Let's prove De Morgan's Laws with truth tables:</p> <p>Law 1: <code>not (A and B)</code> vs. <code>(not A) or (not B)</code></p> A B A and B not (A and B) not A not B (not A) or (not B) T T T F F F F T F F T F T T F T F T T F T F F F T T T T <p>The <code>not (A and B)</code> column and the <code>(not A) or (not B)</code> column are identical. The law holds!</p> <p>Law 2: <code>not (A or B)</code> vs. <code>(not A) and (not B)</code></p> A B A or B not (A or B) not A not B (not A) and (not B) T T T F F F F T F T F F T F F T T F T F F F F F T T T T <p>Again, the columns match perfectly.</p> <p>Monty says: You've got this!</p> <p> De Morgan's Laws might seem abstract right now, but they're incredibly practical. When you start writing <code>if</code> statements with complex conditions, you'll often need to flip the logic. De Morgan's Laws tell you exactly how to do that without making mistakes. Stick with it \u2014 this knowledge will pay off big time!</p> <p>Here's a quick-reference cheat sheet for De Morgan's Laws:</p> Original Equivalent (De Morgan) <code>not (A and B)</code> <code>(not A) or (not B)</code> <code>not (A or B)</code> <code>(not A) and (not B)</code> <p>The pattern: when you push <code>not</code> through parentheses, <code>and</code> becomes <code>or</code>, and <code>or</code> becomes <code>and</code>. Everything flips!</p>"},{"location":"chapters/03-boolean-logic/#diagram-de-morgans-laws-visualizer","title":"Diagram: De Morgan's Laws Visualizer","text":"De Morgan's Laws Interactive Visualizer <p>Type: microsim sim-id: demorgans-laws Library: p5.js Status: Specified</p> <p>Bloom Level: Analyze (L4) Bloom Verb: prove, transform</p> <p>Learning Objective: Students will be able to apply De Morgan's Laws to transform Boolean expressions and verify equivalence using side-by-side truth tables.</p> <p>Purpose: An interactive demonstration that lets students see De Morgan's Laws in action by toggling values of A and B and watching both the original and transformed expressions evaluate simultaneously.</p> <p>Layout: - Top: Title \"De Morgan's Laws Visualizer\" - Left panel: Law 1 \u2014 shows <code>not (A and B)</code> and <code>(not A) or (not B)</code> side by side - Right panel: Law 2 \u2014 shows <code>not (A or B)</code> and <code>(not A) and (not B)</code> side by side - Center: Toggle switches for A and B values - Bottom: Auto-generated truth tables for both laws</p> <p>Interactive controls: - Toggle switch for A (True/False) - Toggle switch for B (True/False) - As A and B change, both expressions in each law evaluate in real-time - Matching results glow green to show equivalence - \"Show Truth Table\" button reveals the full 4-row truth table for each law - \"Apply to Custom Expression\" input: enter an expression like <code>not (X and Y)</code> and see its De Morgan equivalent</p> <p>Visual elements: - Each expression shown in a large, code-styled display - The <code>not</code> operator shown as a bar over the expression (mathematical notation) alongside the Python notation - Color-coded: original in blue, De Morgan equivalent in orange - When both expressions match (always), a \"EQUIVALENT\" badge animates between them - Arrows show the transformation: <code>and</code> flipping to <code>or</code> (and vice versa) with animation</p> <p>Color scheme: Blue for original expressions, orange for transformed, green for matching results Responsive: Panels stack vertically on narrow screens</p> <p>Instructional Rationale: Real-time evaluation with toggleable inputs lets students build intuition about the laws before memorizing them. Seeing both expressions update simultaneously provides immediate proof of equivalence. The visual transformation (and/or flip animation) makes the structural change memorable. This supports the Analyze level by requiring students to both observe and apply the transformation pattern.</p>"},{"location":"chapters/03-boolean-logic/#putting-it-all-together","title":"Putting It All Together","text":"<p>Let's combine everything you've learned in a real-world example. Imagine you're building a simple password checker. The password is valid if:</p> <ol> <li>It's at least 8 characters long</li> <li>It's not the same as the username</li> <li>It contains at least one digit (we'll simplify this check)</li> </ol> <pre><code>username = \"gamer42\"\npassword = \"Py3thon!\"\n\n# Check all conditions\nlong_enough = len(password) &gt;= 8\nnot_same = password != username\nhas_digit = any(char.isdigit() for char in password)\n\n# Combine with 'and'\nis_valid = long_enough and not_same and has_digit\nprint(is_valid)  # True\n</code></pre> <p>This example uses comparison operators (<code>&gt;=</code>, <code>!=</code>), the <code>and</code> operator, truthiness (the <code>any()</code> function returns a Boolean), and even short-circuit evaluation (if <code>long_enough</code> is <code>False</code>, Python won't bother checking the other conditions).</p> <p>Let's trace through the logic:</p> <ul> <li><code>len(\"Py3thon!\")</code> is 8, and <code>8 &gt;= 8</code> is <code>True</code></li> <li><code>\"Py3thon!\" != \"gamer42\"</code> is <code>True</code></li> <li><code>\"Py3thon!\"</code> contains <code>\"3\"</code>, so <code>has_digit</code> is <code>True</code></li> <li><code>True and True and True</code> evaluates to <code>True</code></li> </ul> <p>The password passes! Boolean logic in action.</p> <p>Monty says: You've got this!</p> <p> Outstanding work, coder! You've just mastered the foundation of all decision-making in programming. Every <code>if</code> statement, every loop condition, every search filter \u2014 they all rely on the Boolean logic you learned in this chapter. In the next chapter, we'll put these skills to work with conditional statements. Get ready to make your programs think!</p>"},{"location":"chapters/03-boolean-logic/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>A Boolean expression evaluates to either <code>True</code> or <code>False</code> \u2014 there's no in-between.</li> <li>Python's six comparison operators (<code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>) compare values and return Booleans.</li> <li>The equal operator is <code>==</code> (double equals); the assignment operator is <code>=</code> (single equals). Don't mix them up!</li> <li>Logical operators combine Boolean expressions: <code>and</code> (both must be true), <code>or</code> (at least one must be true), <code>not</code> (flips the value).</li> <li>Truth tables show every possible combination of inputs and outputs for a logical expression.</li> <li>Short-circuit evaluation means Python stops evaluating as soon as it knows the result \u2014 <code>False and ...</code> stops immediately, as does <code>True or ...</code>.</li> <li>Truthiness and falsiness: Zero, empty containers, empty strings, and <code>None</code> are falsy. Everything else is truthy.</li> <li>Boolean conversion with <code>bool()</code> explicitly converts any value to <code>True</code> or <code>False</code>.</li> <li>Chained comparisons like <code>0 &lt;= x &lt;= 100</code> are a Pythonic shortcut for <code>0 &lt;= x and x &lt;= 100</code>.</li> <li>Order of operations: <code>not</code> before <code>and</code> before <code>or</code>. When in doubt, use parentheses!</li> <li>De Morgan's Laws: <code>not (A and B)</code> equals <code>(not A) or (not B)</code>, and <code>not (A or B)</code> equals <code>(not A) and (not B)</code>.</li> </ul> Check Your Understanding: What does <code>not (True and False)</code> evaluate to? <p>Let's work through it step by step:</p> <ol> <li>First, evaluate the inner expression: <code>True and False</code> = <code>False</code></li> <li>Then apply <code>not</code>: <code>not False</code> = <code>True</code></li> </ol> <p>The answer is <code>True</code>. You can also verify this with De Morgan's Law: <code>not (True and False)</code> = <code>(not True) or (not False)</code> = <code>False or True</code> = <code>True</code>. Same answer!</p> Check Your Understanding: Is the string <code>'0'</code> truthy or falsy in Python? <p>It's truthy! Even though the string contains the character \"0\", it's a non-empty string, and all non-empty strings are truthy. Remember, <code>bool(\"0\")</code> returns <code>True</code>. Only the empty string <code>\"\"</code> is falsy.</p> Check Your Understanding: Use De Morgan's Law to rewrite <code>not (x &gt; 5 or y == 0)</code>. <p>Applying De Morgan's second law (<code>not (A or B)</code> = <code>(not A) and (not B)</code>):</p> <p><code>not (x &gt; 5 or y == 0)</code> becomes <code>(not (x &gt; 5)) and (not (y == 0))</code></p> <p>Which simplifies to: <code>x &lt;= 5 and y != 0</code></p> <p>We flipped <code>&gt;</code> to <code>&lt;=</code> and <code>==</code> to <code>!=</code>, and changed <code>or</code> to <code>and</code>. De Morgan's Laws in action!</p>"},{"location":"chapters/04-control-flow/","title":"Control Flow","text":""},{"location":"chapters/04-control-flow/#control-flow","title":"Control Flow","text":""},{"location":"chapters/04-control-flow/#summary","title":"Summary","text":"<p>This chapter covers the mechanisms that control the order of program execution. Students will learn conditional statements (if, elif, else), for and while loops, break and continue statements, and nested control structures. The chapter introduces common iteration patterns including the accumulator, counter, sentinel value, and flag variable patterns that are essential for solving real programming problems.</p>"},{"location":"chapters/04-control-flow/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 25 concepts from the learning graph:</p> <ol> <li>Control Flow</li> <li>Sequential Execution</li> <li>Conditional Statements</li> <li>If Statement</li> <li>If-Else Statement</li> <li>Elif Statement</li> <li>Nested Conditionals</li> <li>Ternary Expression</li> <li>Match Statement</li> <li>Loops</li> <li>For Loop</li> <li>While Loop</li> <li>Range Function</li> <li>Loop Variable</li> <li>Loop Body</li> <li>Infinite Loops</li> <li>Break Statement</li> <li>Continue Statement</li> <li>Nested Loops</li> <li>Loop Patterns</li> <li>Accumulator Pattern</li> <li>Counter Pattern</li> <li>Sentinel Value Pattern</li> <li>Flag Variable Pattern</li> <li>Loop Else Clause</li> </ol>"},{"location":"chapters/04-control-flow/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 2: Python Fundamentals</li> <li>Chapter 3: Boolean Logic and Comparisons</li> </ul> <p>Monty says: Let's code this!</p> <p> Welcome back, coders! So far you've learned how to store data in variables, do math, and compare values with Boolean expressions. But all of our programs have been straight-line \u2014 they just run one instruction after another from top to bottom. That's about to change. In this chapter, you'll learn how to make your programs think, choose, and repeat. Get ready \u2014 this is where programming gets really fun!</p>"},{"location":"chapters/04-control-flow/#what-is-control-flow","title":"What Is Control Flow?","text":"<p>Control flow is the order in which a computer executes statements in a program. Think about it like a GPS giving you driving directions. Sometimes you drive straight ahead. Sometimes you turn left or right. Sometimes you loop around a roundabout. Control flow is the GPS of your program \u2014 it decides which instructions to run and in what order.</p> <p>There are three fundamental patterns of control flow:</p> Pattern What It Does Real-Life Analogy Sequential Run statements one after another, top to bottom Reading a book page by page Selection Choose which statements to run based on a condition A \"Choose Your Own Adventure\" book Iteration Repeat statements multiple times Listening to your favorite song on repeat <p>Every program you'll ever write \u2014 from a simple calculator to a massive video game \u2014 uses some combination of these three patterns. Let's explore each one.</p>"},{"location":"chapters/04-control-flow/#sequential-execution","title":"Sequential Execution","text":"<p>Sequential execution is the simplest form of control flow. The computer runs your statements in order, one after another, from the first line to the last. This is Python's default behavior.</p> <pre><code>name = \"Alex\"\nage = 16\nprint(\"Hello, \" + name)\nprint(\"You are \" + str(age) + \" years old\")\n</code></pre> <p>Python runs line 1, then line 2, then line 3, then line 4. No surprises, no detours. It's like following a recipe step by step \u2014 first crack the eggs, then add the flour, then mix. You wouldn't frost a cake before baking it (well, you could try, but it wouldn't go well).</p> <p>Sequential execution is fine for simple tasks, but real programs need to make decisions and repeat actions. That's where conditionals and loops come in.</p>"},{"location":"chapters/04-control-flow/#diagram-control-flow-patterns","title":"Diagram: Control Flow Patterns","text":"Control Flow Patterns Flowchart <p>Type: diagram sim-id: control-flow-patterns Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: compare, classify</p> <p>Learning Objective: Students will be able to identify and distinguish the three fundamental control flow patterns (sequential, selection, iteration) and trace the path of execution through each.</p> <p>Purpose: An interactive flowchart showing the three patterns of control flow side by side. Students can click on each pattern to see an animated trace of how execution flows through it.</p> <p>Layout: - Three columns, each showing one control flow pattern - Left column: Sequential (straight arrow down through 3 boxes) - Middle column: Selection (diamond decision node branching left/right to different boxes, then merging) - Right column: Iteration (box with arrow looping back to a diamond decision node) - Each pattern has a label and a brief description below</p> <p>Interactive elements: - Click any pattern to animate a glowing dot tracing the execution path - Hover over nodes (rectangles for statements, diamonds for decisions) to see descriptions - A \"Show All\" button animates all three simultaneously for comparison - Toggle to show/hide Python code snippets that correspond to each pattern</p> <p>Visual style: Clean flowchart with rounded rectangles for statements, diamond shapes for conditions, directional arrows Color scheme: Sequential (blue), Selection (green), Iteration (orange), animated dot in bright yellow Responsive: Three columns stack vertically on narrow screens</p> <p>Instructional Rationale: Side-by-side comparison supports the Understand/compare objective. Animated execution traces make the abstract concept of \"flow\" concrete and visible. Toggle between flowchart and code helps students connect visual models to Python syntax.</p>"},{"location":"chapters/04-control-flow/#conditional-statements-making-decisions","title":"Conditional Statements: Making Decisions","text":"<p>Imagine you're at a vending machine. You put in your money, and then you have to make a choice: which snack do you want? Press A1 for chips, B2 for a candy bar, C3 for a granola bar. Your selection determines what comes out. That's exactly what conditional statements do in Python \u2014 they let your program choose different paths based on a condition.</p> <p>Conditional statements check whether something is <code>True</code> or <code>False</code> (remember Boolean values from Chapter 3?) and then decide which code to run.</p>"},{"location":"chapters/04-control-flow/#the-if-statement","title":"The If Statement","text":"<p>The if statement is the simplest conditional. It checks a condition, and if that condition is <code>True</code>, it runs a block of code. If the condition is <code>False</code>, it skips that block entirely.</p> <pre><code>temperature = 95\n\nif temperature &gt; 90:\n    print(\"It's really hot outside!\")\n    print(\"Don't forget your water bottle!\")\n</code></pre> <p>Here's what happens:</p> <ol> <li>Python evaluates <code>temperature &gt; 90</code> \u2014 that's <code>95 &gt; 90</code>, which is <code>True</code></li> <li>Since the condition is <code>True</code>, Python runs the indented code block</li> <li>Both <code>print</code> statements execute</li> </ol> <p>If <code>temperature</code> were <code>75</code>, the condition would be <code>False</code>, and Python would skip right past those two lines. Nothing would print.</p> <p>Notice the structure:</p> <ul> <li>The <code>if</code> keyword, followed by a condition, followed by a colon <code>:</code></li> <li>The code that runs when the condition is <code>True</code> is indented (usually 4 spaces)</li> <li>Everything at the same indentation level belongs to the if block</li> </ul>"},{"location":"chapters/04-control-flow/#the-if-else-statement","title":"The If-Else Statement","text":"<p>What if you want your program to do one thing when a condition is <code>True</code> and a different thing when it's <code>False</code>? That's where the if-else statement comes in.</p> <pre><code>age = 15\n\nif age &gt;= 16:\n    print(\"You can get your driver's license!\")\nelse:\n    print(\"Not old enough to drive yet.\")\n    print(\"But you'll get there soon!\")\n</code></pre> <p>The <code>else</code> clause acts as a safety net \u2014 it catches everything that doesn't match the <code>if</code> condition. It's like a fork in the road: you must go one way or the other. There's no standing in the middle.</p>"},{"location":"chapters/04-control-flow/#the-elif-statement","title":"The Elif Statement","text":"<p>But what if you have more than two options? You don't just want \"hot\" or \"not hot\" \u2014 you want \"hot,\" \"warm,\" \"cool,\" and \"cold.\" That's what the elif statement (short for \"else if\") handles.</p> <pre><code>score = 85\n\nif score &gt;= 90:\n    grade = \"A\"\nelif score &gt;= 80:\n    grade = \"B\"\nelif score &gt;= 70:\n    grade = \"C\"\nelif score &gt;= 60:\n    grade = \"D\"\nelse:\n    grade = \"F\"\n\nprint(\"Your grade is: \" + grade)\n</code></pre> <p>Python checks each condition from top to bottom. The first one that's <code>True</code> wins, and the rest are skipped. With a score of 85:</p> <ol> <li>Is <code>85 &gt;= 90</code>? No. Move on.</li> <li>Is <code>85 &gt;= 80</code>? Yes! Set <code>grade = \"B\"</code> and skip everything else.</li> </ol> <p>This is important: order matters with elif chains. Python takes the first match and ignores the rest. Put your most restrictive conditions first.</p> <p>Monty says: You've got this!</p> <p> Think of an if-elif-else chain like a bouncer at a club checking IDs. The bouncer checks one condition at a time: \"Are you on the VIP list? No? Are you 21 or older? No? Are you with someone who is? No? Sorry, you're not getting in.\" The first condition that matches determines what happens.</p>"},{"location":"chapters/04-control-flow/#diagram-if-elif-else-flowchart","title":"Diagram: If-Elif-Else Flowchart","text":"If-Elif-Else Flowchart MicroSim <p>Type: microsim sim-id: if-elif-else-flowchart Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: trace, predict</p> <p>Learning Objective: Students will be able to trace the execution path through an if-elif-else chain by entering a test value and observing which branch is taken.</p> <p>Purpose: An interactive flowchart of the grading example above. Students enter a numeric score, and the flowchart animates the path through the decision nodes, highlighting which branch is taken and what grade is assigned.</p> <p>Layout: - Top: Input field for score (0-100) with a \"Trace\" button - Below: Vertical flowchart with diamond decision nodes for each condition - First diamond: \"score &gt;= 90?\" with Yes branch going to \"A\" box, No branch going down - Second diamond: \"score &gt;= 80?\" with Yes to \"B\", No down - Third diamond: \"score &gt;= 70?\" with Yes to \"C\", No down - Fourth diamond: \"score &gt;= 60?\" with Yes to \"D\", No to \"F\" - All grade boxes connect to a final \"Print grade\" box at the bottom</p> <p>Interactive elements: - Type a score and click \"Trace\" to animate a dot flowing through the flowchart - Each diamond glows green (True) or red (False) as the dot passes through - The winning grade box pulses and displays the result - A \"Step\" button lets students advance one decision at a time - The corresponding Python code is shown on the right, with the current line highlighted</p> <p>Visual style: Standard flowchart shapes \u2014 diamonds for decisions, rectangles for actions Color scheme: True paths in green, False paths in red, active node in yellow Responsive: Flowchart scales to fit; code panel collapses below on narrow screens</p> <p>Instructional Rationale: Tracing with a concrete input value supports the Apply level. Students predict which branch will be taken and then verify by watching the animation. Pairing the flowchart with highlighted source code builds the connection between visual logic and Python syntax.</p>"},{"location":"chapters/04-control-flow/#nested-conditionals","title":"Nested Conditionals","text":"<p>Sometimes one decision depends on another. You might first check if it's a weekday, and then check if you have homework. Placing an if statement inside another if statement is called using nested conditionals.</p> <pre><code>is_weekend = False\nhas_homework = True\n\nif is_weekend:\n    print(\"It's the weekend!\")\n    if has_homework:\n        print(\"But you should probably do your homework first...\")\n    else:\n        print(\"Enjoy your free time!\")\nelse:\n    print(\"It's a school day.\")\n    if has_homework:\n        print(\"Time to hit the books!\")\n</code></pre> <p>Nesting works, but be careful \u2014 too many levels of nesting make your code hard to read. As a rule of thumb, if you're more than 3 levels deep, there's probably a cleaner way to write it (often using <code>and</code>/<code>or</code> to combine conditions).</p>"},{"location":"chapters/04-control-flow/#ternary-expression","title":"Ternary Expression","text":"<p>Sometimes you just need a quick one-liner to pick between two values. Python's ternary expression (also called a conditional expression) lets you do an if-else in a single line:</p> <pre><code>age = 15\nstatus = \"can drive\" if age &gt;= 16 else \"too young\"\nprint(status)  # Output: too young\n</code></pre> <p>The pattern is: <code>value_if_true if condition else value_if_false</code></p> <p>It reads almost like English: \"status is 'can drive' if age is at least 16, else 'too young'.\" Use ternary expressions for simple choices. For anything complicated, stick with regular if-else blocks \u2014 readability always wins.</p>"},{"location":"chapters/04-control-flow/#match-statement","title":"Match Statement","text":"<p>Python 3.10 introduced the match statement, which is great for checking a single value against multiple specific options. It's similar to a \"switch\" statement in other languages.</p> <pre><code>day = \"Monday\"\n\nmatch day:\n    case \"Monday\":\n        print(\"Start of the school week!\")\n    case \"Friday\":\n        print(\"Almost the weekend!\")\n    case \"Saturday\" | \"Sunday\":\n        print(\"Weekend vibes!\")\n    case _:\n        print(\"Just another school day.\")\n</code></pre> <p>The <code>_</code> at the end is a wildcard \u2014 it matches anything that didn't match the earlier cases, like the <code>else</code> in an if-elif chain. The <code>|</code> symbol means \"or,\" so <code>\"Saturday\" | \"Sunday\"</code> matches either one.</p> <p>Match statements are cleanest when you're comparing one value against a list of known options \u2014 like menu choices, days of the week, or game commands.</p>"},{"location":"chapters/04-control-flow/#loops-doing-things-over-and-over","title":"Loops: Doing Things Over and Over","text":"<p>Imagine you had to write a program that prints \"Hello!\" one hundred times. Without loops, you'd need 100 <code>print</code> statements. That's not programming \u2014 that's punishment. Loops let you repeat a block of code multiple times without copying and pasting it.</p> <p>There are two main types of loops in Python:</p> <ul> <li>For loops \u2014 when you know how many times to repeat (or you're iterating over a collection)</li> <li>While loops \u2014 when you want to keep going until a condition changes</li> </ul>"},{"location":"chapters/04-control-flow/#the-for-loop","title":"The For Loop","text":"<p>A for loop repeats a block of code once for each item in a sequence (like a list, a string, or a range of numbers).</p> <pre><code>fruits = [\"apple\", \"banana\", \"cherry\"]\n\nfor fruit in fruits:\n    print(\"I like \" + fruit)\n</code></pre> <p>Output:</p> <pre><code>I like apple\nI like banana\nI like cherry\n</code></pre> <p>Here's how it works:</p> <ol> <li>Python picks the first item from the list (<code>\"apple\"</code>) and stores it in the variable <code>fruit</code></li> <li>It runs the indented code block (the loop body)</li> <li>It goes back to the top, picks the next item (<code>\"banana\"</code>), and runs the loop body again</li> <li>This continues until every item has been processed</li> </ol> <p>The variable <code>fruit</code> in this example is called the loop variable \u2014 it takes on a different value each time through the loop. The indented code below the <code>for</code> line is the loop body \u2014 the code that gets repeated.</p>"},{"location":"chapters/04-control-flow/#the-range-function","title":"The Range Function","text":"<p>What if you want to repeat something a specific number of times? The range function generates a sequence of numbers that you can loop over.</p> <pre><code>for i in range(5):\n    print(\"Count: \" + str(i))\n</code></pre> <p>Output:</p> <pre><code>Count: 0\nCount: 1\nCount: 2\nCount: 3\nCount: 4\n</code></pre> <p>Notice that <code>range(5)</code> gives you numbers 0 through 4 \u2014 that's 5 numbers total, but it starts at 0, not 1. This is one of Python's quirks that trips up beginners. (Why start at 0? It's a long tradition in computer science that has to do with memory addresses. You'll get used to it!)</p> <p>The <code>range</code> function has three forms:</p> Form Meaning Example Numbers Generated <code>range(stop)</code> 0 to stop-1 <code>range(5)</code> 0, 1, 2, 3, 4 <code>range(start, stop)</code> start to stop-1 <code>range(2, 7)</code> 2, 3, 4, 5, 6 <code>range(start, stop, step)</code> start to stop-1, skipping by step <code>range(0, 10, 2)</code> 0, 2, 4, 6, 8 <p>You can even count backward:</p> <pre><code>for i in range(5, 0, -1):\n    print(i)\n# Output: 5, 4, 3, 2, 1 (like a rocket countdown!)\n</code></pre> <p>Monty says: Let's debug this together!</p> <p> A common mistake is writing <code>range(1, 5)</code> and expecting to get 1, 2, 3, 4, 5. But remember: the stop value is exclusive \u2014 it's not included. If you want 1 through 5, use <code>range(1, 6)</code>. The rule is: range goes up to but not including the stop value.</p>"},{"location":"chapters/04-control-flow/#diagram-range-function-explorer","title":"Diagram: Range Function Explorer","text":"Range Function Explorer MicroSim <p>Type: microsim sim-id: range-function-explorer Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: experiment, predict</p> <p>Learning Objective: Students will be able to predict the output of the range() function with various start, stop, and step arguments by adjusting sliders and observing the generated sequence.</p> <p>Purpose: An interactive tool where students adjust the start, stop, and step parameters of range() and immediately see the resulting sequence of numbers displayed visually.</p> <p>Layout: - Top: Three labeled sliders \u2014 Start (range -10 to 20, default 0), Stop (range -10 to 20, default 5), Step (range -5 to 5, default 1, excluding 0) - Middle: A number line from -10 to 20 with dots/circles at each integer - Below the number line: The generated numbers highlighted with colored dots and labeled - Bottom: The Python code shown dynamically, e.g., <code>range(0, 5, 1)</code> and the resulting list <code>[0, 1, 2, 3, 4]</code></p> <p>Interactive elements: - Drag any slider to change the parameter in real time - The number line updates instantly, highlighting the generated values - The Python code and list output update automatically - A \"Challenge\" button gives the student a target sequence (e.g., \"Generate: 2, 5, 8, 11\") and they adjust sliders to match - Show a warning message if step is 0 (infinite loop) or if the range produces no values</p> <p>Visual style: Clean number line with colored highlight dots, sliders below each label Color scheme: Active numbers in green, inactive in light gray, slider handles in blue Responsive: Canvas width adjusts; sliders stack if too narrow</p> <p>Instructional Rationale: Direct manipulation of parameters supports the Apply level. Immediate visual feedback on a number line builds intuition for how start, stop, and step interact. The challenge mode adds goal-directed practice.</p>"},{"location":"chapters/04-control-flow/#the-while-loop","title":"The While Loop","text":"<p>A while loop keeps running as long as a condition is <code>True</code>. Unlike a for loop, you don't necessarily know in advance how many times it will repeat.</p> <pre><code>password = \"\"\n\nwhile password != \"python123\":\n    password = input(\"Enter the password: \")\n\nprint(\"Access granted!\")\n</code></pre> <p>This loop keeps asking for a password until the user types the correct one. It could run once (if they get it right the first time) or a hundred times (if they keep guessing wrong).</p> <p>The while loop structure:</p> <ol> <li>Check the condition \u2014 is it <code>True</code>?</li> <li>If <code>True</code>, run the loop body</li> <li>Go back to step 1</li> <li>If <code>False</code>, skip the loop body and continue with the rest of the program</li> </ol>"},{"location":"chapters/04-control-flow/#infinite-loops","title":"Infinite Loops","text":"<p>Here's something to watch out for: if the condition in a while loop never becomes <code>False</code>, the loop runs forever. This is called an infinite loop, and it's one of the most common bugs in programming.</p> <pre><code># WARNING: This loop never ends!\nx = 1\nwhile x &gt; 0:\n    print(x)\n    x = x + 1\n</code></pre> <p>Since <code>x</code> starts at 1 and keeps increasing, <code>x &gt; 0</code> is always <code>True</code>. Your program will print numbers forever (or until you force it to stop with Ctrl+C).</p> <p>Sometimes infinite loops are intentional \u2014 for example, a game's main loop that keeps running until the player quits. But accidental infinite loops are a headache. Always make sure your while loop condition will eventually become <code>False</code>.</p> <p>Monty says: Watch out!</p> <p> If your program seems \"frozen\" or stuck, you might have an infinite loop! Press Ctrl+C (or Cmd+C on Mac) to stop the program. Then check your while loop: is the condition ever becoming False? Make sure something inside the loop is changing a variable that affects the condition.</p>"},{"location":"chapters/04-control-flow/#break-statement","title":"Break Statement","text":"<p>The break statement is like an emergency exit. When Python hits <code>break</code> inside a loop, it immediately jumps out of the loop \u2014 no questions asked.</p> <pre><code>for num in range(1, 100):\n    if num == 7:\n        print(\"Found it!\")\n        break\n    print(\"Checking \" + str(num))\n</code></pre> <p>Output:</p> <pre><code>Checking 1\nChecking 2\nChecking 3\nChecking 4\nChecking 5\nChecking 6\nFound it!\n</code></pre> <p>Without <code>break</code>, this loop would check all 99 numbers. With <code>break</code>, it stops as soon as it finds 7. Efficient!</p>"},{"location":"chapters/04-control-flow/#continue-statement","title":"Continue Statement","text":"<p>The continue statement is the opposite of <code>break</code>. Instead of exiting the loop, it skips the rest of the current iteration and jumps to the next one.</p> <pre><code>for i in range(1, 6):\n    if i == 3:\n        continue\n    print(i)\n</code></pre> <p>Output:</p> <pre><code>1\n2\n4\n5\n</code></pre> <p>When <code>i</code> is 3, <code>continue</code> tells Python \"skip the print and go to the next number.\" It's useful for filtering \u2014 running the loop body only for items that meet certain criteria.</p> <p>Here's a comparison to keep them straight:</p> Statement What It Does Analogy <code>break</code> Exit the loop entirely Walking out of the movie theater <code>continue</code> Skip to the next iteration Fast-forwarding past a boring scene"},{"location":"chapters/04-control-flow/#diagram-break-vs-continue-visualizer","title":"Diagram: Break vs Continue Visualizer","text":"Break vs Continue Visualizer MicroSim <p>Type: microsim sim-id: break-vs-continue Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: compare, trace</p> <p>Learning Objective: Students will be able to distinguish between break and continue by tracing the execution of loops that use each statement and predicting the output.</p> <p>Purpose: A side-by-side animation showing two identical loops \u2014 one using break and one using continue \u2014 so students can visually compare how each statement affects the loop's execution.</p> <p>Layout: - Split screen: left side \"Loop with break\", right side \"Loop with continue\" - Each side shows a for loop iterating through numbers 1-5 with a condition check at number 3 - Animated execution dot traces through each loop - An output console at the bottom of each side shows what gets printed</p> <p>Interactive elements: - \"Step\" button advances both loops one step simultaneously - \"Auto Play\" button animates with adjustable speed - \"Reset\" button restarts both loops - Students can change the \"trigger number\" (the number that activates break/continue) via a dropdown</p> <p>Visual elements: - Loop iterations shown as boxes in a row (1, 2, 3, 4, 5) - Current iteration highlighted in yellow - Break side: when trigger is reached, remaining boxes turn gray (skipped) - Continue side: only the trigger box turns gray, rest continue normally - Output consoles show printed values accumulating</p> <p>Color scheme: Active iteration in yellow, completed in green, skipped/break in red, continue-skipped in orange Responsive: Side-by-side on wide screens, stacked vertically on narrow</p> <p>Instructional Rationale: Side-by-side comparison with identical input makes the behavioral difference immediately obvious. Step-by-step execution supports careful tracing. Changing the trigger number lets students verify their understanding with different scenarios.</p>"},{"location":"chapters/04-control-flow/#nested-loops","title":"Nested Loops","text":"<p>A nested loop is a loop inside another loop. The inner loop runs completely for each iteration of the outer loop. This is like a clock: the minute hand goes around 60 times for every single revolution of the hour hand.</p> <pre><code>for row in range(1, 4):\n    for col in range(1, 4):\n        print(f\"({row},{col})\", end=\" \")\n    print()  # New line after each row\n</code></pre> <p>Output:</p> <pre><code>(1,1) (1,2) (1,3)\n(2,1) (2,2) (2,3)\n(3,1) (3,2) (3,3)\n</code></pre> <p>The outer loop runs 3 times (rows 1, 2, 3). For each row, the inner loop runs 3 times (columns 1, 2, 3). That's 3 x 3 = 9 total iterations. Nested loops are commonly used for working with grids, tables, and two-dimensional data.</p> <p>Here's a classic example \u2014 printing a multiplication table:</p> <pre><code>for i in range(1, 6):\n    for j in range(1, 6):\n        print(f\"{i*j:4}\", end=\"\")\n    print()\n</code></pre> <p>Output:</p> <pre><code>   1   2   3   4   5\n   2   4   6   8  10\n   3   6   9  12  15\n   4   8  12  16  20\n   5  10  15  20  25\n</code></pre>"},{"location":"chapters/04-control-flow/#diagram-nested-loop-grid-visualizer","title":"Diagram: Nested Loop Grid Visualizer","text":"Nested Loop Grid Visualizer MicroSim <p>Type: microsim sim-id: nested-loop-grid Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: trace, predict</p> <p>Learning Objective: Students will be able to trace the execution order of nested loops by watching a cell-by-cell animation across a grid and predicting which cell is filled next.</p> <p>Purpose: An animated grid that fills in cell by cell to show the execution order of a nested for loop. Students see the outer loop variable (row) and inner loop variable (column) update in real time.</p> <p>Layout: - Top: Current values display \u2014 \"row = ?, col = ?, iteration = ?\" - Center: An N x N grid (default 4x4) with row and column labels - Right side: The Python code with the current line highlighted - Bottom: Controls</p> <p>Interactive elements: - Grid size slider (2x2 to 6x6) - \"Step\" button to advance one cell at a time - \"Auto Play\" button with speed control - \"Reset\" button - Click any cell to see its (row, col) coordinates and iteration number</p> <p>Visual elements: - Cells fill in order: left to right across each row, then down to the next row - Current cell glows brightly - Already-filled cells show their iteration number - Row label highlights on the left when that row is active - Column label highlights on top when that column is active - Python code on the right highlights the inner or outer loop line as appropriate</p> <p>Color scheme: Current cell in bright yellow, filled cells in gradient from light to dark blue (showing order), unfilled in white Responsive: Grid scales proportionally; code panel collapses below on narrow screens</p> <p>Instructional Rationale: Step-by-step cell filling makes the nested execution order concrete. Seeing the loop variables update alongside the grid builds understanding of which variable changes \"fast\" (inner) and which changes \"slow\" (outer). Adjustable grid size lets students verify their mental model at different scales.</p>"},{"location":"chapters/04-control-flow/#loop-else-clause","title":"Loop Else Clause","text":"<p>Here's a Python feature that surprises even experienced programmers: you can put an <code>else</code> block on a loop. The loop else clause runs when the loop finishes normally (without hitting a <code>break</code>).</p> <pre><code>numbers = [2, 4, 6, 8]\n\nfor num in numbers:\n    if num % 2 != 0:\n        print(f\"Found an odd number: {num}\")\n        break\nelse:\n    print(\"All numbers are even!\")\n</code></pre> <p>Output: <code>All numbers are even!</code></p> <p>Since no odd number was found, the loop never hit <code>break</code>, so the <code>else</code> block ran. If the list contained a 5, the <code>break</code> would trigger and the <code>else</code> would be skipped.</p> <p>A helpful way to read this: \"for each item... do this... else (if we got through everything without breaking)... do that.\" Some people find it easier to think of it as \"for...no-break.\"</p>"},{"location":"chapters/04-control-flow/#common-loop-patterns","title":"Common Loop Patterns","text":"<p>Now that you know the mechanics of loops, let's look at some loop patterns \u2014 tried-and-true templates that show up over and over in real programs. Learning these patterns is like learning chess openings: once you recognize them, you can solve problems much faster.</p>"},{"location":"chapters/04-control-flow/#the-accumulator-pattern","title":"The Accumulator Pattern","text":"<p>The accumulator pattern is used when you want to build up a result (a total, a string, a list) as you loop through data. You start with an initial value, and each time through the loop, you add to it.</p> <pre><code># Sum all numbers from 1 to 100\ntotal = 0  # accumulator variable, initialized to 0\n\nfor num in range(1, 101):\n    total = total + num\n\nprint(\"The sum is:\", total)  # Output: The sum is: 5050\n</code></pre> <p>The formula is:</p> <ol> <li>Initialize the accumulator before the loop (<code>total = 0</code>)</li> <li>Update the accumulator inside the loop (<code>total = total + num</code>)</li> <li>Use the accumulator after the loop (<code>print(total)</code>)</li> </ol> <p>The accumulator doesn't have to be a number. You can accumulate a string:</p> <pre><code># Build a string of initials\nnames = [\"Alice\", \"Bob\", \"Charlie\"]\ninitials = \"\"\n\nfor name in names:\n    initials = initials + name[0]\n\nprint(initials)  # Output: ABC\n</code></pre>"},{"location":"chapters/04-control-flow/#the-counter-pattern","title":"The Counter Pattern","text":"<p>The counter pattern is a special case of the accumulator where you're counting how many items meet a certain condition.</p> <pre><code># Count how many scores are above 80\nscores = [72, 95, 88, 61, 79, 93, 85]\nhigh_scores = 0  # counter variable\n\nfor score in scores:\n    if score &gt; 80:\n        high_scores = high_scores + 1\n\nprint(\"Number of high scores:\", high_scores)  # Output: 3\n</code></pre> <p>The key difference from a plain accumulator: you add 1 only when a condition is met. This is incredibly useful \u2014 counting vowels in a string, counting even numbers in a list, counting how many students passed a test.</p>"},{"location":"chapters/04-control-flow/#the-sentinel-value-pattern","title":"The Sentinel Value Pattern","text":"<p>The sentinel value pattern uses a special value (the \"sentinel\") to signal that the loop should stop. Instead of knowing the number of iterations in advance, you keep looping until you see the magic stop value.</p> <pre><code># Keep reading scores until the user enters -1\ntotal = 0\ncount = 0\n\nscore = int(input(\"Enter a score (-1 to stop): \"))\n\nwhile score != -1:  # -1 is the sentinel value\n    total = total + score\n    count = count + 1\n    score = int(input(\"Enter a score (-1 to stop): \"))\n\nif count &gt; 0:\n    average = total / count\n    print(f\"Average score: {average}\")\nelse:\n    print(\"No scores entered.\")\n</code></pre> <p>The sentinel value (-1 in this case) is chosen because it's not a valid score. Sentinels must be values that would never appear as legitimate data.</p> <p>Common sentinel values include:</p> <ul> <li><code>-1</code> for positive-only data</li> <li><code>\"\"</code> (empty string) for text input</li> <li><code>\"quit\"</code> or <code>\"exit\"</code> as a command</li> <li><code>0</code> when zero isn't valid data</li> </ul>"},{"location":"chapters/04-control-flow/#the-flag-variable-pattern","title":"The Flag Variable Pattern","text":"<p>The flag variable pattern uses a Boolean variable (the \"flag\") to track whether a certain condition has been encountered. Think of it like raising a flag on a mailbox \u2014 once it's up, you know something happened.</p> <pre><code># Check if a list contains any negative numbers\nnumbers = [4, 7, -2, 9, 1]\nhas_negative = False  # flag variable\n\nfor num in numbers:\n    if num &lt; 0:\n        has_negative = True\n        break  # no need to keep looking\n\nif has_negative:\n    print(\"The list contains negative numbers.\")\nelse:\n    print(\"All numbers are positive.\")\n</code></pre> <p>The flag starts as <code>False</code> and gets flipped to <code>True</code> when the condition is found. After the loop, you check the flag to decide what to do. This pattern is great when you're searching for something \u2014 you don't care how many items match, just whether at least one does.</p> <p>Monty says: Let's debug this together!</p> <p> Here's a quick cheat sheet for loop patterns: Accumulator = \"build up a total.\" Counter = \"count how many.\" Sentinel = \"stop when you see the signal.\" Flag = \"did this thing ever happen?\" Once you recognize which pattern a problem calls for, writing the code becomes much easier!</p>"},{"location":"chapters/04-control-flow/#diagram-loop-patterns-comparison","title":"Diagram: Loop Patterns Comparison","text":"Loop Patterns Comparison MicroSim <p>Type: microsim sim-id: loop-patterns-comparison Library: p5.js Status: Specified</p> <p>Bloom Level: Analyze (L4) Bloom Verb: classify, differentiate</p> <p>Learning Objective: Students will be able to identify which loop pattern (accumulator, counter, sentinel, flag) is being used in a given code example and explain why that pattern was chosen.</p> <p>Purpose: An interactive quiz/explorer that presents code snippets and asks students to identify the loop pattern being used, with visual feedback and explanations.</p> <p>Layout: - Top: Four pattern cards arranged horizontally, each with a name, icon, and one-sentence description   - Accumulator (sum icon): \"Build up a result\"   - Counter (tally icon): \"Count matches\"   - Sentinel (stop sign icon): \"Stop on signal\"   - Flag (flag icon): \"Track if something happened\" - Middle: A code snippet display area showing a Python loop example - Bottom: \"Which pattern is this?\" prompt with four clickable buttons matching the pattern cards</p> <p>Interactive elements: - \"Next Example\" button cycles through 8-10 different code snippets - Click a pattern button to guess \u2014 correct answers highlight green with explanation, incorrect flash red with a hint - Score tracker in the corner (e.g., \"5/8 correct\") - \"Show Answer\" button reveals the correct pattern with explanation - Each pattern card is clickable to show a reference example of that pattern</p> <p>Visual elements: - Code snippets displayed with syntax highlighting - Correct guess: confetti animation and green glow - Incorrect guess: gentle red flash and hint text - Pattern cards pulse when they're the correct answer after reveal</p> <p>Color scheme: Accumulator (blue), Counter (green), Sentinel (orange), Flag (purple) Responsive: Pattern cards stack in 2x2 grid on narrow screens; code area adjusts width</p> <p>Instructional Rationale: Classification tasks support the Analyze level by requiring students to look at code structure and match it to an abstract pattern. Multiple examples build pattern recognition fluency. Immediate feedback with explanations corrects misconceptions on the spot.</p>"},{"location":"chapters/04-control-flow/#putting-it-all-together","title":"Putting It All Together","text":"<p>Let's see how these concepts combine in a more realistic example. Here's a number-guessing game that uses a while loop, conditionals, a counter, and a flag:</p> <pre><code>import random\n\nsecret = random.randint(1, 100)\nguesses = 0  # counter pattern\nfound = False  # flag variable pattern\n\nprint(\"I'm thinking of a number between 1 and 100!\")\n\nwhile not found:\n    guess = int(input(\"Your guess: \"))\n    guesses = guesses + 1\n\n    if guess &lt; secret:\n        print(\"Too low! Try again.\")\n    elif guess &gt; secret:\n        print(\"Too high! Try again.\")\n    else:\n        found = True\n        print(f\"You got it in {guesses} guesses!\")\n</code></pre> <p>This little program uses almost everything we covered: control flow, conditionals (if-elif-else), a while loop, a counter pattern, and a flag variable pattern. That's the beauty of these building blocks \u2014 individually they're simple, but together they can create something genuinely interactive and fun.</p> <p>Monty says: You've got this!</p> <p> Awesome work making it through this monster chapter! You now know how to make programs that think (conditionals), repeat (loops), and decide when to stop (break, continue, sentinels, flags). These tools are the backbone of every program you'll ever write. From here on out, your code is going to get a lot more interesting!</p>"},{"location":"chapters/04-control-flow/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Control flow determines the order in which statements execute. The three patterns are sequential, selection (conditionals), and iteration (loops).</li> <li>If, elif, and else let your program choose different paths. Python checks conditions top-to-bottom and takes the first match.</li> <li>Ternary expressions provide a compact one-line if-else for simple choices.</li> <li>Match statements (Python 3.10+) cleanly handle checking one value against multiple options.</li> <li>Nested conditionals place if statements inside other if statements \u2014 use sparingly for readability.</li> <li>For loops iterate over sequences (lists, strings, ranges). While loops repeat as long as a condition is True.</li> <li>The range function generates sequences of numbers. Remember: the stop value is exclusive.</li> <li>Loop variables take a new value each iteration; the loop body is the indented code that repeats.</li> <li>Break exits a loop immediately. Continue skips to the next iteration.</li> <li>Infinite loops occur when a while condition never becomes False \u2014 always ensure your loop can terminate.</li> <li>Nested loops run the inner loop completely for each iteration of the outer loop.</li> <li>The loop else clause runs only if the loop finishes without hitting break.</li> <li>Accumulator pattern: initialize, update inside loop, use after loop \u2014 for building totals or results.</li> <li>Counter pattern: accumulate +1 each time a condition is met.</li> <li>Sentinel value pattern: loop until a special \"stop\" value is entered.</li> <li>Flag variable pattern: use a Boolean to track whether something was found.</li> </ul> Check Your Understanding: What does this code print? <pre><code>for i in range(3):\n    for j in range(2):\n        print(f\"{i}-{j}\", end=\" \")\n    print()\n</code></pre> <p>Answer: </p><pre><code>0-0 0-1\n1-0 1-1\n2-0 2-1\n</code></pre> The outer loop runs 3 times (i = 0, 1, 2). For each value of i, the inner loop runs 2 times (j = 0, 1). That's 3 x 2 = 6 total iterations, printed in a 3-row, 2-column grid.<p></p> Check Your Understanding: Which loop pattern would you use to find out whether a list contains any prime numbers? <p>The flag variable pattern! You'd set a Boolean variable like <code>has_prime = False</code> before the loop, check each number, and set it to <code>True</code> if you find a prime. After the loop, check the flag. You could also use <code>break</code> to stop early once you find one.</p> Check Your Understanding: What's the difference between <code>break</code> and <code>continue</code>? <p>Break exits the loop completely \u2014 no more iterations happen. Continue skips the rest of the current iteration and jumps to the next one. Think of break as walking out of a movie theater, and continue as fast-forwarding past a boring scene.</p>"},{"location":"chapters/05-working-with-strings/","title":"Working with Strings","text":""},{"location":"chapters/05-working-with-strings/#working-with-strings","title":"Working with Strings","text":""},{"location":"chapters/05-working-with-strings/#summary","title":"Summary","text":"<p>This chapter provides a comprehensive treatment of Python strings. Students will learn string indexing, negative indexing, slicing, and immutability. The chapter covers essential string methods (upper, lower, strip, split, join, find, replace), string formatting techniques, iteration over strings, and string comparison. These text-processing skills are fundamental to nearly every Python program.</p>"},{"location":"chapters/05-working-with-strings/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 25 concepts from the learning graph:</p> <ol> <li>String Basics</li> <li>String Indexing</li> <li>Negative Indexing</li> <li>String Slicing</li> <li>Slice Notation</li> <li>String Immutability</li> <li>String Length</li> <li>String Methods</li> <li>Upper and Lower Methods</li> <li>Strip Method</li> <li>Split Method</li> <li>Join Method</li> <li>Find and Replace Methods</li> <li>Startswith and Endswith</li> <li>String Iteration</li> <li>String Comparison</li> <li>Escape Characters</li> <li>Raw Strings</li> <li>Multiline Strings</li> <li>String Formatting</li> <li>Format Method</li> <li>String Validation Methods</li> <li>In Operator for Strings</li> <li>Character Methods</li> <li>String Reversal</li> </ol>"},{"location":"chapters/05-working-with-strings/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 2: Python Fundamentals</li> <li>Chapter 3: Boolean Logic and Comparisons</li> <li>Chapter 4: Control Flow</li> </ul> <p>Monty says: Let's code this!</p> <p> Welcome back, coders! Get ready to become a text wizard. Strings are everywhere in programming \u2014 usernames, messages, web pages, even DNA sequences. By the end of this chapter, you'll be slicing, dicing, searching, and formatting text like a pro. Let's string together some awesome skills!</p>"},{"location":"chapters/05-working-with-strings/#string-basics","title":"String Basics","text":"<p>A string is a sequence of characters. That's it. Letters, numbers, spaces, punctuation, emoji \u2014 if you can type it, you can put it in a string. In Python, you create a string by wrapping text in quotes:</p> <pre><code>greeting = \"Hello, world!\"\nname = 'Alice'\nnumber_as_text = \"42\"\n</code></pre> <p>Notice you can use either double quotes (<code>\"...\"</code>) or single quotes (<code>'...'</code>). Python doesn't care which one you pick, as long as you start and end with the same type. Most Python programmers use double quotes by convention, but single quotes are handy when your string contains a double quote:</p> <pre><code>dialogue = 'She said, \"Python is amazing!\"'\n</code></pre> <p>A string can be empty, too:</p> <pre><code>empty = \"\"\n</code></pre> <p>An empty string has zero characters, but it's still a valid string. Think of it like an empty box \u2014 there's nothing inside, but the box is real.</p> <p>Here are a few important things to know about strings right away:</p> <ul> <li>Strings are ordered \u2014 each character has a specific position</li> <li>Strings are immutable \u2014 once created, you can't change individual characters (more on this soon)</li> <li>Strings can contain any Unicode character \u2014 letters, digits, symbols, and even emoji</li> </ul>"},{"location":"chapters/05-working-with-strings/#string-length","title":"String Length","text":"<p>How many characters are in a string? Python's built-in <code>len()</code> function tells you the string length:</p> <pre><code>message = \"Hello!\"\nprint(len(message))  # Output: 6\n</code></pre> <p>Every character counts, including spaces and punctuation:</p> <pre><code>sentence = \"Hi there!\"\nprint(len(sentence))  # Output: 9\n</code></pre> <p>That's 2 letters + 1 space + 5 letters + 1 exclamation mark = 9 characters. The <code>len()</code> function is one you'll reach for constantly. It's your string measuring tape.</p>"},{"location":"chapters/05-working-with-strings/#accessing-characters-string-indexing","title":"Accessing Characters: String Indexing","text":"<p>Since a string is a sequence, each character sits at a numbered position called an index. Here's the key: Python starts counting at zero, not one. This is called zero-based indexing.</p> <p>Let's visualize the string <code>\"PYTHON\"</code>:</p> Character P Y T H O N Index 0 1 2 3 4 5 <p>You access a character using square brackets:</p> <pre><code>word = \"PYTHON\"\nprint(word[0])   # P\nprint(word[1])   # Y\nprint(word[5])   # N\n</code></pre> <p>If you try to access an index that doesn't exist, Python raises an <code>IndexError</code>:</p> <pre><code>print(word[6])   # IndexError: string index out of range\n</code></pre> <p>String indexing is like seats on a bus. Seat 0 is the first seat, seat 1 is the second, and so on. If the bus only has 6 seats (indices 0-5), asking for seat 6 gets you nowhere.</p>"},{"location":"chapters/05-working-with-strings/#diagram-string-indexing-visualizer","title":"Diagram: String Indexing Visualizer","text":"String Indexing Visualizer MicroSim <p>Type: microsim sim-id: string-indexing-visualizer Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: demonstrate, identify</p> <p>Learning Objective: Students will be able to determine the character at any given index (positive or negative) within a string.</p> <p>Purpose: An interactive visualization where students type a string and click on individual character boxes to see both the positive and negative index for that position.</p> <p>Layout:</p> <ul> <li>Top section: Text input field where the student can type any string (default: \"PYTHON\")</li> <li>Middle section: Row of character boxes, each showing one character of the string in a large font</li> <li>Above each box: The positive index (0, 1, 2, ...)</li> <li>Below each box: The negative index (-6, -5, -4, ...)</li> <li>Bottom section: Display area showing <code>string[index] = character</code> when a box is clicked</li> <li>A slider or number input labeled \"Index:\" where the student can enter a positive or negative integer, and the corresponding character box highlights</li> </ul> <p>Interactive elements:</p> <ul> <li>Click any character box to highlight it and display its positive index, negative index, and value</li> <li>Type a positive or negative integer in the \"Index:\" input to highlight the corresponding box</li> <li>Edit the string in the text input to see a new string visualized instantly</li> <li>If the entered index is out of range, show a red \"IndexError!\" message</li> </ul> <p>Visual elements:</p> <ul> <li>Character boxes have alternating light blue and light green backgrounds</li> <li>Highlighted box gets a gold border and slight scale-up animation</li> <li>Positive indices displayed in blue above boxes</li> <li>Negative indices displayed in red below boxes</li> <li>IndexError message displayed in red with a shake animation</li> </ul> <p>Color scheme: Blue for positive indices, red for negative indices, gold highlight for selected box Responsive: Boxes scale based on string length and window width</p> <p>Instructional Rationale: Direct manipulation of index values supports the Apply level by requiring students to map between index numbers and character positions. Showing both positive and negative indices simultaneously helps students build a mental model of bidirectional access. Immediate IndexError feedback teaches boundaries without crashing a real program.</p>"},{"location":"chapters/05-working-with-strings/#negative-indexing","title":"Negative Indexing","text":"<p>What if you want the last character of a string, but you don't know how long it is? You could write <code>word[len(word) - 1]</code>, but Python gives you a shortcut: negative indexing.</p> <p>Negative indices count backward from the end of the string. The last character is at index <code>-1</code>, the second-to-last is <code>-2</code>, and so on:</p> Character P Y T H O N Positive Index 0 1 2 3 4 5 Negative Index -6 -5 -4 -3 -2 -1 <pre><code>word = \"PYTHON\"\nprint(word[-1])   # N (last character)\nprint(word[-2])   # O (second to last)\nprint(word[-6])   # P (first character)\n</code></pre> <p>Negative indexing is incredibly handy. Need the last character of a filename to check its extension? Just use <code>filename[-1]</code>. Need the last three characters? We'll cover that next with slicing.</p>"},{"location":"chapters/05-working-with-strings/#string-slicing","title":"String Slicing","text":"<p>String slicing lets you extract a portion of a string \u2014 a substring. Instead of grabbing one character at a time, you can grab a whole chunk.</p> <p>The slice notation uses a colon inside the square brackets:</p> <pre><code>string[start:stop]\n</code></pre> <p>This gives you characters from index <code>start</code> up to (but not including) index <code>stop</code>. Think of it like a fence: <code>start</code> is where you begin, <code>stop</code> is where you stop \u2014 you don't include the post at <code>stop</code>.</p> <pre><code>word = \"PYTHON\"\nprint(word[0:3])   # PYT (indices 0, 1, 2)\nprint(word[2:5])   # THO (indices 2, 3, 4)\nprint(word[1:4])   # YTH (indices 1, 2, 3)\n</code></pre> <p>You can also leave out <code>start</code> or <code>stop</code> to slice from the beginning or to the end:</p> <pre><code>print(word[:3])    # PYT (from start to index 3)\nprint(word[3:])    # HON (from index 3 to end)\nprint(word[:])     # PYTHON (a copy of the whole string)\n</code></pre> <p>Monty says: You've got this!</p> <p> The \"up to but not including\" rule trips up a lot of beginners. Here's a trick to remember it: the number of characters you get equals <code>stop - start</code>. So <code>word[1:4]</code> gives you <code>4 - 1 = 3</code> characters. Neat, right?</p>"},{"location":"chapters/05-working-with-strings/#extended-slice-notation","title":"Extended Slice Notation","text":"<p>You can add a third number \u2014 the step \u2014 to skip characters:</p> <pre><code>string[start:stop:step]\n</code></pre> <pre><code>word = \"PYTHON\"\nprint(word[0:6:2])   # PTO (every other character)\nprint(word[::2])     # PTO (same thing, shorter)\nprint(word[1::2])    # YHN (every other, starting at index 1)\n</code></pre> <p>Negative slicing works too:</p> <pre><code>print(word[-3:])     # HON (last three characters)\nprint(word[:-2])     # PYTH (everything except last two)\n</code></pre> <p>Here's a handy reference table for common slicing patterns:</p> Slice Meaning Example with <code>\"PYTHON\"</code> <code>s[0:3]</code> First three characters <code>\"PYT\"</code> <code>s[:3]</code> First three characters (shorthand) <code>\"PYT\"</code> <code>s[3:]</code> Everything from index 3 onward <code>\"HON\"</code> <code>s[-3:]</code> Last three characters <code>\"HON\"</code> <code>s[:-1]</code> Everything except the last character <code>\"PYTHO\"</code> <code>s[::2]</code> Every other character <code>\"PTO\"</code> <code>s[::-1]</code> The entire string reversed <code>\"NOHTYP\"</code> <code>s[:]</code> A copy of the full string <code>\"PYTHON\"</code>"},{"location":"chapters/05-working-with-strings/#diagram-string-slicing-playground","title":"Diagram: String Slicing Playground","text":"String Slicing Playground MicroSim <p>Type: microsim sim-id: string-slicing-playground Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: demonstrate, predict</p> <p>Learning Objective: Students will be able to use slice notation to extract substrings, predict the result of a slice expression, and experiment with start, stop, and step parameters.</p> <p>Purpose: An interactive playground where students can adjust start, stop, and step values using sliders and immediately see which characters are selected in a visual string display.</p> <p>Layout:</p> <ul> <li>Top section: Editable text input for the string (default: \"COMPUTER SCIENCE\")</li> <li>Middle section: Row of character boxes (like the indexing visualizer) showing each character with positive index above and negative index below</li> <li>Three sliders below the character boxes:</li> <li>Start slider (range: -len to len, default: 0)</li> <li>Stop slider (range: -len to len, default: len)</li> <li>Step slider (range: -len to len, excluding 0, default: 1)</li> <li>Below sliders: Display showing the current slice notation <code>string[start:stop:step]</code> and the resulting substring</li> <li>A \"Challenge\" button that shows a target substring and asks the student to set the sliders to produce it</li> </ul> <p>Interactive elements:</p> <ul> <li>Drag any slider to change start, stop, or step values</li> <li>Selected characters are highlighted in the character box row in real time</li> <li>Characters included in the slice get a gold background; excluded characters are dimmed</li> <li>An arrow overlay on the character boxes shows the direction (left-to-right or right-to-left depending on step sign)</li> <li>Challenge mode displays a target string and turns green when the student's slice matches</li> </ul> <p>Visual elements:</p> <ul> <li>Character boxes use alternating colors; selected characters glow gold</li> <li>Sliders labeled clearly with current values</li> <li>The slice notation string updates live: e.g., <code>\"COMPUTER SCIENCE\"[2:8:1]</code> = <code>\"MPUTER\"</code></li> <li>Step direction indicated by arrow overlays on the character boxes</li> <li>Challenge mode target shown in a green bordered box</li> </ul> <p>Color scheme: Gold for selected characters, gray for excluded, green for correct challenge answer Responsive: Canvas and sliders scale with window width; character boxes resize for long strings</p> <p>Instructional Rationale: Slider-based manipulation supports the Apply level by letting students experiment freely with all three slice parameters and immediately see the visual result. The spatial highlighting on the character row makes abstract index arithmetic concrete. Challenge mode provides goal-directed practice.</p>"},{"location":"chapters/05-working-with-strings/#string-immutability","title":"String Immutability","text":"<p>Here's a concept that surprises many new programmers: strings in Python are immutable. That means once a string is created, you cannot change its individual characters. You can't reach in and swap one letter for another.</p> <pre><code>word = \"Hello\"\nword[0] = \"J\"   # TypeError: 'str' object does not support item assignment\n</code></pre> <p>If you want a modified version of a string, you create a new string:</p> <pre><code>word = \"Hello\"\nnew_word = \"J\" + word[1:]   # \"Jello\"\nprint(new_word)             # Jello\n</code></pre> <p>Why is string immutability a thing? It makes strings safer and more efficient behind the scenes. Python can share string data in memory without worrying that some other part of your program will change it unexpectedly. Think of it like a printed poster \u2014 if you want to change a word on it, you don't erase the ink; you print a new poster.</p> <p>Monty says: Let's debug this together!</p> <p> This is one of the most common mistakes beginners make: trying to change a character inside a string with <code>my_string[3] = \"x\"</code>. Python will always throw a <code>TypeError</code>. Remember \u2014 to \"change\" a string, you build a new one from pieces of the old one.</p>"},{"location":"chapters/05-working-with-strings/#escape-characters","title":"Escape Characters","text":"<p>What if you need to put a quote mark inside a string that's wrapped in the same kind of quotes? Or what about a newline or a tab? That's where escape characters come in. An escape character starts with a backslash (<code>\\</code>) followed by a special code:</p> Escape Sequence What It Produces <code>\\n</code> New line (moves to next line) <code>\\t</code> Tab (horizontal space) <code>\\\\</code> A literal backslash <code>\\'</code> A literal single quote <code>\\\"</code> A literal double quote <pre><code>print(\"Line one\\nLine two\")\n# Output:\n# Line one\n# Line two\n\nprint(\"Name:\\tAlice\")\n# Output:\n# Name:   Alice\n\nprint(\"She said, \\\"Wow!\\\"\")\n# Output:\n# She said, \"Wow!\"\n</code></pre>"},{"location":"chapters/05-working-with-strings/#raw-strings","title":"Raw Strings","text":"<p>Sometimes you want backslashes to be treated literally \u2014 no escape sequences. This is common when working with file paths on Windows or regular expressions. A raw string is prefixed with <code>r</code>:</p> <pre><code># Regular string: \\n becomes a newline\nprint(\"C:\\new_folder\")   # C:\n                          # ew_folder\n\n# Raw string: \\n stays as \\n\nprint(r\"C:\\new_folder\")  # C:\\new_folder\n</code></pre> <p>Raw strings tell Python: \"Don't interpret any backslashes. Just take everything literally.\"</p>"},{"location":"chapters/05-working-with-strings/#multiline-strings","title":"Multiline Strings","text":"<p>For text that spans multiple lines, use triple quotes \u2014 either <code>\"\"\"...\"\"\"</code> or <code>'''...'''</code>:</p> <pre><code>poem = \"\"\"Roses are red,\nViolets are blue,\nPython is awesome,\nAnd so are you!\"\"\"\n\nprint(poem)\n</code></pre> <p>Multiline strings preserve line breaks and spacing exactly as you type them. They're perfect for long messages, documentation, or any text that needs to span several lines.</p>"},{"location":"chapters/05-working-with-strings/#string-methods","title":"String Methods","text":"<p>Now we get to the really powerful stuff. String methods are built-in functions that every string carries with it. You call them using dot notation: <code>my_string.method_name()</code>. Python has dozens of string methods, and they all return new strings (remember, strings are immutable!).</p> <p>Let's explore the most important ones.</p>"},{"location":"chapters/05-working-with-strings/#upper-and-lower-methods","title":"Upper and Lower Methods","text":"<p>The upper and lower methods change the case of every letter in a string:</p> <pre><code>name = \"Alice Smith\"\nprint(name.upper())   # ALICE SMITH\nprint(name.lower())   # alice smith\n</code></pre> <p>These are incredibly useful for case-insensitive comparisons:</p> <pre><code>user_input = \"YES\"\nif user_input.lower() == \"yes\":\n    print(\"User said yes!\")\n</code></pre> <p>There are a few related case methods worth knowing:</p> Method What It Does Example <code>.upper()</code> All uppercase <code>\"hello\"</code> becomes <code>\"HELLO\"</code> <code>.lower()</code> All lowercase <code>\"HELLO\"</code> becomes <code>\"hello\"</code> <code>.title()</code> Capitalize each word <code>\"hello world\"</code> becomes <code>\"Hello World\"</code> <code>.capitalize()</code> Capitalize first letter only <code>\"hello world\"</code> becomes <code>\"Hello world\"</code> <code>.swapcase()</code> Flip every letter's case <code>\"Hello\"</code> becomes <code>\"hELLO\"</code>"},{"location":"chapters/05-working-with-strings/#strip-method","title":"Strip Method","text":"<p>The strip method removes whitespace (spaces, tabs, newlines) from both ends of a string:</p> <pre><code>messy = \"   Hello, world!   \"\nclean = messy.strip()\nprint(clean)        # \"Hello, world!\"\nprint(len(messy))   # 19\nprint(len(clean))   # 13\n</code></pre> <p>You can also strip from just one side:</p> <ul> <li><code>.lstrip()</code> \u2014 removes leading (left) whitespace</li> <li><code>.rstrip()</code> \u2014 removes trailing (right) whitespace</li> </ul> <p>Why does this matter? Because user input is often messy. Someone types \" Alice \" with extra spaces, and your program needs to handle it gracefully. The <code>strip()</code> method is your cleanup crew.</p>"},{"location":"chapters/05-working-with-strings/#split-method","title":"Split Method","text":"<p>The split method breaks a string into a list of smaller strings based on a separator:</p> <pre><code>sentence = \"Python is awesome\"\nwords = sentence.split()        # Split on whitespace (default)\nprint(words)                    # ['Python', 'is', 'awesome']\n\ncsv_data = \"Alice,Bob,Charlie\"\nnames = csv_data.split(\",\")     # Split on commas\nprint(names)                    # ['Alice', 'Bob', 'Charlie']\n</code></pre> <p>The <code>split()</code> method is a workhorse for parsing text data. Got a comma-separated list? Split on commas. Got a sentence? Split on spaces. Got a file path? Split on slashes.</p>"},{"location":"chapters/05-working-with-strings/#join-method","title":"Join Method","text":"<p>The join method is the opposite of <code>split()</code> \u2014 it takes a list of strings and glues them together with a separator:</p> <pre><code>words = ['Python', 'is', 'awesome']\nsentence = \" \".join(words)\nprint(sentence)                 # \"Python is awesome\"\n\nnames = ['Alice', 'Bob', 'Charlie']\ncsv_line = \",\".join(names)\nprint(csv_line)                 # \"Alice,Bob,Charlie\"\n</code></pre> <p>Notice the syntax: you call <code>.join()</code> on the separator string, not on the list. This feels a bit backward at first, but it makes sense when you think about it \u2014 the separator is what defines how the pieces connect.</p>"},{"location":"chapters/05-working-with-strings/#diagram-split-and-join-visualizer","title":"Diagram: Split and Join Visualizer","text":"Split and Join Visualizer MicroSim <p>Type: microsim sim-id: split-join-visualizer Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: explain, demonstrate</p> <p>Learning Objective: Students will be able to explain how <code>split()</code> breaks a string into a list and how <code>join()</code> reassembles a list into a string, and predict the output for given inputs and separators.</p> <p>Purpose: An animated visualization that shows the split and join operations step by step, helping students see how a single string becomes a list of parts and vice versa.</p> <p>Layout:</p> <ul> <li>Top half: \"Split\" section</li> <li>Input field for a string (default: \"one,two,three\")</li> <li>Input field for separator (default: \",\")</li> <li>A \"Split!\" button</li> <li>Animation area: shows the original string breaking apart at separator positions, pieces flying to form a list display <code>['one', 'two', 'three']</code></li> <li>Bottom half: \"Join\" section</li> <li>Display of the current list from the split above</li> <li>Input field for join separator (default: \" - \")</li> <li>A \"Join!\" button</li> <li>Animation area: shows list items sliding together with the separator inserted between them, forming a new string <code>\"one - two - three\"</code></li> </ul> <p>Interactive elements:</p> <ul> <li>Edit the input string and separator, then click \"Split!\" to see the animated split</li> <li>Edit the join separator, then click \"Join!\" to see the animated join</li> <li>Each piece in the split list is a draggable card that students can reorder before joining</li> <li>A \"Swap\" button that toggles between split mode and join mode</li> </ul> <p>Visual elements:</p> <ul> <li>String displayed as a row of character boxes</li> <li>Separator characters highlighted in red before the split animation</li> <li>During split animation, the string visually tears apart at separator positions</li> <li>List items shown as colored cards</li> <li>During join animation, cards slide together with separator cards inserted between them</li> <li>Final joined string animates into a continuous row</li> </ul> <p>Color scheme: Blue for string characters, red for separator characters, green for list item cards Responsive: Canvas scales with window width; text sizes adjust for long strings</p> <p>Instructional Rationale: Animation of the split/join process supports the Understand level by making the invisible string manipulation visible. Showing split and join as inverse operations reinforces that they are complementary. Allowing students to reorder list items before joining adds an element of experimentation.</p>"},{"location":"chapters/05-working-with-strings/#find-and-replace-methods","title":"Find and Replace Methods","text":"<p>Need to search inside a string? The find and replace methods have you covered.</p> <p>The <code>.find()</code> method returns the index of the first occurrence of a substring, or <code>-1</code> if it's not found:</p> <pre><code>message = \"Hello, world!\"\nprint(message.find(\"world\"))    # 7\nprint(message.find(\"Python\"))   # -1 (not found)\n</code></pre> <p>The <code>.replace()</code> method swaps every occurrence of one substring with another:</p> <pre><code>text = \"I like cats. Cats are great.\"\nnew_text = text.replace(\"cats\", \"dogs\")\nprint(new_text)   # \"I like dogs. Cats are great.\"\n</code></pre> <p>Wait \u2014 why didn't \"Cats\" get replaced? Because <code>.replace()</code> is case-sensitive. <code>\"cats\"</code> and <code>\"Cats\"</code> are different strings. If you want to replace both, you'd need to handle each case or convert to lowercase first.</p> <p>You can also limit the number of replacements:</p> <pre><code>text = \"ha ha ha ha\"\nprint(text.replace(\"ha\", \"HO\", 2))   # \"HO HO ha ha\"\n</code></pre>"},{"location":"chapters/05-working-with-strings/#startswith-and-endswith","title":"Startswith and Endswith","text":"<p>The startswith and endswith methods check whether a string begins or ends with a specific substring. They return <code>True</code> or <code>False</code>:</p> <pre><code>filename = \"report.pdf\"\nprint(filename.endswith(\".pdf\"))      # True\nprint(filename.endswith(\".docx\"))     # False\nprint(filename.startswith(\"report\"))  # True\n</code></pre> <p>These are perfect for checking file extensions, URL protocols, or any kind of prefix/suffix matching:</p> <pre><code>url = \"https://www.python.org\"\nif url.startswith(\"https://\"):\n    print(\"Secure connection!\")\n</code></pre>"},{"location":"chapters/05-working-with-strings/#string-formatting","title":"String Formatting","text":"<p>Building strings from a mix of text and variables is something you'll do constantly. String formatting gives you clean, readable ways to combine them.</p>"},{"location":"chapters/05-working-with-strings/#f-strings-formatted-string-literals","title":"f-strings (Formatted String Literals)","text":"<p>The most modern and popular approach is the f-string. Just put an <code>f</code> before the opening quote and use curly braces <code>{}</code> to insert expressions:</p> <pre><code>name = \"Alice\"\nage = 16\nprint(f\"My name is {name} and I am {age} years old.\")\n# Output: My name is Alice and I am 16 years old.\n</code></pre> <p>You can put any Python expression inside the curly braces:</p> <pre><code>x = 7\nprint(f\"The square of {x} is {x ** 2}.\")\n# Output: The square of 7 is 49.\n</code></pre>"},{"location":"chapters/05-working-with-strings/#the-format-method","title":"The Format Method","text":"<p>Before f-strings, Python programmers used the format method:</p> <pre><code>template = \"My name is {} and I am {} years old.\"\nprint(template.format(\"Alice\", 16))\n# Output: My name is Alice and I am 16 years old.\n</code></pre> <p>You can also use numbered or named placeholders:</p> <pre><code>print(\"{0} loves {1}, and {1} loves {0}\".format(\"Alice\", \"Bob\"))\n# Output: Alice loves Bob, and Bob loves Alice\n\nprint(\"{name} scored {score}%\".format(name=\"Charlie\", score=95))\n# Output: Charlie scored 95%\n</code></pre> <p>Both f-strings and <code>.format()</code> work great. In this course, we'll mostly use f-strings since they're shorter and easier to read. But you'll see <code>.format()</code> in plenty of existing Python code.</p> <p>Monty says: Let's debug this together!</p> <p> f-strings are your best friend for clean output. Instead of writing <code>print(\"Score: \" + str(score) + \" points\")</code>, just write <code>print(f\"Score: {score} points\")</code>. Shorter, cleaner, and no need to convert numbers to strings manually!</p>"},{"location":"chapters/05-working-with-strings/#diagram-string-formatting-comparison","title":"Diagram: String Formatting Comparison","text":"String Formatting Comparison MicroSim <p>Type: microsim sim-id: string-formatting-comparison Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: apply, demonstrate</p> <p>Learning Objective: Students will be able to construct formatted strings using f-strings and the <code>.format()</code> method, and choose the appropriate formatting approach for a given task.</p> <p>Purpose: A side-by-side comparison tool where students define variables and a template, then see the output of both f-string and <code>.format()</code> approaches simultaneously.</p> <p>Layout:</p> <ul> <li>Top section: Variable definition area with three text inputs:</li> <li>Variable 1: name and value (default: <code>name = \"Alice\"</code>)</li> <li>Variable 2: name and value (default: <code>age = 16</code>)</li> <li>Variable 3: name and value (default: <code>score = 95.5</code>)</li> <li>Middle section: Two columns</li> <li>Left column: \"f-string\" \u2014 shows the f-string syntax with editable template (default: <code>f\"Hello {name}, age {age}, score: {score}\"</code>)</li> <li>Right column: \".format()\" \u2014 shows the equivalent .format() syntax, auto-generated</li> <li>Bottom section: Output display showing the result string, identical for both approaches</li> <li>A \"Try it!\" button that evaluates and displays the result</li> <li>A gallery of example templates students can click to load</li> </ul> <p>Interactive elements:</p> <ul> <li>Edit variable values and see the output update</li> <li>Edit the f-string template and see the .format() equivalent auto-generate</li> <li>Click example templates from a gallery (e.g., \"Name badge\", \"Score report\", \"Email greeting\")</li> <li>Toggle \"Show number formatting\" to see examples with decimal places, padding, and alignment</li> </ul> <p>Visual elements:</p> <ul> <li>Variable values highlighted in gold within both template strings</li> <li>Curly braces and format specifiers highlighted in blue</li> <li>Output string displayed in a large, clean font</li> <li>Side-by-side layout with a visual \"equals\" sign between the two approaches</li> </ul> <p>Color scheme: Gold for variable values, blue for format syntax, green for output Responsive: Columns stack vertically on narrow screens</p> <p>Instructional Rationale: Side-by-side comparison supports the Apply level by letting students see two equivalent approaches simultaneously, building flexibility. Editable templates with instant feedback encourage experimentation. The example gallery provides scaffolded practice for common formatting patterns.</p>"},{"location":"chapters/05-working-with-strings/#string-iteration","title":"String Iteration","text":"<p>Since a string is a sequence of characters, you can loop through it one character at a time. This is called string iteration, and it uses the <code>for</code> loop you learned in Chapter 4:</p> <pre><code>word = \"PYTHON\"\nfor letter in word:\n    print(letter)\n</code></pre> <p>Output:</p> <pre><code>P\nY\nT\nH\nO\nN\n</code></pre> <p>You can also loop with indices using <code>range()</code> and <code>len()</code>:</p> <pre><code>word = \"PYTHON\"\nfor i in range(len(word)):\n    print(f\"Index {i}: {word[i]}\")\n</code></pre> <p>Output:</p> <pre><code>Index 0: P\nIndex 1: Y\nIndex 2: T\nIndex 3: H\nIndex 4: O\nIndex 5: N\n</code></pre> <p>Here's a practical example \u2014 counting how many times a letter appears in a string:</p> <pre><code>text = \"mississippi\"\ncount = 0\nfor char in text:\n    if char == \"s\":\n        count += 1\nprint(f\"The letter 's' appears {count} times.\")\n# Output: The letter 's' appears 4 times.\n</code></pre> <p>(Python also has a built-in <code>.count()</code> method that does this in one line: <code>text.count(\"s\")</code>. But writing the loop yourself helps you understand what's happening under the hood.)</p>"},{"location":"chapters/05-working-with-strings/#the-in-operator-for-strings","title":"The In Operator for Strings","text":"<p>The in operator checks whether a substring exists inside a string. It returns <code>True</code> or <code>False</code>:</p> <pre><code>message = \"Hello, world!\"\nprint(\"world\" in message)     # True\nprint(\"Python\" in message)    # False\nprint(\"Hello\" in message)     # True\n</code></pre> <p>You can also use <code>not in</code>:</p> <pre><code>if \"spam\" not in message:\n    print(\"No spam here!\")    # This will print\n</code></pre> <p>The <code>in</code> operator is one of Python's most readable features. Code like <code>if \"error\" in log_message:</code> reads almost like English.</p>"},{"location":"chapters/05-working-with-strings/#string-comparison","title":"String Comparison","text":"<p>You can compare strings using the standard comparison operators you learned in Chapter 3. String comparison in Python works character by character, using each character's Unicode value:</p> <pre><code>print(\"apple\" == \"apple\")    # True\nprint(\"apple\" == \"Apple\")    # False (case matters!)\nprint(\"apple\" &lt; \"banana\")    # True (alphabetical order)\nprint(\"A\" &lt; \"a\")             # True (uppercase comes before lowercase in Unicode)\n</code></pre> <p>Python compares strings lexicographically \u2014 like alphabetical order, but based on Unicode values. Since uppercase letters have lower Unicode values than lowercase letters, <code>\"A\"</code> (65) is \"less than\" <code>\"a\"</code> (97).</p> <p>Here's the comparison order, from lowest to highest Unicode values:</p> <ol> <li>Digits: <code>\"0\"</code> through <code>\"9\"</code> (values 48-57)</li> <li>Uppercase letters: <code>\"A\"</code> through <code>\"Z\"</code> (values 65-90)</li> <li>Lowercase letters: <code>\"a\"</code> through <code>\"z\"</code> (values 97-122)</li> </ol> <p>For case-insensitive comparison, convert both strings to the same case first:</p> <pre><code>user_input = \"Alice\"\nstored_name = \"alice\"\nif user_input.lower() == stored_name.lower():\n    print(\"Names match!\")     # This will print\n</code></pre>"},{"location":"chapters/05-working-with-strings/#string-validation-methods","title":"String Validation Methods","text":"<p>Python gives you a set of string validation methods that test whether a string meets certain criteria. They all return <code>True</code> or <code>False</code>:</p> Method Returns <code>True</code> If... Example <code>.isalpha()</code> All characters are letters <code>\"Hello\"</code> is <code>True</code>, <code>\"Hello3\"</code> is <code>False</code> <code>.isdigit()</code> All characters are digits <code>\"123\"</code> is <code>True</code>, <code>\"12.3\"</code> is <code>False</code> <code>.isalnum()</code> All characters are letters or digits <code>\"Hello3\"</code> is <code>True</code>, <code>\"Hello!\"</code> is <code>False</code> <code>.isspace()</code> All characters are whitespace <code>\"   \"</code> is <code>True</code>, <code>\" hi \"</code> is <code>False</code> <code>.isupper()</code> All letters are uppercase <code>\"HELLO\"</code> is <code>True</code>, <code>\"Hello\"</code> is <code>False</code> <code>.islower()</code> All letters are lowercase <code>\"hello\"</code> is <code>True</code>, <code>\"Hello\"</code> is <code>False</code> <p>These are perfect for validating user input:</p> <pre><code>age_input = input(\"Enter your age: \")\nif age_input.isdigit():\n    age = int(age_input)\n    print(f\"You are {age} years old!\")\nelse:\n    print(\"That's not a valid number!\")\n</code></pre>"},{"location":"chapters/05-working-with-strings/#character-methods","title":"Character Methods","text":"<p>Every character in a string is actually a tiny string of length 1. Python provides a couple of handy character methods for converting between characters and their numeric Unicode values:</p> <ul> <li><code>ord(char)</code> \u2014 returns the Unicode number for a character</li> <li><code>chr(number)</code> \u2014 returns the character for a Unicode number</li> </ul> <pre><code>print(ord(\"A\"))     # 65\nprint(ord(\"a\"))     # 97\nprint(ord(\"0\"))     # 48\n\nprint(chr(65))      # A\nprint(chr(97))      # a\nprint(chr(128013))  # a snake emoji on many systems\n</code></pre> <p>These are useful for tasks like shifting characters (think secret codes!) or checking whether a character falls in a certain range.</p> <p>Monty says: Let's code this!</p> <p> Here's a neat trick: since uppercase letters are numbered 65-90 and lowercase are 97-122, the difference is always 32. So <code>chr(ord(\"A\") + 32)</code> gives you <code>\"a\"</code>. That's basically what <code>.lower()</code> does behind the scenes!</p>"},{"location":"chapters/05-working-with-strings/#string-reversal","title":"String Reversal","text":"<p>How do you reverse a string? Python doesn't have a built-in <code>.reverse()</code> method for strings (remember, strings are immutable!), but string reversal is incredibly easy with slice notation:</p> <pre><code>word = \"PYTHON\"\nreversed_word = word[::-1]\nprint(reversed_word)          # NOHTYP\n</code></pre> <p>The <code>[::-1]</code> slice says \"start at the end, go to the beginning, stepping backward by 1.\" It's one of Python's most elegant tricks.</p> <p>You can use this to check if a string is a palindrome \u2014 a word that reads the same forward and backward:</p> <pre><code>def is_palindrome(text):\n    cleaned = text.lower().replace(\" \", \"\")\n    return cleaned == cleaned[::-1]\n\nprint(is_palindrome(\"racecar\"))       # True\nprint(is_palindrome(\"hello\"))         # False\nprint(is_palindrome(\"A man a plan a canal Panama\"))  # True\n</code></pre>"},{"location":"chapters/05-working-with-strings/#diagram-palindrome-checker","title":"Diagram: Palindrome Checker","text":"Palindrome Checker MicroSim <p>Type: microsim sim-id: palindrome-checker Library: p5.js Status: Specified</p> <p>Bloom Level: Analyze (L4) Bloom Verb: analyze, compare</p> <p>Learning Objective: Students will be able to apply string reversal and cleaning techniques to determine whether a given string is a palindrome, and trace through the comparison step by step.</p> <p>Purpose: An interactive palindrome checker that visually shows the step-by-step process of cleaning, reversing, and comparing a string to determine if it reads the same forwards and backwards.</p> <p>Layout:</p> <ul> <li>Top section: Text input for a word or phrase (default: \"racecar\")</li> <li>Middle section: Three-stage visualization:</li> <li>Stage 1 \"Clean\": Shows the original string, then the cleaned version (lowercase, no spaces) with removed characters fading out</li> <li>Stage 2 \"Reverse\": Shows the cleaned string on top and the reversed string below, with animated arrows showing the reversal</li> <li>Stage 3 \"Compare\": Characters from the original and reversed strings are compared side by side, with matching characters lighting up green</li> <li>Bottom section: Large \"Palindrome!\" or \"Not a palindrome\" verdict with animation</li> </ul> <p>Interactive elements:</p> <ul> <li>Type any word or phrase in the input</li> <li>Click \"Check\" to start the step-by-step animation</li> <li>Click \"Step\" to advance one stage at a time</li> <li>A library of example palindromes to try (e.g., \"racecar\", \"A man a plan a canal Panama\", \"Was it a car or a cat I saw?\")</li> </ul> <p>Visual elements:</p> <ul> <li>Characters displayed as individual boxes in a row</li> <li>Cleaning stage: spaces and punctuation fade to transparent; uppercase letters animate to lowercase</li> <li>Reversal stage: boxes animate from original positions to reversed positions with a flip animation</li> <li>Comparison stage: pairs of boxes light up green (match) or red (no match) from outside in</li> <li>Verdict displayed with confetti animation for palindromes</li> </ul> <p>Color scheme: Green for matching characters, red for mismatches, gold for the \"Palindrome!\" message Responsive: Character boxes scale based on string length and window width</p> <p>Instructional Rationale: Step-by-step visualization of the cleaning, reversal, and comparison process supports the Analyze level by making each stage of the algorithm explicit. Students can trace the logic visually rather than just seeing a boolean result. The example library provides varied practice, including phrases with spaces and mixed case.</p>"},{"location":"chapters/05-working-with-strings/#practical-example-cleaning-user-input","title":"Practical Example: Cleaning User Input","text":"<p>Let's bring several concepts together with a real-world example. Suppose you're building a simple contact form and need to clean up a user's name:</p> <pre><code>raw_input = \"   aLiCe   sMiTh   \"\n\n# Step 1: Strip extra whitespace from both ends\nstripped = raw_input.strip()\nprint(stripped)           # \"aLiCe   sMiTh\"\n\n# Step 2: Split into individual words\nparts = stripped.split()\nprint(parts)              # ['aLiCe', 'sMiTh']\n\n# Step 3: Capitalize each word properly\nproper_parts = []\nfor part in parts:\n    proper_parts.append(part.capitalize())\nprint(proper_parts)       # ['Alice', 'Smith']\n\n# Step 4: Join back together\nclean_name = \" \".join(proper_parts)\nprint(clean_name)         # \"Alice Smith\"\n</code></pre> <p>Or, in one clean line using the <code>.title()</code> method:</p> <pre><code>clean_name = \"   aLiCe   sMiTh   \".strip().title()\nprint(clean_name)         # \"Alice Smith\"\n</code></pre> <p>That's the power of method chaining \u2014 calling multiple methods in a row. Each method returns a new string, and you immediately call the next method on that result.</p>"},{"location":"chapters/05-working-with-strings/#string-methods-reference-table","title":"String Methods Reference Table","text":"<p>Here's a comprehensive reference for the string methods covered in this chapter:</p> Method Description Returns <code>s.upper()</code> Converts to uppercase <code>str</code> <code>s.lower()</code> Converts to lowercase <code>str</code> <code>s.title()</code> Capitalizes each word <code>str</code> <code>s.capitalize()</code> Capitalizes first character <code>str</code> <code>s.strip()</code> Removes whitespace from both ends <code>str</code> <code>s.lstrip()</code> Removes whitespace from left <code>str</code> <code>s.rstrip()</code> Removes whitespace from right <code>str</code> <code>s.split(sep)</code> Splits string into list <code>list</code> <code>sep.join(list)</code> Joins list into string <code>str</code> <code>s.find(sub)</code> Index of first occurrence (-1 if not found) <code>int</code> <code>s.replace(old, new)</code> Replaces occurrences <code>str</code> <code>s.startswith(prefix)</code> Checks if starts with prefix <code>bool</code> <code>s.endswith(suffix)</code> Checks if ends with suffix <code>bool</code> <code>s.count(sub)</code> Counts occurrences of substring <code>int</code> <code>s.isalpha()</code> True if all letters <code>bool</code> <code>s.isdigit()</code> True if all digits <code>bool</code> <code>s.isalnum()</code> True if all letters/digits <code>bool</code> <code>s.isspace()</code> True if all whitespace <code>bool</code> <code>s.isupper()</code> True if all uppercase <code>bool</code> <code>s.islower()</code> True if all lowercase <code>bool</code>"},{"location":"chapters/05-working-with-strings/#diagram-string-methods-explorer","title":"Diagram: String Methods Explorer","text":"String Methods Explorer MicroSim <p>Type: microsim sim-id: string-methods-explorer Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: apply, experiment</p> <p>Learning Objective: Students will be able to apply common string methods to a given input string, predict the output before seeing it, and explain what each method does.</p> <p>Purpose: An interactive sandbox where students type a string, select a method from a menu, provide any required arguments, and see the result \u2014 with an option to predict the output first.</p> <p>Layout:</p> <ul> <li>Top section: Text input for the string (default: \"  Hello, World!  \")</li> <li>Middle section: Grid of method buttons organized by category:</li> <li>Case methods: upper(), lower(), title(), capitalize(), swapcase()</li> <li>Whitespace methods: strip(), lstrip(), rstrip()</li> <li>Search methods: find(), replace(), count(), startswith(), endswith()</li> <li>Split/Join: split(), join()</li> <li>Validation: isalpha(), isdigit(), isalnum(), isspace(), isupper(), islower()</li> <li>When a method requiring arguments is selected, an argument input field appears</li> <li>Bottom section:</li> <li>\"Predict\" area: students type what they think the output will be</li> <li>\"Run\" button: shows the actual output</li> <li>Comparison: highlights whether the prediction was correct</li> </ul> <p>Interactive elements:</p> <ul> <li>Click any method button to select it</li> <li>Enter arguments when prompted (e.g., separator for split, substring for find)</li> <li>Type a prediction, then click \"Run\" to compare</li> <li>A \"History\" panel on the side shows previous method calls and results</li> </ul> <p>Visual elements:</p> <ul> <li>Method buttons color-coded by category (blue for case, green for whitespace, orange for search, purple for validation)</li> <li>Correct predictions get a green check animation</li> <li>Incorrect predictions show the correct answer in red with a brief explanation</li> <li>History panel shows a scrollable list of previous operations</li> </ul> <p>Color scheme: Category-coded buttons, green for correct predictions, red for incorrect Responsive: Button grid adjusts column count based on window width</p> <p>Instructional Rationale: Predict-then-reveal interaction supports the Apply level by requiring students to mentally execute the method before seeing the answer. The category-organized button grid helps students build a mental map of available methods. The history panel lets students compare results across different methods applied to the same string.</p>"},{"location":"chapters/05-working-with-strings/#putting-it-all-together-text-analysis","title":"Putting It All Together: Text Analysis","text":"<p>Let's combine everything you've learned into a mini text analysis project. Here's a function that takes a sentence and reports interesting statistics:</p> <pre><code>def analyze_text(text):\n    print(f\"Text: '{text}'\")\n    print(f\"Length: {len(text)} characters\")\n    print(f\"Words: {len(text.split())}\")\n    print(f\"Uppercase: {text.upper()}\")\n    print(f\"Reversed: {text[::-1]}\")\n    print(f\"Starts with 'The': {text.startswith('The')}\")\n    print(f\"Contains 'python': {'python' in text.lower()}\")\n\n    # Count vowels\n    vowels = 0\n    for char in text.lower():\n        if char in \"aeiou\":\n            vowels += 1\n    print(f\"Vowels: {vowels}\")\n\nanalyze_text(\"The Python programming language is fun\")\n</code></pre> <p>Output:</p> <pre><code>Text: 'The Python programming language is fun'\nLength: 38 characters\nWords: 6\nUppercase: THE PYTHON PROGRAMMING LANGUAGE IS FUN\nReversed: nuf si egaugnal gnimmargorp nohtyP ehT\nStarts with 'The': True\nContains 'python': True\nVowels: 11\n</code></pre> <p>Monty says: You've got this!</p> <p> Amazing work, coder! You've just learned how to index, slice, search, format, validate, and reverse strings. These skills show up in almost every Python program you'll ever write. From processing user input to analyzing data files, strings are your bread and butter. On to the next chapter!</p>"},{"location":"chapters/05-working-with-strings/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>A string is an ordered, immutable sequence of characters. Create them with single, double, or triple quotes.</li> <li>String indexing starts at 0. Use negative indexing (starting at -1) to count from the end.</li> <li>String slicing with <code>[start:stop:step]</code> extracts substrings. The <code>stop</code> index is not included.</li> <li>Strings are immutable \u2014 you can't change individual characters. Create new strings instead.</li> <li><code>len()</code> returns the number of characters in a string.</li> <li>String methods like <code>.upper()</code>, <code>.lower()</code>, <code>.strip()</code>, <code>.split()</code>, <code>.join()</code>, <code>.find()</code>, and <code>.replace()</code> are powerful tools for text processing.</li> <li><code>.startswith()</code> and <code>.endswith()</code> check prefixes and suffixes.</li> <li>Use f-strings (<code>f\"Hello {name}\"</code>) or the <code>.format()</code> method for clean string formatting.</li> <li>Escape characters (<code>\\n</code>, <code>\\t</code>, <code>\\\\</code>) insert special characters. Raw strings (<code>r\"...\"</code>) disable escaping.</li> <li>Multiline strings use triple quotes and preserve line breaks.</li> <li>String iteration with <code>for</code> loops lets you process one character at a time.</li> <li>The <code>in</code> operator checks if a substring exists within a string.</li> <li>String comparison is case-sensitive and uses Unicode values for ordering.</li> <li>Validation methods (<code>.isalpha()</code>, <code>.isdigit()</code>, etc.) check string content.</li> <li><code>ord()</code> and <code>chr()</code> convert between characters and Unicode numbers.</li> <li>Reverse a string with the slice <code>[::-1]</code>.</li> </ul> Check Your Understanding: What does <code>'hello world'[6:]</code> return? <p>It returns <code>\"world\"</code>. The slice starts at index 6 (the <code>'w'</code>) and goes to the end of the string. Remember: <code>'h'</code> is index 0, <code>'e'</code> is 1, <code>'l'</code> is 2, <code>'l'</code> is 3, <code>'o'</code> is 4, <code>' '</code> is 5, and <code>'w'</code> is 6.</p> Check Your Understanding: Why does <code>my_string[0] = 'X'</code> cause an error? <p>Because strings are immutable in Python. You cannot change individual characters of a string. Instead, you'd create a new string: <code>my_string = 'X' + my_string[1:]</code>. This builds a brand-new string using the character <code>'X'</code> followed by everything from index 1 onward in the original string.</p> Check Your Understanding: What's the difference between <code>'Hello'.find('lo')</code> and <code>'lo' in 'Hello'</code>? <p><code>.find('lo')</code> returns the index where the substring starts (in this case, <code>3</code>), or <code>-1</code> if it's not found. The <code>in</code> operator returns a boolean (<code>True</code> or <code>False</code>). Use <code>.find()</code> when you need to know where something is. Use <code>in</code> when you just need to know if it's there.</p>"},{"location":"chapters/06-functions-and-modular-design/","title":"Functions and Modular Design","text":""},{"location":"chapters/06-functions-and-modular-design/#functions-and-modular-design","title":"Functions and Modular Design","text":""},{"location":"chapters/06-functions-and-modular-design/#summary","title":"Summary","text":"<p>This chapter introduces functions as the primary tool for organizing and reusing code. Students will learn to define functions with parameters and return values, understand variable scope (local vs global), use default and keyword arguments, and write documentation with docstrings. The chapter emphasizes modular design principles that lead to well-structured, maintainable programs.</p>"},{"location":"chapters/06-functions-and-modular-design/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 17 concepts from the learning graph:</p> <ol> <li>Functions</li> <li>Function Definition</li> <li>Function Call</li> <li>Parameters</li> <li>Arguments</li> <li>Return Statement</li> <li>Return Values</li> <li>None Type</li> <li>Default Parameters</li> <li>Keyword Arguments</li> <li>Positional Arguments</li> <li>Multiple Return Values</li> <li>Variable Scope</li> <li>Local Variables</li> <li>Global Variables</li> <li>Global Keyword</li> <li>Docstrings</li> </ol>"},{"location":"chapters/06-functions-and-modular-design/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 1: Introduction to Computer Science</li> <li>Chapter 2: Python Fundamentals</li> <li>Chapter 4: Control Flow</li> <li>Chapter 5: Working with Strings</li> </ul> <p>Monty says: Let's code this!</p> <p> Welcome back, coders! This chapter is a huge milestone. You're about to learn about functions \u2014 the single most important tool for writing clean, organized, reusable code. Once you master functions, you'll never look at programming the same way again. Let's do this!</p>"},{"location":"chapters/06-functions-and-modular-design/#what-are-functions","title":"What Are Functions?","text":"<p>Imagine you're baking cookies. Every time you want cookies, you don't reinvent the recipe from scratch. You follow the same set of steps: preheat the oven, mix the ingredients, scoop the dough, bake for 12 minutes. That recipe is a set of reusable instructions you can follow again and again.</p> <p>A function in Python works the same way. It's a named block of code that performs a specific task. You write it once, and then you can use it as many times as you want \u2014 no copy-pasting needed. Functions are the recipe cards of programming.</p> <p>You've actually been using functions since Chapter 2 without realizing it. Every time you wrote <code>print(\"Hello!\")</code> or <code>len(\"Python\")</code> or <code>input(\"What's your name? \")</code>, you were calling a function that someone else already wrote for you. Now it's time to write your own.</p> <p>Why do functions matter? Here are the big reasons:</p> <ul> <li>Reusability \u2014 Write code once, use it everywhere</li> <li>Organization \u2014 Break big programs into smaller, manageable pieces</li> <li>Readability \u2014 Give chunks of code meaningful names so others (and future you) can understand them</li> <li>Debugging \u2014 When something breaks, you only need to fix it in one place</li> <li>Collaboration \u2014 Different team members can work on different functions</li> </ul> <p>In short, functions turn spaghetti code into a well-organized recipe book.</p>"},{"location":"chapters/06-functions-and-modular-design/#diagram-function-anatomy","title":"Diagram: Function Anatomy","text":"Function Anatomy Interactive Diagram <p>Type: diagram sim-id: function-anatomy Library: p5.js Status: Specified</p> <p>Bloom Level: Remember (L1) Bloom Verb: identify, label</p> <p>Learning Objective: Students will be able to identify the parts of a Python function definition \u2014 the <code>def</code> keyword, function name, parameters, colon, body, and return statement \u2014 and describe the purpose of each.</p> <p>Purpose: An interactive labeled diagram of a Python function that highlights each part when the student hovers over it, showing the name and purpose of each syntactic element.</p> <p>Layout: - Center of canvas: A large, syntax-highlighted Python function displayed as styled text: </p><pre><code>def greet(name):\n    \"\"\"Say hello to someone.\"\"\"\n    message = \"Hello, \" + name + \"!\"\n    return message\n</code></pre> - Each part of the function has an invisible hover zone - A tooltip panel on the right side shows descriptions<p></p> <p>Hover zones and descriptions:</p> <ol> <li><code>def</code> keyword \u2014 \"The def keyword tells Python you're defining a new function.\"</li> <li><code>greet</code> (function name) \u2014 \"The function's name. You'll use this name to call the function later.\"</li> <li><code>(name)</code> (parameter) \u2014 \"Parameters are placeholders for data the function will receive. They go inside parentheses.\"</li> <li><code>:</code> (colon) \u2014 \"The colon marks the beginning of the function body. Everything indented below is part of the function.\"</li> <li><code>\"\"\"Say hello to someone.\"\"\"</code> (docstring) \u2014 \"A docstring describes what the function does. It's the first line inside the function, wrapped in triple quotes.\"</li> <li><code>message = \"Hello, \" + name + \"!\"</code> (body) \u2014 \"The body is where the function does its work. All body lines must be indented.\"</li> <li><code>return message</code> (return statement) \u2014 \"The return statement sends a value back to whoever called the function.\"</li> </ol> <p>Interactive elements: - Hover over any part to highlight it with a colored background and show its description in the tooltip panel - Click any part to \"lock\" the tooltip so it stays visible while you read it - A \"Show All Labels\" button draws arrows from each part to a labeled list</p> <p>Color scheme: - <code>def</code> keyword: blue - Function name: green - Parameters: orange - Colon: gray - Docstring: purple - Body: default/white - Return statement: red</p> <p>Visual style: Monospaced font for code, clean modern tooltip panel Responsive: Font size scales with canvas width; tooltip repositions on smaller screens</p> <p>Instructional Rationale: Hover-to-reveal supports the Remember level by letting students explore each syntactic element at their own pace. The visual mapping between syntax and purpose builds a mental model of function structure before students write their own.</p>"},{"location":"chapters/06-functions-and-modular-design/#defining-your-first-function","title":"Defining Your First Function","text":"<p>Let's write our first function. A function definition is the code that creates a new function. It starts with the <code>def</code> keyword, followed by the function's name, parentheses, and a colon. The function's code goes on the next lines, indented by four spaces.</p> <pre><code>def say_hello():\n    print(\"Hello, world!\")\n</code></pre> <p>That's it! You just defined a function called <code>say_hello</code>. But here's the important part: defining a function doesn't run it. It's like writing a recipe in your recipe book \u2014 the cookies don't magically appear until you actually follow the recipe.</p> <p>To run the function, you need to make a function call:</p> <pre><code>say_hello()\n</code></pre> <p>When Python sees this line, it jumps up to where you defined <code>say_hello</code>, runs the code inside it, then comes back to where it left off. You can call the same function as many times as you want:</p> <pre><code>say_hello()  # prints \"Hello, world!\"\nsay_hello()  # prints \"Hello, world!\" again\nsay_hello()  # and again!\n</code></pre> <p>Here's the basic pattern for defining and calling a function:</p> Step What You Write What It Does 1. Define <code>def function_name():</code> Creates the function (stores the recipe) 2. Write body Indented code below <code>def</code> Describes what the function does 3. Call <code>function_name()</code> Runs the function (follows the recipe)"},{"location":"chapters/06-functions-and-modular-design/#naming-your-functions","title":"Naming Your Functions","text":"<p>Function names follow the same rules as variable names:</p> <ul> <li>Use lowercase letters and underscores (snake_case): <code>calculate_area</code>, <code>get_user_input</code></li> <li>Start with a letter or underscore, not a number</li> <li>Make names descriptive \u2014 <code>calculate_tax</code> is better than <code>ct</code></li> <li>Use verbs since functions do things: <code>greet_user</code>, <code>find_maximum</code>, <code>print_report</code></li> </ul>"},{"location":"chapters/06-functions-and-modular-design/#parameters-and-arguments","title":"Parameters and Arguments","text":"<p>A function that does the exact same thing every time is useful, but limited. What if you want to customize what it does? That's where parameters come in.</p> <p>Parameters are variables listed inside the parentheses of a function definition. They act as placeholders for data that will be provided when the function is called. Think of them like blank lines on a form \u2014 the function says \"I need a name here,\" and you fill it in when you use the function.</p> <pre><code>def greet(name):\n    print(f\"Hello, {name}!\")\n</code></pre> <p>In this example, <code>name</code> is a parameter. When you call the function, you provide a value for that parameter \u2014 and that value is called an argument:</p> <pre><code>greet(\"Alice\")    # \"Alice\" is the argument\ngreet(\"Bob\")      # \"Bob\" is the argument\ngreet(\"Monty\")    # \"Monty\" is the argument\n</code></pre> <p>Output:</p> <pre><code>Hello, Alice!\nHello, Bob!\nHello, Monty!\n</code></pre> <p>Here's a quick way to remember the difference:</p> Term Where It Appears What It Is Parameter In the function definition The placeholder (the blank line on the form) Argument In the function call The actual value you fill in <p>You can have multiple parameters \u2014 just separate them with commas:</p> <pre><code>def add(a, b):\n    result = a + b\n    print(f\"{a} + {b} = {result}\")\n\nadd(3, 5)     # prints \"3 + 5 = 8\"\nadd(10, 20)   # prints \"10 + 20 = 30\"\n</code></pre> <p>Monty says: You've got this!</p> <p> Think of a function like a vending machine. The parameters are the slots where you insert your selections (like choosing a snack and a drink). The arguments are the actual buttons you press. The function's body is all the machinery inside, and the output is the snack that drops out. Same machine, different snacks depending on what you press!</p>"},{"location":"chapters/06-functions-and-modular-design/#return-values-getting-results-back","title":"Return Values: Getting Results Back","text":"<p>So far, our functions have printed things. But what if you want a function to calculate a result and give it back to you so you can use it later? That's what the return statement does.</p> <p>The <code>return</code> keyword sends a value \u2014 called a return value \u2014 back to the code that called the function. It's like asking a friend to go check the temperature outside. You don't want them to just shout the temperature into the void \u2014 you want them to come back and tell you so you can decide whether to wear a jacket.</p> <pre><code>def add(a, b):\n    return a + b\n\nresult = add(3, 5)\nprint(result)       # prints 8\n</code></pre> <p>Notice the difference from before: instead of <code>print</code> inside the function, we use <code>return</code>. The function sends the value back, and we can store it in a variable, use it in another calculation, or do whatever we want with it.</p> <pre><code>def square(n):\n    return n * n\n\narea = square(7)           # area is now 49\ndouble_area = square(7) * 2  # double_area is 98\nprint(f\"Area: {area}\")\nprint(f\"Double: {double_area}\")\n</code></pre> <p>Here are some key facts about <code>return</code>:</p> <ul> <li>A function can have multiple <code>return</code> statements (often inside <code>if/else</code> blocks), but only one will execute</li> <li>Once <code>return</code> runs, the function immediately stops \u2014 any code after the <code>return</code> line won't execute</li> <li>A function without a <code>return</code> statement automatically returns a special value called <code>None</code></li> </ul>"},{"location":"chapters/06-functions-and-modular-design/#the-none-type","title":"The None Type","text":"<p>What happens when a function doesn't explicitly return anything? Python gives it a return value of <code>None</code>. None is a special Python value \u2014 it represents \"nothing\" or \"no value.\" Its type is the None type (technically <code>NoneType</code>).</p> <pre><code>def say_hello():\n    print(\"Hello!\")\n\nresult = say_hello()\nprint(result)       # prints: None\nprint(type(result)) # prints: &lt;class 'NoneType'&gt;\n</code></pre> <p><code>None</code> isn't the same as zero, an empty string, or <code>False</code>. It's its own thing \u2014 it means \"this variable doesn't hold any meaningful value.\" You'll see <code>None</code> come up often when debugging, so it's good to know what it means.</p>"},{"location":"chapters/06-functions-and-modular-design/#diagram-function-call-flow","title":"Diagram: Function Call Flow","text":"Function Call Flow MicroSim <p>Type: microsim sim-id: function-call-flow Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: trace, explain</p> <p>Learning Objective: Students will be able to trace the flow of execution when a function is called, including how arguments are passed, how the function body runs, and how the return value flows back to the caller.</p> <p>Purpose: An animated step-through showing a function call, visualizing the jump from caller code to the function definition and back, with arguments flowing in and the return value flowing out.</p> <p>Canvas layout: - Left side: \"Caller Code\" panel showing: </p><pre><code>x = add(3, 5)\nprint(x)\n</code></pre> - Right side: \"Function Definition\" panel showing: <pre><code>def add(a, b):\n    return a + b\n</code></pre> - Between the panels: animated arrows and value \"bubbles\" showing data flow - Bottom: A step-by-step narration bar explaining what's happening<p></p> <p>Animation steps:</p> <ol> <li>Highlight <code>add(3, 5)</code> in the caller \u2014 Narration: \"Python sees a function call: add(3, 5)\"</li> <li>Animate \"3\" bubble flowing from caller to parameter <code>a</code> \u2014 Narration: \"Argument 3 is assigned to parameter a\"</li> <li>Animate \"5\" bubble flowing from caller to parameter <code>b</code> \u2014 Narration: \"Argument 5 is assigned to parameter b\"</li> <li>Highlight <code>return a + b</code> in the function \u2014 Narration: \"Python evaluates a + b = 3 + 5 = 8\"</li> <li>Animate \"8\" bubble flowing back from function to <code>x =</code> \u2014 Narration: \"The return value 8 is sent back and stored in x\"</li> <li>Highlight <code>print(x)</code> \u2014 Narration: \"Python prints x, which is 8\"</li> </ol> <p>Interactive controls: - \"Step\" button: Advance one step at a time - \"Auto Play\" button: Animate all steps with a 1.5-second delay - \"Reset\" button: Return to starting state - Speed slider to adjust animation pace</p> <p>Visual style: - Code panels use monospaced font with syntax highlighting - Value \"bubbles\" are colored circles with the value displayed inside - Active lines have a yellow highlight - Arrows animate smoothly with easing</p> <p>Responsive: Panels stack vertically on narrow screens</p> <p>Instructional Rationale: Step-through animation supports the Understand level by making the invisible execution flow visible. Students often struggle with the concept of \"jumping\" to a function and back \u2014 this animation makes the jump explicit. Value bubbles show how arguments become parameters and how return values flow back.</p>"},{"location":"chapters/06-functions-and-modular-design/#positional-and-keyword-arguments","title":"Positional and Keyword Arguments","text":"<p>When you call a function with multiple parameters, there are two ways to pass the arguments.</p> <p>Positional arguments are the default. The first argument goes to the first parameter, the second argument goes to the second parameter, and so on. Order matters!</p> <pre><code>def describe_pet(animal, name):\n    print(f\"I have a {animal} named {name}.\")\n\ndescribe_pet(\"cat\", \"Whiskers\")   # I have a cat named Whiskers.\ndescribe_pet(\"Whiskers\", \"cat\")   # I have a Whiskers named cat. (Oops!)\n</code></pre> <p>See what happened in the second call? We swapped the order, so the arguments got matched to the wrong parameters. With positional arguments, you have to remember which order to use.</p> <p>Keyword arguments let you specify exactly which parameter gets which value by using the parameter's name:</p> <pre><code>describe_pet(animal=\"cat\", name=\"Whiskers\")   # Correct!\ndescribe_pet(name=\"Whiskers\", animal=\"cat\")   # Also correct!\n</code></pre> <p>With keyword arguments, order doesn't matter \u2014 Python matches each argument to the right parameter by name. This makes your code clearer, especially when a function has many parameters.</p> <p>You can even mix positional and keyword arguments, but there's one rule: positional arguments must come first.</p> <pre><code>describe_pet(\"cat\", name=\"Whiskers\")  # OK! positional first, keyword second\ndescribe_pet(animal=\"cat\", \"Whiskers\")  # ERROR! keyword before positional\n</code></pre> Argument Type How It Works Order Matters? Example Positional Matched by position (1st, 2nd, 3rd...) Yes <code>greet(\"Alice\", 16)</code> Keyword Matched by parameter name No <code>greet(name=\"Alice\", age=16)</code> Mixed Positional first, then keyword Partially <code>greet(\"Alice\", age=16)</code> <p>Monty says: Watch out!</p> <p> A common mistake is putting keyword arguments before positional ones. Python will throw a <code>SyntaxError</code> if you try this. Always put positional arguments first, keyword arguments second!</p>"},{"location":"chapters/06-functions-and-modular-design/#default-parameters","title":"Default Parameters","text":"<p>Sometimes you want a parameter to have a fallback value in case the caller doesn't provide one. That's what default parameters do. You set a default value in the function definition using <code>=</code>:</p> <pre><code>def greet(name, greeting=\"Hello\"):\n    print(f\"{greeting}, {name}!\")\n\ngreet(\"Alice\")              # prints \"Hello, Alice!\" (uses default)\ngreet(\"Bob\", \"Hey there\")   # prints \"Hey there, Bob!\" (overrides default)\n</code></pre> <p>The parameter <code>greeting</code> has a default value of <code>\"Hello\"</code>. If you call <code>greet</code> with only one argument, <code>greeting</code> automatically becomes <code>\"Hello\"</code>. If you provide a second argument, it replaces the default.</p> <p>Default parameters are incredibly handy:</p> <pre><code>def calculate_tip(bill, tip_rate=0.18):\n    \"\"\"Calculate the tip amount for a restaurant bill.\"\"\"\n    return bill * tip_rate\n\nprint(calculate_tip(50))          # $9.00 (18% default)\nprint(calculate_tip(50, 0.20))    # $10.00 (20% custom)\nprint(calculate_tip(50, 0.15))    # $7.50 (15% custom)\n</code></pre> <p>There's one important rule: parameters with default values must come after parameters without defaults. Otherwise Python gets confused about which argument matches which parameter.</p> <pre><code>def greet(greeting=\"Hello\", name):  # ERROR! Default before non-default\n    print(f\"{greeting}, {name}!\")\n\ndef greet(name, greeting=\"Hello\"):  # Correct! Non-default first\n    print(f\"{greeting}, {name}!\")\n</code></pre>"},{"location":"chapters/06-functions-and-modular-design/#multiple-return-values","title":"Multiple Return Values","text":"<p>Here's a Python superpower: a single function can return multiple return values at once. You do this by separating the values with commas after <code>return</code>. Under the hood, Python packs them into a tuple (which you'll learn more about in Chapter 10).</p> <pre><code>def get_min_max(numbers):\n    return min(numbers), max(numbers)\n\nlowest, highest = get_min_max([4, 7, 2, 9, 1])\nprint(f\"Lowest: {lowest}\")    # Lowest: 1\nprint(f\"Highest: {highest}\")  # Highest: 9\n</code></pre> <p>This is really useful when a function needs to compute several related pieces of information:</p> <pre><code>def analyze_scores(scores):\n    total = sum(scores)\n    average = total / len(scores)\n    highest = max(scores)\n    lowest = min(scores)\n    return average, highest, lowest\n\navg, high, low = analyze_scores([85, 92, 78, 95, 88])\nprint(f\"Average: {avg}\")    # Average: 87.6\nprint(f\"Highest: {high}\")   # Highest: 95\nprint(f\"Lowest: {low}\")     # Lowest: 78\n</code></pre> <p>The left side of the assignment uses unpacking \u2014 each variable on the left matches up with one returned value on the right. If you use the wrong number of variables, Python will raise an error.</p>"},{"location":"chapters/06-functions-and-modular-design/#diagram-arguments-vs-parameters","title":"Diagram: Arguments vs Parameters","text":"Arguments vs Parameters Interactive Comparison <p>Type: diagram sim-id: args-vs-params Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: differentiate, classify</p> <p>Learning Objective: Students will be able to distinguish between parameters (in the definition) and arguments (in the call), and between positional, keyword, and default argument types.</p> <p>Purpose: An interactive side-by-side display that shows a function definition and multiple function calls, with color-coded connections between arguments and their corresponding parameters.</p> <p>Canvas layout: - Top half: Function definition displayed prominently: </p><pre><code>def make_profile(name, age, city=\"Unknown\"):\n    return f\"{name}, age {age}, from {city}\"\n</code></pre> - Each parameter is color-coded: <code>name</code> (blue), <code>age</code> (green), <code>city</code> (orange) - Bottom half: Three function call examples the student can switch between using tabs:   - Tab 1 \"Positional\": <code>make_profile(\"Alice\", 16, \"Austin\")</code>   - Tab 2 \"Keyword\": <code>make_profile(age=16, name=\"Alice\", city=\"Austin\")</code>   - Tab 3 \"Default Used\": <code>make_profile(\"Alice\", 16)</code><p></p> <p>Interactive elements: - Click a tab to show a different function call style - Animated lines connect each argument to its matched parameter, using the parameter's color - Hover over any argument to highlight both the argument and the parameter it maps to - For Tab 3, the default value for <code>city</code> glows to show it's being used automatically - Below each call: text showing the return value output</p> <p>Visual style: - Monospaced font for code - Smooth curved connecting lines between arguments and parameters - Subtle animation when switching tabs</p> <p>Color scheme: - <code>name</code> parameter/argument: blue - <code>age</code> parameter/argument: green - <code>city</code> parameter/argument: orange - Default value indicator: dashed orange border</p> <p>Responsive: Layout stacks vertically on narrow screens</p> <p>Instructional Rationale: Color-coded matching lines make the abstract mapping between arguments and parameters concrete and visible. Showing three different calling styles in tabs lets students compare positional, keyword, and default behaviors side by side. This supports the Understand level by helping students differentiate between these closely related concepts.</p>"},{"location":"chapters/06-functions-and-modular-design/#variable-scope-who-can-see-what","title":"Variable Scope: Who Can See What?","text":"<p>Here's a concept that trips up a lot of new programmers, so pay close attention. Variable scope determines where in your code a variable can be accessed. Not every variable is available everywhere.</p>"},{"location":"chapters/06-functions-and-modular-design/#local-variables","title":"Local Variables","text":"<p>A local variable is a variable created inside a function. It only exists while the function is running, and it can only be used inside that function. Once the function finishes, the local variable vanishes like a Snapchat message.</p> <pre><code>def calculate_area(length, width):\n    area = length * width   # 'area' is a local variable\n    return area\n\ncalculate_area(5, 3)\nprint(area)   # ERROR! 'area' doesn't exist outside the function\n</code></pre> <p>The variable <code>area</code> was born inside <code>calculate_area</code> and dies when the function ends. The rest of your program has no idea it ever existed.</p> <p>Parameters are also local variables. In the example above, <code>length</code> and <code>width</code> only exist inside <code>calculate_area</code>.</p>"},{"location":"chapters/06-functions-and-modular-design/#global-variables","title":"Global Variables","text":"<p>A global variable is a variable created outside of any function, in the main body of your program. It can be read from anywhere \u2014 inside functions, outside functions, everywhere.</p> <pre><code>school_name = \"Westside High\"   # global variable\n\ndef print_welcome():\n    print(f\"Welcome to {school_name}!\")  # can READ the global variable\n\nprint_welcome()   # prints \"Welcome to Westside High!\"\n</code></pre> <p>But here's the catch: you can read a global variable from inside a function, but you cannot change it without special permission. If you try to assign a new value to it inside a function, Python creates a new local variable with the same name instead:</p> <pre><code>count = 0   # global variable\n\ndef increment():\n    count = count + 1   # ERROR! Python thinks 'count' is local\n                         # but it hasn't been assigned yet\n\nincrement()\n</code></pre> <p>This error happens because Python sees <code>count =</code> on the left side and assumes you're trying to create a local variable called <code>count</code>. But you're also trying to use <code>count</code> on the right side before it's been created locally. Confusing? It's one of Python's quirks.</p>"},{"location":"chapters/06-functions-and-modular-design/#the-global-keyword","title":"The Global Keyword","text":"<p>If you truly need to modify a global variable from inside a function, you must use the global keyword to tell Python \"I mean the global one, not a new local one\":</p> <pre><code>count = 0   # global variable\n\ndef increment():\n    global count         # \"I want the GLOBAL count\"\n    count = count + 1    # Now this works!\n\nincrement()\nincrement()\nincrement()\nprint(count)   # prints 3\n</code></pre> <p>However, using <code>global</code> is generally considered a bad habit. It makes your code harder to understand and debug because any function could change any variable at any time. It's like giving everyone in school the keys to the janitor's closet \u2014 technically possible, but things get messy fast.</p> <p>Best practice: Instead of using global variables, pass values into functions as parameters and get results back using <code>return</code>. This keeps your functions self-contained and predictable.</p> <p>Here's a summary of scope rules:</p> Variable Type Created Where? Accessible Where? Lifespan Local Inside a function Only inside that function While the function runs Global Outside all functions Readable everywhere; writable only with <code>global</code> keyword Entire program Parameter In the function definition Only inside that function (acts like a local variable) While the function runs <p>Monty says: Let's debug this together!</p> <p> Think of scope like rooms in a house. A local variable is like a note pinned to the fridge in the kitchen \u2014 only people in the kitchen can see it. A global variable is like a message on the mailbox outside \u2014 everyone can read it. The <code>global</code> keyword is like giving someone the key to the mailbox so they can change the message.</p>"},{"location":"chapters/06-functions-and-modular-design/#diagram-variable-scope-visualizer","title":"Diagram: Variable Scope Visualizer","text":"Variable Scope Visualizer MicroSim <p>Type: microsim sim-id: variable-scope-visualizer Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: demonstrate, predict</p> <p>Learning Objective: Students will be able to predict the value of variables at different points in a program by understanding the rules of local and global variable scope.</p> <p>Purpose: An interactive code execution visualizer that shows which variables exist (and their values) at each step of a program containing both global variables and function calls with local variables.</p> <p>Canvas layout: - Left panel: A short Python program displayed with line numbers: </p><pre><code>x = 10              # Line 1\ny = 20              # Line 2\n\ndef double(n):       # Line 4\n    result = n * 2   # Line 5\n    return result    # Line 6\n\nz = double(x)        # Line 8\nprint(x, y, z)       # Line 9\n</code></pre> - Right panel: \"Variable Scope\" display with two sections:   - \"Global Scope\" box (blue border) showing global variables and their current values   - \"Local Scope: double()\" box (orange border) that appears/disappears when the function is active<p></p> <p>Animation steps:</p> <ol> <li>Line 1 executes \u2014 Global scope shows: <code>x = 10</code></li> <li>Line 2 executes \u2014 Global scope shows: <code>x = 10, y = 20</code></li> <li>Line 8 calls <code>double(x)</code> \u2014 Local scope box appears: <code>n = 10</code></li> <li>Line 5 executes \u2014 Local scope shows: <code>n = 10, result = 20</code></li> <li>Line 6 returns \u2014 Local scope box disappears (variables gone!), Global scope adds: <code>z = 20</code></li> <li>Line 9 prints \u2014 Output shown: <code>10 20 20</code></li> </ol> <p>Interactive controls: - \"Step Forward\" and \"Step Back\" buttons - \"Auto Play\" button with speed slider - \"Reset\" button - Dropdown to choose from 3 different code examples:   - Example 1: Basic scope (shown above)   - Example 2: Name collision (global and local variable with the same name)   - Example 3: Using <code>global</code> keyword</p> <p>Visual elements: - Current executing line highlighted in yellow - Global scope box always visible - Local scope box fades in when function is entered, fades out when function exits - Variables appear with a brief \"pop\" animation when created - Variables fade out and \"disappear\" when their scope ends</p> <p>Color scheme: - Global scope border: blue - Local scope border: orange - Current line highlight: yellow - New variable animation: green flash</p> <p>Responsive: Panels stack vertically on narrow screens</p> <p>Instructional Rationale: Step-by-step execution with a visible scope display directly addresses the Apply level by requiring students to predict outcomes before stepping forward. The appearing/disappearing local scope box vividly demonstrates that local variables have a limited lifespan. Multiple code examples let students explore edge cases like name collisions and the global keyword.</p>"},{"location":"chapters/06-functions-and-modular-design/#docstrings-documenting-your-functions","title":"Docstrings: Documenting Your Functions","text":"<p>As your programs grow, you'll write dozens (or hundreds) of functions. A month from now, will you remember what each one does? What about your teammates? That's why good programmers document their functions with docstrings.</p> <p>A docstring (short for \"documentation string\") is a string that appears as the very first line inside a function. It describes what the function does, what parameters it expects, and what it returns. Docstrings are wrapped in triple quotes (<code>\"\"\"...\"\"\"</code>).</p> <pre><code>def calculate_bmi(weight_kg, height_m):\n    \"\"\"Calculate Body Mass Index (BMI).\n\n    Parameters:\n        weight_kg: Weight in kilograms\n        height_m: Height in meters\n\n    Returns:\n        The BMI value as a float\n    \"\"\"\n    return weight_kg / (height_m ** 2)\n</code></pre> <p>Docstrings aren't just comments \u2014 Python actually stores them and makes them available through the built-in <code>help()</code> function:</p> <pre><code>help(calculate_bmi)\n</code></pre> <p>Output:</p> <pre><code>Help on function calculate_bmi:\n\ncalculate_bmi(weight_kg, height_m)\n    Calculate Body Mass Index (BMI).\n\n    Parameters:\n        weight_kg: Weight in kilograms\n        height_m: Height in meters\n\n    Returns:\n        The BMI value as a float\n</code></pre> <p>Here are some docstring best practices:</p> <ul> <li>First line: A brief, one-sentence summary of what the function does</li> <li>Parameters section: List each parameter and what it represents</li> <li>Returns section: Describe what the function returns</li> <li>Keep it honest: If the function changes, update the docstring too!</li> </ul> <p>Even a simple one-liner helps:</p> <pre><code>def square(n):\n    \"\"\"Return the square of n.\"\"\"\n    return n * n\n</code></pre> <p>Monty says: Let's debug this together!</p> <p> Here's a tip from the pros: write your docstring before you write the function body. It forces you to think about what the function should do before you get lost in the details of how it does it. Future you will thank present you!</p>"},{"location":"chapters/06-functions-and-modular-design/#modular-design-putting-it-all-together","title":"Modular Design: Putting It All Together","text":"<p>Now that you know how to write functions, let's talk about when and why to use them. The philosophy of breaking a program into small, focused functions is called modular design.</p> <p>Imagine you're building a calculator app. You could write the entire thing as one giant block of code \u2014 but that would be messy, hard to read, and a nightmare to debug. Instead, you break it into modules (functions), each handling one task:</p> <pre><code>def get_numbers():\n    \"\"\"Get two numbers from the user.\"\"\"\n    a = float(input(\"Enter first number: \"))\n    b = float(input(\"Enter second number: \"))\n    return a, b\n\ndef add(a, b):\n    \"\"\"Return the sum of a and b.\"\"\"\n    return a + b\n\ndef subtract(a, b):\n    \"\"\"Return the difference of a and b.\"\"\"\n    return a - b\n\ndef display_result(operation, result):\n    \"\"\"Display the result of a calculation.\"\"\"\n    print(f\"The result of {operation} is: {result}\")\n\n# Main program\nx, y = get_numbers()\ntotal = add(x, y)\ndisplay_result(\"addition\", total)\n</code></pre> <p>Each function does one thing and does it well. If the <code>add</code> function has a bug, you know exactly where to look. If you want to add multiplication, you just write a new function \u2014 you don't have to touch the existing code.</p> <p>Here are the principles of good modular design:</p> <ul> <li>Single responsibility: Each function should do one thing</li> <li>Descriptive names: A function's name should tell you what it does</li> <li>Short and sweet: If a function is longer than 20-30 lines, consider breaking it up</li> <li>Documented: Every function should have a docstring</li> <li>Self-contained: Functions should rely on their parameters, not global variables</li> </ul>"},{"location":"chapters/06-functions-and-modular-design/#diagram-modular-design-builder","title":"Diagram: Modular Design Builder","text":"Modular Design Builder MicroSim <p>Type: microsim sim-id: modular-design-builder Library: p5.js Status: Specified</p> <p>Bloom Level: Analyze (L4) Bloom Verb: organize, deconstruct</p> <p>Learning Objective: Students will be able to break a monolithic program into modular functions by identifying logical units of work and creating appropriate function boundaries.</p> <p>Purpose: An interactive exercise where students are given a block of sequential code and must drag-and-drop code lines into function groups, naming each function and connecting them with a call graph.</p> <p>Canvas layout: - Left panel: \"Original Code\" \u2014 a 12-line sequential program displayed as movable code blocks: </p><pre><code>1. name = input(\"Name: \")\n2. age = int(input(\"Age: \"))\n3. greeting = \"Hello, \" + name\n4. print(greeting)\n5. birth_year = 2026 - age\n6. print(\"Born in: \" + str(birth_year))\n7. if age &gt;= 16:\n8.     print(\"You can drive!\")\n9. else:\n10.    print(\"Not old enough to drive.\")\n11. print(\"Thanks for using our app!\")\n12. print(\"Goodbye, \" + name)\n</code></pre> - Right panel: \"Modular Version\" \u2014 empty function containers (rounded rectangles) that students can drag code lines into - Bottom: Three pre-labeled empty function boxes: <code>get_info()</code>, <code>check_driving()</code>, <code>show_farewell()</code> - A \"Check My Answer\" button that evaluates the student's grouping<p></p> <p>Interactive elements: - Drag code lines from the left panel into the function boxes on the right - Each function box shows a header where the student types a function name (pre-populated with suggestions) - Lines snap into place inside a function box - A \"Show Solution\" button reveals one good way to modularize the code - \"Check My Answer\" provides feedback: \"Lines 1-2 make sense in get_info()\" etc. - A \"Run Both\" button that shows both versions produce the same output</p> <p>Feedback: - Green check for correctly grouped lines - Orange suggestion for lines that could reasonably go in multiple functions - Red X for clearly misplaced lines (e.g., putting the farewell message in get_info)</p> <p>Visual style: Code blocks are rounded rectangles with monospaced text; function containers have colored borders (blue, green, orange) Responsive: Panels stack vertically on small screens</p> <p>Instructional Rationale: Drag-and-drop grouping supports the Analyze level by requiring students to examine relationships between code lines and decide which belong together based on their purpose. This active reorganization task builds intuition for modular design principles that passive reading cannot achieve.</p>"},{"location":"chapters/06-functions-and-modular-design/#common-patterns-and-best-practices","title":"Common Patterns and Best Practices","text":"<p>Let's look at some patterns you'll see again and again in well-written Python functions.</p>"},{"location":"chapters/06-functions-and-modular-design/#pattern-1-input-validation","title":"Pattern 1: Input Validation","text":"<p>Functions can check that their arguments make sense before doing any work:</p> <pre><code>def calculate_average(scores):\n    \"\"\"Calculate the average of a list of scores.\"\"\"\n    if len(scores) == 0:\n        return None   # Can't average an empty list!\n    return sum(scores) / len(scores)\n</code></pre>"},{"location":"chapters/06-functions-and-modular-design/#pattern-2-multiple-return-paths","title":"Pattern 2: Multiple Return Paths","text":"<p>Use <code>if/else</code> to return different values depending on conditions:</p> <pre><code>def letter_grade(score):\n    \"\"\"Convert a numeric score to a letter grade.\"\"\"\n    if score &gt;= 90:\n        return \"A\"\n    elif score &gt;= 80:\n        return \"B\"\n    elif score &gt;= 70:\n        return \"C\"\n    elif score &gt;= 60:\n        return \"D\"\n    else:\n        return \"F\"\n</code></pre>"},{"location":"chapters/06-functions-and-modular-design/#pattern-3-building-results","title":"Pattern 3: Building Results","text":"<p>Use a local variable to accumulate a result, then return it:</p> <pre><code>def count_vowels(text):\n    \"\"\"Count the number of vowels in a string.\"\"\"\n    count = 0\n    for char in text.lower():\n        if char in \"aeiou\":\n            count += 1\n    return count\n\nprint(count_vowels(\"Hello World\"))  # prints 3\n</code></pre>"},{"location":"chapters/06-functions-and-modular-design/#pattern-4-functions-calling-functions","title":"Pattern 4: Functions Calling Functions","text":"<p>Functions can call other functions \u2014 this is where modular design really shines:</p> <pre><code>def is_passing(score):\n    \"\"\"Check if a score earns a passing grade.\"\"\"\n    grade = letter_grade(score)   # Calls the function we wrote earlier\n    return grade != \"F\"\n\nprint(is_passing(75))   # True\nprint(is_passing(55))   # False\n</code></pre>"},{"location":"chapters/06-functions-and-modular-design/#diagram-function-pattern-gallery","title":"Diagram: Function Pattern Gallery","text":"Function Pattern Gallery Interactive Reference <p>Type: infographic sim-id: function-pattern-gallery Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: implement, use</p> <p>Learning Objective: Students will be able to recognize and apply common function patterns (input validation, multiple returns, result accumulation, function composition) when writing their own programs.</p> <p>Purpose: A clickable gallery of four common function design patterns, each showing a code example with annotations explaining the pattern and when to use it.</p> <p>Canvas layout: - Grid of 4 cards (2x2), each representing a pattern:   - Card 1: \"Input Validation\" \u2014 check before compute   - Card 2: \"Multiple Return Paths\" \u2014 different results for different conditions   - Card 3: \"Result Accumulation\" \u2014 build up a value in a loop   - Card 4: \"Function Composition\" \u2014 functions calling functions</p> <p>Each card shows: - Pattern name (bold header) - A 4-6 line code example with syntax highlighting - A one-sentence description of when to use this pattern - An icon representing the pattern (shield for validation, fork for multiple paths, stack for accumulation, chain for composition)</p> <p>Interactive elements: - Click a card to expand it to full width, showing:   - The complete code example   - Line-by-line annotations   - A \"When to Use\" section with bullet points   - A \"Try It\" section with a small editable code area - Click again or click another card to collapse/switch</p> <p>Color scheme: - Validation: blue - Multiple returns: green - Accumulation: orange - Composition: purple</p> <p>Visual style: Card-based layout with rounded corners and subtle shadows Responsive: Cards stack into a single column on narrow screens</p> <p>Instructional Rationale: A gallery format supports the Apply level by presenting patterns as reusable templates. Students can browse, compare, and practice each pattern independently. The card-based format mirrors how developers use reference documentation in the real world.</p>"},{"location":"chapters/06-functions-and-modular-design/#putting-it-all-together-a-complete-example","title":"Putting It All Together: A Complete Example","text":"<p>Let's combine everything from this chapter into a complete program. We'll build a simple grade report generator:</p> <pre><code>def get_student_name():\n    \"\"\"Get the student's name from user input.\"\"\"\n    return input(\"Enter student name: \")\n\ndef get_scores():\n    \"\"\"Get a list of test scores from user input.\"\"\"\n    scores = []\n    while True:\n        entry = input(\"Enter a score (or 'done'): \")\n        if entry.lower() == \"done\":\n            break\n        scores.append(float(entry))\n    return scores\n\ndef calculate_stats(scores):\n    \"\"\"Calculate and return average, highest, and lowest scores.\"\"\"\n    if len(scores) == 0:\n        return 0, 0, 0\n    average = sum(scores) / len(scores)\n    highest = max(scores)\n    lowest = min(scores)\n    return average, highest, lowest\n\ndef letter_grade(score):\n    \"\"\"Convert a numeric score to a letter grade.\"\"\"\n    if score &gt;= 90:\n        return \"A\"\n    elif score &gt;= 80:\n        return \"B\"\n    elif score &gt;= 70:\n        return \"C\"\n    elif score &gt;= 60:\n        return \"D\"\n    else:\n        return \"F\"\n\ndef print_report(name, scores):\n    \"\"\"Print a formatted grade report for a student.\"\"\"\n    avg, high, low = calculate_stats(scores)\n    grade = letter_grade(avg)\n    print(f\"\\n--- Grade Report for {name} ---\")\n    print(f\"Scores: {scores}\")\n    print(f\"Average: {avg:.1f}\")\n    print(f\"Highest: {high}\")\n    print(f\"Lowest: {low}\")\n    print(f\"Letter Grade: {grade}\")\n\n# Main program\nstudent = get_student_name()\nstudent_scores = get_scores()\nprint_report(student, student_scores)\n</code></pre> <p>Notice how each function has a single job, a descriptive name, and a docstring. The main program at the bottom reads almost like plain English: get the name, get the scores, print the report. That's the beauty of modular design.</p> <p>Monty says: You've got this!</p> <p> Look at you, writing clean, modular, well-documented code with functions! You've leveled up from writing simple scripts to designing organized programs. That's a massive step forward. The skills you learned in this chapter \u2014 parameters, return values, scope, docstrings \u2014 will be the foundation for everything else in this course. Great work, coder!</p>"},{"location":"chapters/06-functions-and-modular-design/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>A function is a reusable block of code that performs a specific task. Define it with <code>def</code>, call it by name.</li> <li>Parameters are placeholders in the function definition; arguments are the actual values passed in the call.</li> <li>The return statement sends a value back to the caller. Without one, the function returns None.</li> <li>Positional arguments are matched by order; keyword arguments are matched by parameter name.</li> <li>Default parameters provide fallback values when arguments are omitted.</li> <li>A function can return multiple values separated by commas (packed as a tuple).</li> <li>Variable scope determines where a variable can be accessed: local variables live inside functions; global variables live outside.</li> <li>The global keyword lets a function modify a global variable \u2014 but avoid it when possible.</li> <li>Docstrings document what a function does, its parameters, and its return value.</li> <li>Good modular design means each function does one thing, has a clear name, and is self-contained.</li> </ul> Check Your Understanding: What is the difference between a parameter and an argument? <p>A parameter is a variable in the function definition \u2014 it's the placeholder. An argument is the actual value you pass when you call the function. For example, in <code>def greet(name):</code>, <code>name</code> is the parameter. In <code>greet(\"Alice\")</code>, <code>\"Alice\"</code> is the argument. Think of the parameter as a blank on a form, and the argument as what you write in that blank.</p> Check Your Understanding: What does a function return if it has no return statement? <p>It returns None. <code>None</code> is Python's special value meaning \"nothing\" or \"no value.\" Its type is <code>NoneType</code>. For example: </p><pre><code>def say_hi():\n    print(\"Hi!\")\n\nresult = say_hi()\nprint(result)  # Output: None\n</code></pre><p></p> Check Your Understanding: Why is using the <code>global</code> keyword generally discouraged? <p>Using <code>global</code> lets any function change variables that live outside of it, which makes your program harder to understand and debug. If multiple functions can modify the same global variable, it becomes difficult to track where changes happen. Best practice is to pass values into functions as parameters and use <code>return</code> to send results back. This keeps each function self-contained and predictable.</p>"},{"location":"chapters/07-higher-order-functions-and-recursion/","title":"Higher-Order Functions and Recursion","text":""},{"location":"chapters/07-higher-order-functions-and-recursion/#higher-order-functions-and-recursion","title":"Higher-Order Functions and Recursion","text":""},{"location":"chapters/07-higher-order-functions-and-recursion/#summary","title":"Summary","text":"<p>This chapter covers two powerful programming paradigms: higher-order functions and recursion. Students will learn to write lambda functions, use map/filter/reduce, and compose functions. The chapter then introduces recursive thinking, including identifying base and recursive cases, tracing the call stack, and comparing recursive vs iterative solutions. These techniques are essential for elegant problem solving.</p>"},{"location":"chapters/07-higher-order-functions-and-recursion/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 16 concepts from the learning graph:</p> <ol> <li>Function Documentation</li> <li>Helper Functions</li> <li>Main Function Pattern</li> <li>Lambda Functions</li> <li>Higher-Order Functions</li> <li>Map Function</li> <li>Filter Function</li> <li>Reduce Function</li> <li>Function Composition</li> <li>Recursion</li> <li>Base Case</li> <li>Recursive Case</li> <li>Recursive Call Stack</li> <li>Stack Overflow</li> <li>Recursion vs Iteration</li> <li>Recursive Patterns</li> </ol>"},{"location":"chapters/07-higher-order-functions-and-recursion/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 1: Introduction to Computer Science</li> <li>Chapter 4: Control Flow</li> <li>Chapter 6: Functions and Modular Design</li> </ul> <p>Monty says: Let's code this!</p> <p> Welcome back, coders! In Chapter 6 you learned to build your own functions -- the basic building blocks of modular code. Now we're going to level up. In this chapter, you'll discover that functions in Python are incredibly flexible: you can pass them around like any other value, combine them like building blocks, and even have them call themselves. That last part -- recursion -- might bend your brain a little, but trust me, it's one of the most elegant ideas in all of computer science. Let's do this!</p>"},{"location":"chapters/07-higher-order-functions-and-recursion/#writing-professional-functions","title":"Writing Professional Functions","text":"<p>Before we dive into the fancy stuff, let's make sure our functions are clean, well-organized, and professional. Two important practices -- function documentation and the use of helper functions -- will make your code easier to read, debug, and share.</p>"},{"location":"chapters/07-higher-order-functions-and-recursion/#function-documentation","title":"Function Documentation","text":"<p>Function documentation (also called a docstring) is a description you place right inside your function to explain what it does. In Python, you write it as a triple-quoted string immediately after the <code>def</code> line:</p> <pre><code>def calculate_area(length, width):\n    \"\"\"Calculate the area of a rectangle.\n\n    Args:\n        length: The length of the rectangle (must be positive).\n        width: The width of the rectangle (must be positive).\n\n    Returns:\n        The area as a float.\n    \"\"\"\n    return length * width\n</code></pre> <p>Why bother? Imagine you wrote this function six months ago. Without a docstring, you'd have to re-read all the code to remember what it does. With a docstring, the explanation is right there. Even better, Python's built-in <code>help()</code> function can display your docstring:</p> <pre><code>help(calculate_area)\n</code></pre> <p>Good docstrings answer three questions:</p> <ul> <li>What does this function do?</li> <li>What arguments does it take?</li> <li>What does it return?</li> </ul> <p>Think of a docstring like a label on a box. You could open the box to figure out what's inside, but a label is way faster.</p>"},{"location":"chapters/07-higher-order-functions-and-recursion/#helper-functions","title":"Helper Functions","text":"<p>A helper function is a small, focused function that does one specific job to support a larger function. Instead of writing one giant function that does everything, you break the work into smaller pieces.</p> <pre><code>def is_even(n):\n    \"\"\"Return True if n is even.\"\"\"\n    return n % 2 == 0\n\ndef count_evens(numbers):\n    \"\"\"Count how many even numbers are in the list.\"\"\"\n    count = 0\n    for num in numbers:\n        if is_even(num):\n            count += 1\n    return count\n</code></pre> <p>Here, <code>is_even()</code> is a helper function. It handles one tiny task -- checking if a number is even -- so that <code>count_evens()</code> stays clean and readable. Helper functions follow the principle of decomposition from Chapter 1: break big problems into smaller pieces.</p> <p>Benefits of helper functions:</p> <ul> <li>Readability -- Your main logic reads almost like English</li> <li>Reusability -- You can use <code>is_even()</code> anywhere else in your program</li> <li>Testability -- You can test each small function independently</li> </ul>"},{"location":"chapters/07-higher-order-functions-and-recursion/#the-main-function-pattern","title":"The Main Function Pattern","text":"<p>In many Python programs, you'll see a common structure called the main function pattern. Instead of scattering code throughout your file, you wrap the primary logic inside a <code>main()</code> function and then call it at the bottom:</p> <pre><code>def greet(name):\n    \"\"\"Helper: return a greeting string.\"\"\"\n    return f\"Hello, {name}! Welcome to Python.\"\n\ndef main():\n    \"\"\"Main function: runs the program.\"\"\"\n    user_name = input(\"What's your name? \")\n    message = greet(user_name)\n    print(message)\n\n# This line runs main() only when the file is executed directly\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>The mysterious <code>if __name__ == \"__main__\":</code> line tells Python: \"Only run <code>main()</code> if this file is being executed directly, not when it's imported by another file.\" This pattern keeps your code organized and reusable. You'll see it in almost every professional Python project.</p> <p>Here's why the main function pattern matters:</p> Benefit Explanation Organization All top-level logic is in one place Reusability Other files can import your helpers without running <code>main()</code> Testing You can test functions individually without triggering the full program Readability Anyone reading your code knows where to start"},{"location":"chapters/07-higher-order-functions-and-recursion/#lambda-functions-functions-in-a-single-line","title":"Lambda Functions: Functions in a Single Line","text":"<p>Sometimes you need a quick, throwaway function that's so short it doesn't deserve a full name. Enter the lambda function -- a way to define a tiny, anonymous function in a single line.</p> <pre><code># Regular function\ndef double(x):\n    return x * 2\n\n# Equivalent lambda function\ndouble = lambda x: x * 2\n\nprint(double(5))  # Output: 10\n</code></pre> <p>The syntax is: <code>lambda arguments: expression</code>. The lambda takes the arguments, evaluates the expression, and returns the result. No <code>def</code>, no <code>return</code>, no name required.</p> <p>Here are a few more examples:</p> <pre><code># Add two numbers\nadd = lambda a, b: a + b\nprint(add(3, 7))  # Output: 10\n\n# Check if a number is positive\nis_positive = lambda n: n &gt; 0\nprint(is_positive(-3))  # Output: False\n\n# Get the last character of a string\nlast_char = lambda s: s[-1]\nprint(last_char(\"Python\"))  # Output: n\n</code></pre> <p>Lambda functions shine when you need a quick function to pass as an argument to another function -- which brings us to one of the most powerful ideas in this chapter.</p> <p>Monty says: You've got this!</p> <p> Think of a lambda function like a sticky note. A regular function is a full letter you write, sign, and file away. A lambda is a quick note you scribble and hand to someone. Both communicate a message, but you'd use the sticky note when you need something fast and disposable.</p>"},{"location":"chapters/07-higher-order-functions-and-recursion/#higher-order-functions","title":"Higher-Order Functions","text":"<p>Here's where things get really interesting. In Python, functions are first-class objects. That means you can store them in variables, put them in lists, and -- most importantly -- pass them as arguments to other functions or return them as results.</p> <p>A higher-order function is any function that either:</p> <ol> <li>Takes another function as an argument, OR</li> <li>Returns a function as its result</li> </ol> <p>You've already seen hints of this. When you pass <code>lambda x: x * 2</code> to another function, that other function is a higher-order function. Let's see a concrete example:</p> <pre><code>def apply_operation(func, value):\n    \"\"\"Apply a function to a value and return the result.\"\"\"\n    return func(value)\n\nresult = apply_operation(lambda x: x ** 2, 5)\nprint(result)  # Output: 25\n</code></pre> <p>Here, <code>apply_operation</code> is a higher-order function because it takes <code>func</code> as a parameter. We passed in a lambda that squares a number, and it applied that operation to 5. Neat!</p> <p>Why is this useful? It lets you write general-purpose functions that can do different things depending on what function you pass in. Same tool, different attachments -- like a power drill with interchangeable bits.</p> <p>Python comes with three built-in higher-order functions that you'll use all the time: <code>map()</code>, <code>filter()</code>, and <code>reduce()</code>.</p>"},{"location":"chapters/07-higher-order-functions-and-recursion/#diagram-higher-order-functions-flow","title":"Diagram: Higher-Order Functions Flow","text":"Higher-Order Functions Flow Diagram <p>Type: diagram sim-id: higher-order-functions-flow Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: explain, classify</p> <p>Learning Objective: Students will be able to explain what makes a function \"higher-order\" and classify examples as higher-order or regular functions.</p> <p>Layout: - Top section: Title \"Higher-Order Functions\" - Center: A visual pipeline showing a function (represented as a machine/box) receiving two inputs -- a regular value (shown as a number ball) and a function (shown as a gear/tool icon) - Three lanes below showing map, filter, and reduce as specific examples of higher-order functions - Each lane shows: input list -&gt; function being applied -&gt; output</p> <p>Interactive elements: - Hover over each lane (map, filter, reduce) to see a brief description and example - Click on a lane to see an animated demonstration of how data flows through that higher-order function - Toggle between \"Visual Mode\" (animated icons) and \"Code Mode\" (Python syntax)</p> <p>Visual elements: - Regular values shown as colored number balls - Functions shown as gears or tool icons - Arrows showing data flow direction - Map lane: shows each input ball being transformed into a different colored ball - Filter lane: shows some balls passing through a gate while others are blocked - Reduce lane: shows multiple balls being combined into a single result ball</p> <p>Color scheme: - Map: blue tones - Filter: green tones - Reduce: orange tones - Input values: light gray - Output values: bright colors matching the operation</p> <p>Responsive: Canvas resizes with window; lanes stack vertically on narrow screens</p> <p>Instructional Rationale: A visual pipeline metaphor makes the abstract concept of \"passing a function to a function\" concrete. Showing map, filter, and reduce as parallel examples helps students see the common pattern (input + function = output) while distinguishing each operation's unique behavior.</p>"},{"location":"chapters/07-higher-order-functions-and-recursion/#the-map-function","title":"The Map Function","text":"<p>The map function applies a given function to every item in a list (or other iterable) and returns the results. Think of it like a factory assembly line: every item on the conveyor belt gets the same transformation applied.</p> <pre><code>numbers = [1, 2, 3, 4, 5]\ndoubled = list(map(lambda x: x * 2, numbers))\nprint(doubled)  # Output: [2, 4, 6, 8, 10]\n</code></pre> <p>Here's what happened step by step:</p> <ol> <li><code>map()</code> took the lambda function and the list <code>numbers</code></li> <li>It applied <code>lambda x: x * 2</code> to each element: 1 becomes 2, 2 becomes 4, 3 becomes 6...</li> <li><code>list()</code> converted the result into a list</li> </ol> <p>You can use <code>map()</code> with any function, not just lambdas:</p> <pre><code>def to_uppercase(s):\n    \"\"\"Convert a string to uppercase.\"\"\"\n    return s.upper()\n\nnames = [\"alice\", \"bob\", \"charlie\"]\nloud_names = list(map(to_uppercase, names))\nprint(loud_names)  # Output: ['ALICE', 'BOB', 'CHARLIE']\n</code></pre>"},{"location":"chapters/07-higher-order-functions-and-recursion/#the-filter-function","title":"The Filter Function","text":"<p>The filter function tests every item in a list with a function that returns <code>True</code> or <code>False</code>, and keeps only the items that pass the test. It's like a bouncer at a club -- only the items that meet the criteria get in.</p> <pre><code>numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nevens = list(filter(lambda x: x % 2 == 0, numbers))\nprint(evens)  # Output: [2, 4, 6, 8, 10]\n</code></pre> <p>The lambda <code>lambda x: x % 2 == 0</code> returns <code>True</code> for even numbers and <code>False</code> for odd ones. <code>filter()</code> keeps only the <code>True</code> items.</p> <p>Here's another example -- filtering strings by length:</p> <pre><code>words = [\"hi\", \"hello\", \"hey\", \"howdy\", \"yo\"]\nlong_words = list(filter(lambda w: len(w) &gt; 2, words))\nprint(long_words)  # Output: ['hello', 'hey', 'howdy']\n</code></pre>"},{"location":"chapters/07-higher-order-functions-and-recursion/#the-reduce-function","title":"The Reduce Function","text":"<p>The reduce function takes a list of items and combines them down to a single value by repeatedly applying a function. Think of it like folding a long piece of paper in half, again and again, until you end up with one thick square.</p> <p>Unlike <code>map()</code> and <code>filter()</code>, <code>reduce()</code> isn't built-in -- you need to import it:</p> <pre><code>from functools import reduce\n\nnumbers = [1, 2, 3, 4, 5]\ntotal = reduce(lambda a, b: a + b, numbers)\nprint(total)  # Output: 15\n</code></pre> <p>Here's how reduce processes this step by step:</p> Step a b Result 1 1 2 3 2 3 3 6 3 6 4 10 4 10 5 15 <p>It starts with the first two elements (1 and 2), adds them to get 3. Then it takes that 3 and adds the next element (3) to get 6. And so on, until every element has been folded in.</p> <p>Here's a comparison of all three functions:</p> Function What It Does Input Output Analogy <code>map()</code> Transforms each item List + function New list (same length) Assembly line <code>filter()</code> Keeps items that pass a test List + function New list (same or shorter) Bouncer at a club <code>reduce()</code> Combines all items into one List + function Single value Folding paper <p>Monty says: Let's debug this together!</p> <p> A common mistake is forgetting to wrap <code>map()</code> and <code>filter()</code> with <code>list()</code>. In Python 3, these functions return iterator objects, not lists. If you just write <code>map(func, data)</code> without <code>list()</code>, you'll get something like <code>&lt;map object at 0x...&gt;</code> instead of the actual values. Always wrap with <code>list()</code> when you want to see the results!</p>"},{"location":"chapters/07-higher-order-functions-and-recursion/#diagram-map-filter-reduce-pipeline","title":"Diagram: Map Filter Reduce Pipeline","text":"Map Filter Reduce Pipeline MicroSim <p>Type: microsim sim-id: map-filter-reduce-pipeline Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: apply, demonstrate</p> <p>Learning Objective: Students will be able to chain map, filter, and reduce operations on a list and predict the output at each stage.</p> <p>Layout: - Top: An input conveyor belt with numbered balls (the input list) - Three processing stations arranged left to right: MAP, FILTER, REDUCE - Between each station, a conveyor belt shows intermediate results - Bottom: Final output display</p> <p>Interactive controls: - Input field to enter a comma-separated list of numbers (default: 1,2,3,4,5,6,7,8,9,10) - Dropdown to select map operation: \"double\", \"square\", \"negate\", \"add 10\" - Dropdown to select filter condition: \"even\", \"odd\", \"greater than 5\", \"positive\" - Dropdown to select reduce operation: \"sum\", \"product\", \"max\", \"min\" - \"Run Pipeline\" button: Animates the data flowing through all three stages - \"Step\" button: Advance one item at a time through the pipeline - \"Reset\" button: Clear and start over</p> <p>Visual elements: - Numbered balls on conveyor belts - MAP station: balls change color/number as they're transformed - FILTER station: a gate that opens for passing items and shows rejected items falling off - REDUCE station: balls merge together into one final ball - Each station shows the Python code equivalent below it - Running total/status shown at each stage</p> <p>Animation: - Smooth ball movement along conveyor belts - Transformation animation at MAP (ball morphs) - Accept/reject animation at FILTER (gate opens or ball drops) - Merge animation at REDUCE (two balls combine into one)</p> <p>Color scheme: Industrial/factory theme with steel grays, colored balls, green for accepted, red for rejected</p> <p>Responsive: Canvas scales with window; stations may stack vertically on narrow screens</p> <p>Instructional Rationale: The factory/pipeline metaphor makes the abstract chaining of higher-order functions tangible. Step-by-step animation lets students predict what happens next before seeing the result, which supports active learning at the Apply level. Customizable inputs encourage experimentation.</p>"},{"location":"chapters/07-higher-order-functions-and-recursion/#function-composition","title":"Function Composition","text":"<p>Function composition means combining two or more functions so that the output of one becomes the input of the next. It's like an assembly line where the product passes through multiple stations, each one adding or changing something.</p> <pre><code>def add_tax(price):\n    \"\"\"Add 8% sales tax.\"\"\"\n    return price * 1.08\n\ndef apply_discount(price):\n    \"\"\"Apply a 20% discount.\"\"\"\n    return price * 0.80\n\ndef format_price(price):\n    \"\"\"Format as a dollar string.\"\"\"\n    return f\"${price:.2f}\"\n\n# Compose the functions: discount first, then tax, then format\noriginal_price = 100\nfinal = format_price(add_tax(apply_discount(original_price)))\nprint(final)  # Output: $86.40\n</code></pre> <p>Notice how we read the composition from the inside out: first <code>apply_discount(100)</code> returns 80, then <code>add_tax(80)</code> returns 86.4, then <code>format_price(86.4)</code> returns \"$86.40\". Each function takes the previous function's result as its input.</p> <p>You can also write a general-purpose compose function:</p> <pre><code>def compose(f, g):\n    \"\"\"Return a new function that applies g first, then f.\"\"\"\n    return lambda x: f(g(x))\n\n# Create a composed function\ndiscount_then_tax = compose(add_tax, apply_discount)\nprint(discount_then_tax(100))  # Output: 86.4\n</code></pre> <p>Function composition is everywhere in programming. When you chain operations together -- like transforming data, then filtering it, then formatting it -- you're composing functions. It's a key pattern in writing clean, modular code.</p>"},{"location":"chapters/07-higher-order-functions-and-recursion/#recursion-functions-that-call-themselves","title":"Recursion: Functions That Call Themselves","text":"<p>Now for the mind-bending part. What if a function could call itself? That's recursion, and it's one of the most powerful (and initially confusing) ideas in computer science.</p> <p>Monty says: You've got this!</p> <p> Recursion can feel weird at first -- and that's totally normal! Even experienced programmers had to wrap their heads around it. Think of Russian nesting dolls (matryoshkas): you open one doll and find a smaller doll inside, open that one and find an even smaller doll, and so on until you reach the tiniest doll that can't be opened. That's recursion! Each doll \"contains\" a smaller version of itself, and the tiniest doll is where the process stops.</p> <p>Here's the simplest possible recursive function:</p> <pre><code>def countdown(n):\n    \"\"\"Count down from n to 1, then print 'Go!'\"\"\"\n    if n == 0:\n        print(\"Go!\")\n    else:\n        print(n)\n        countdown(n - 1)\n\ncountdown(3)\n</code></pre> <p>Output:</p> <pre><code>3\n2\n1\nGo!\n</code></pre> <p>The function <code>countdown()</code> calls itself with a smaller number each time. When <code>n</code> reaches 0, it stops. This brings us to the two essential ingredients of every recursive function.</p>"},{"location":"chapters/07-higher-order-functions-and-recursion/#base-case","title":"Base Case","text":"<p>The base case is the condition that stops the recursion. Without it, the function would call itself forever (spoiler: that's bad). The base case is the \"tiniest nesting doll\" -- the simplest version of the problem that you can solve directly without any more recursive calls.</p> <p>In our countdown example, the base case is <code>if n == 0: print(\"Go!\")</code>. When we reach zero, we don't call <code>countdown()</code> again. We just print and stop.</p>"},{"location":"chapters/07-higher-order-functions-and-recursion/#recursive-case","title":"Recursive Case","text":"<p>The recursive case is the part where the function calls itself with a smaller or simpler version of the problem. Each recursive call should move you closer to the base case.</p> <p>In our countdown, the recursive case is <code>countdown(n - 1)</code>. Each call reduces <code>n</code> by 1, so we're guaranteed to eventually reach 0 (the base case).</p> <p>Every recursive function must have:</p> Component What It Does What Happens Without It Base case Stops the recursion Infinite recursion (crash!) Recursive case Makes the problem smaller and calls itself Function never does useful work Progress toward base case Ensures we eventually stop Infinite recursion (crash!)"},{"location":"chapters/07-higher-order-functions-and-recursion/#classic-example-factorial","title":"Classic Example: Factorial","text":"<p>The factorial of a number (n) (written (n!)) is the product of all positive integers from 1 to (n):</p> <p>[ n! = n \\times (n-1) \\times (n-2) \\times \\cdots \\times 2 \\times 1 ]</p> <p>For example, (5! = 5 \\times 4 \\times 3 \\times 2 \\times 1 = 120).</p> <p>Notice something interesting: (5! = 5 \\times 4!). And (4! = 4 \\times 3!). Each factorial is defined in terms of a smaller factorial. That's a perfect fit for recursion!</p> <pre><code>def factorial(n):\n    \"\"\"Calculate n! recursively.\n\n    Base case: 0! = 1\n    Recursive case: n! = n * (n-1)!\n    \"\"\"\n    if n == 0:\n        return 1          # Base case\n    else:\n        return n * factorial(n - 1)  # Recursive case\n\nprint(factorial(5))  # Output: 120\n</code></pre> <p>Let's trace through <code>factorial(5)</code>:</p> <pre><code>factorial(5) = 5 * factorial(4)\n             = 5 * (4 * factorial(3))\n             = 5 * (4 * (3 * factorial(2)))\n             = 5 * (4 * (3 * (2 * factorial(1))))\n             = 5 * (4 * (3 * (2 * (1 * factorial(0)))))\n             = 5 * (4 * (3 * (2 * (1 * 1))))\n             = 5 * (4 * (3 * (2 * 1)))\n             = 5 * (4 * (3 * 2))\n             = 5 * (4 * 6)\n             = 5 * 24\n             = 120\n</code></pre> <p>The function \"unwinds\" outward until it hits the base case, then the results cascade back, multiplying at each level.</p>"},{"location":"chapters/07-higher-order-functions-and-recursion/#diagram-factorial-recursion-tree","title":"Diagram: Factorial Recursion Tree","text":"Factorial Recursion Tree MicroSim <p>Type: microsim sim-id: factorial-recursion-tree Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: trace, explain</p> <p>Learning Objective: Students will be able to trace through recursive factorial calls, identify the base case and recursive case, and explain how the return values cascade back up.</p> <p>Layout: - Top: Input slider for n (range 1 to 8, default 5) - Center: A vertical tree showing each recursive call as a node - Each node shows: the function call (e.g., \"factorial(5)\"), the computation (e.g., \"5 * factorial(4)\"), and the return value once computed - Arrows connecting parent calls to child calls going down - Return value arrows going back up - Bottom: Final result display</p> <p>Interactive controls: - Slider to set n (1-8) - \"Step Forward\" button: Reveals one level of recursion at a time (going down) - \"Step Return\" button: After reaching the base case, shows return values cascading up one at a time - \"Auto Play\" button: Animates the full trace automatically - \"Reset\" button: Clear and start over - Speed slider for auto play</p> <p>Visual elements: - Each recursive call shown as a rounded rectangle node - Nodes appear one at a time as you step forward (building the call chain downward) - Base case node highlighted in green with a star icon - Recursive case nodes in blue - When stepping return: each node fills with its computed return value in gold - Arrows animate to show data flow direction (down for calls, up for returns) - Current active node is highlighted with a pulsing border</p> <p>Animation sequence: 1. Start with factorial(n) node at top 2. Each step adds a new child node below: factorial(n-1) 3. When base case is reached, node turns green 4. Return phase: each node computes its value and passes it up 5. Final result shown at the top in large text</p> <p>Color scheme: Blue nodes for recursive calls, green for base case, gold for computed values</p> <p>Responsive: Tree repositions based on canvas width; nodes scale for smaller screens</p> <p>Instructional Rationale: Step-by-step trace visualization makes the \"unwinding\" and \"rewinding\" nature of recursion concrete. Students can pause at each step to predict what happens next, reinforcing understanding of base and recursive cases. The visual tree structure mirrors how recursion is often explained on paper, creating a bridge between the code and the mental model.</p>"},{"location":"chapters/07-higher-order-functions-and-recursion/#the-recursive-call-stack","title":"The Recursive Call Stack","text":"<p>When a function calls itself, Python doesn't throw away the current call. Instead, it pauses the current call and stacks a new one on top. This data structure is called the recursive call stack (or just \"the call stack\").</p> <p>Imagine a stack of cafeteria trays. Each time you make a recursive call, a new tray goes on top. When a call finishes (returns), its tray gets removed. The previous call resumes where it left off.</p> <p>Here's what the call stack looks like for <code>factorial(4)</code>:</p> <pre><code>Step 1: [factorial(4)] -- calls factorial(3)\nStep 2: [factorial(4), factorial(3)] -- calls factorial(2)\nStep 3: [factorial(4), factorial(3), factorial(2)] -- calls factorial(1)\nStep 4: [factorial(4), factorial(3), factorial(2), factorial(1)] -- calls factorial(0)\nStep 5: [factorial(4), factorial(3), factorial(2), factorial(1), factorial(0)]\n        -- base case reached! Returns 1\nStep 6: [factorial(4), factorial(3), factorial(2), factorial(1)]\n        -- returns 1 * 1 = 1\nStep 7: [factorial(4), factorial(3), factorial(2)]\n        -- returns 2 * 1 = 2\nStep 8: [factorial(4), factorial(3)]\n        -- returns 3 * 2 = 6\nStep 9: [factorial(4)]\n        -- returns 4 * 6 = 24\n</code></pre> <p>Each frame on the call stack holds its own local variables. The <code>n</code> in <code>factorial(4)</code> is 4, the <code>n</code> in <code>factorial(3)</code> is 3, and so on. They don't interfere with each other.</p>"},{"location":"chapters/07-higher-order-functions-and-recursion/#diagram-recursive-call-stack-visualizer","title":"Diagram: Recursive Call Stack Visualizer","text":"Recursive Call Stack Visualizer MicroSim <p>Type: microsim sim-id: recursive-call-stack Library: p5.js Status: Specified</p> <p>Bloom Level: Analyze (L4) Bloom Verb: trace, differentiate</p> <p>Learning Objective: Students will be able to trace the call stack during recursive execution, identify when frames are pushed and popped, and determine the value of local variables at any point during execution.</p> <p>Layout: - Left panel (60%): Code display showing the recursive function with line-by-line highlighting - Right panel (40%): Visual call stack showing frames stacking up and down - Bottom: Controls and status bar</p> <p>Code display (left panel): - Shows the factorial function code with line numbers - Current executing line is highlighted in yellow - A dropdown to switch between \"Factorial\", \"Fibonacci\", and \"Countdown\" examples</p> <p>Call stack display (right panel): - Stack frames shown as rectangles stacking upward (like cafeteria trays) - Each frame displays:   - Function name and argument (e.g., \"factorial(3)\")   - Local variable values (e.g., \"n = 3\")   - Return value (shown when the frame completes, in gold) - New frames animate sliding in from the right onto the top of the stack - Completed frames animate sliding out to the left - Base case frame is highlighted in green - Current active frame has a pulsing yellow border</p> <p>Interactive controls: - Function selector dropdown: \"Factorial\", \"Fibonacci\", \"Countdown\" - Input field for the argument (e.g., n = 5) - \"Step Into\" button: Execute the next line, pushing a new frame if it's a recursive call - \"Step Return\" button: Complete the current frame and pop it off the stack - \"Auto Play\" button: Animate the full execution at adjustable speed - \"Reset\" button: Return to starting state - Speed slider for auto play - Stack depth counter: \"Stack depth: 3 / max 1000\"</p> <p>Visual elements: - Stack frames are 3D-looking rectangles with slight shadows - Pushing a frame: frame slides in from the right and settles on top - Popping a frame: frame lifts off, shows return value floating up to the frame below - Return value animation: gold number floats from child frame to parent frame - Line highlight in code panel syncs with stack operations - Stack depth indicator with color gradient (green = safe, yellow = getting deep, red = nearing overflow)</p> <p>Color scheme: - Active frame: yellow border - Waiting frames: blue - Base case frame: green - Return values: gold - Code highlight: yellow background</p> <p>Responsive: Panels adjust width on resize; code panel may move above stack panel on narrow screens</p> <p>Instructional Rationale: The call stack is the single most important mental model for understanding recursion. By syncing code execution with stack visualization, students can see the direct relationship between \"this line of code executes\" and \"this frame is pushed/popped.\" The step-by-step controls let students pause and predict, which is critical for building accurate mental models at the Analyze level. Supporting multiple function examples (factorial, Fibonacci, countdown) helps students generalize the pattern.</p>"},{"location":"chapters/07-higher-order-functions-and-recursion/#stack-overflow","title":"Stack Overflow","text":"<p>What happens if you forget the base case? The function keeps calling itself forever, and the call stack grows taller and taller until Python runs out of memory. This crash is called a stack overflow.</p> <pre><code>def oops(n):\n    \"\"\"This function has no base case -- don't run this!\"\"\"\n    return n * oops(n - 1)\n\n# oops(5) would crash with:\n# RecursionError: maximum recursion depth exceeded\n</code></pre> <p>Python has a default recursion limit of about 1,000 calls deep. If your function tries to go deeper than that, Python stops it and raises a <code>RecursionError</code>. This is a safety net to prevent your computer from freezing.</p> <p>Monty says: Watch out!</p> <p> The two most common causes of stack overflow are: (1) forgetting the base case entirely, and (2) having a base case that's never actually reached (for example, checking <code>if n == 0</code> but never decreasing <code>n</code>). Always ask yourself: \"Does every recursive call move me closer to the base case?\" If the answer is no, you've got an infinite recursion waiting to happen!</p> <p>Common causes of stack overflow:</p> <ul> <li>Missing base case -- The function never stops</li> <li>Base case never reached -- The arguments don't progress toward the base case</li> <li>Problem too large -- Even correct recursion on very deep problems can hit the limit</li> </ul>"},{"location":"chapters/07-higher-order-functions-and-recursion/#recursion-vs-iteration","title":"Recursion vs. Iteration","text":"<p>You might be thinking: \"Can't I just use a loop instead?\" Great question! Recursion vs. iteration is an important comparison. Many problems can be solved either way.</p> <p>Here's factorial done both ways:</p> <pre><code># Recursive version\ndef factorial_recursive(n):\n    if n == 0:\n        return 1\n    return n * factorial_recursive(n - 1)\n\n# Iterative version (using a loop)\ndef factorial_iterative(n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result\n</code></pre> <p>Both give the same answer. So when should you use which?</p> Feature Recursion Iteration Readability Can be more elegant and closer to the math definition Can be more straightforward for simple counting Memory Uses more memory (call stack) Uses constant memory Speed Can be slower due to function call overhead Generally faster Best for Tree structures, divide-and-conquer, problems with natural recursive definitions Simple counting, accumulating results, large datasets Risk Stack overflow if too deep Infinite loop if condition is wrong <p>In practice, many programmers use recursion when the problem naturally breaks into smaller subproblems (like tree traversal or parsing nested data), and iteration when they're just counting or accumulating values.</p>"},{"location":"chapters/07-higher-order-functions-and-recursion/#recursive-patterns","title":"Recursive Patterns","text":"<p>Now that you understand the mechanics, let's look at some common recursive patterns that appear over and over in computer science.</p>"},{"location":"chapters/07-higher-order-functions-and-recursion/#pattern-1-linear-recursion-factorial","title":"Pattern 1: Linear Recursion (Factorial)","text":"<p>Each call makes exactly one recursive call. The call chain forms a straight line. Factorial is the classic example.</p> <pre><code>def sum_list(numbers):\n    \"\"\"Sum a list recursively.\"\"\"\n    if len(numbers) == 0:    # Base case: empty list\n        return 0\n    return numbers[0] + sum_list(numbers[1:])  # First element + sum of rest\n\nprint(sum_list([1, 2, 3, 4]))  # Output: 10\n</code></pre>"},{"location":"chapters/07-higher-order-functions-and-recursion/#pattern-2-tree-recursion-fibonacci","title":"Pattern 2: Tree Recursion (Fibonacci)","text":"<p>Each call makes two or more recursive calls. The calls branch out like a tree. The Fibonacci sequence is the classic example.</p> <p>The Fibonacci sequence starts with 0, 1, and each subsequent number is the sum of the two before it:</p> <p>[ F(n) = F(n-1) + F(n-2) ]</p> <p>So the sequence goes: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...</p> <pre><code>def fibonacci(n):\n    \"\"\"Return the nth Fibonacci number.\n\n    Base cases: F(0) = 0, F(1) = 1\n    Recursive case: F(n) = F(n-1) + F(n-2)\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n - 1) + fibonacci(n - 2)\n\nprint(fibonacci(7))  # Output: 13\n</code></pre> <p>Be careful with tree recursion -- it can be very slow for large inputs because it recalculates the same values many times. <code>fibonacci(30)</code> makes over a million function calls! (You'll learn how to fix this with a technique called memoization in later chapters.)</p>"},{"location":"chapters/07-higher-order-functions-and-recursion/#pattern-3-divide-and-conquer","title":"Pattern 3: Divide and Conquer","text":"<p>The problem is split into smaller subproblems, each solved recursively, and then the results are combined. You'll see this in sorting algorithms like merge sort (Chapter 18).</p> <pre><code>def binary_search(sorted_list, target, low, high):\n    \"\"\"Search for target in a sorted list using recursion.\"\"\"\n    if low &gt; high:\n        return -1  # Base case: not found\n    mid = (low + high) // 2\n    if sorted_list[mid] == target:\n        return mid  # Base case: found it!\n    elif sorted_list[mid] &lt; target:\n        return binary_search(sorted_list, target, mid + 1, high)\n    else:\n        return binary_search(sorted_list, target, low, mid - 1)\n</code></pre>"},{"location":"chapters/07-higher-order-functions-and-recursion/#pattern-4-accumulator-pattern","title":"Pattern 4: Accumulator Pattern","text":"<p>Pass an extra parameter that accumulates the result as you go. This can convert some recursive solutions into tail-recursive form:</p> <pre><code>def factorial_acc(n, accumulator=1):\n    \"\"\"Factorial with an accumulator parameter.\"\"\"\n    if n == 0:\n        return accumulator\n    return factorial_acc(n - 1, accumulator * n)\n\nprint(factorial_acc(5))  # Output: 120\n</code></pre> <p>Here's a summary of recursive patterns:</p> Pattern Calls per Step Shape Example Linear 1 Straight line Factorial, sum of list Tree 2+ Branching tree Fibonacci Divide and conquer 2+ (on subsets) Balanced tree Binary search, merge sort Accumulator 1 (with extra param) Straight line Tail-recursive factorial"},{"location":"chapters/07-higher-order-functions-and-recursion/#diagram-fibonacci-tree-visualization","title":"Diagram: Fibonacci Tree Visualization","text":"Fibonacci Tree Visualization MicroSim <p>Type: microsim sim-id: fibonacci-tree Library: p5.js Status: Specified</p> <p>Bloom Level: Analyze (L4) Bloom Verb: compare, analyze</p> <p>Learning Objective: Students will be able to trace Fibonacci recursion, identify redundant calculations in tree recursion, and compare the number of function calls for different input values.</p> <p>Layout: - Top: Input slider for n (range 1 to 10, default 6) - Center: Tree visualization showing all recursive calls - Each tree node shows: function call (e.g., \"fib(5)\") and return value once computed - Left and right branches for the two recursive calls - Bottom: Statistics panel showing total calls, unique calls, and redundant calls</p> <p>Interactive controls: - Slider to set n (1-10) - \"Step\" button: Reveals one function call at a time in depth-first order - \"Auto Play\" button: Animates the full tree building at adjustable speed - \"Show Redundancy\" toggle: Highlights duplicate calls in red (e.g., fib(2) appears multiple times) - \"Reset\" button</p> <p>Visual elements: - Tree nodes as circles with function call text inside - Base case nodes (fib(0), fib(1)) shown in green - Redundant nodes highlighted in red when \"Show Redundancy\" is on - Edges connect parent to children - When a node's value is computed, it displays in gold text - Nodes appear with a gentle pop-in animation</p> <p>Statistics panel: - Total function calls: [number] - Unique subproblems: [number] - Redundant calls: [number] ([percentage]%) - Bar chart comparing call counts for fib(1) through fib(n)</p> <p>Color scheme: - Regular nodes: blue - Base case nodes: green - Redundant nodes: red - Return values: gold text - Edges: gray</p> <p>Responsive: Tree auto-layouts to fit canvas width; may scroll horizontally for large n</p> <p>Instructional Rationale: Tree recursion is the most visually dramatic demonstration of why naive recursion can be inefficient. By highlighting redundant calls, students immediately see that fib(2) is calculated many times -- motivating the eventual need for memoization. The statistics panel quantifies the waste, helping students develop intuition for algorithmic complexity. Step-by-step building of the tree supports the Analyze level by requiring students to predict branching behavior.</p>"},{"location":"chapters/07-higher-order-functions-and-recursion/#combining-it-all-higher-order-functions-meet-recursion","title":"Combining It All: Higher-Order Functions Meet Recursion","text":"<p>Let's see how higher-order functions and recursion can work together. Here's a function that recursively applies a list of transformations to a value:</p> <pre><code>def apply_all(functions, value):\n    \"\"\"Recursively apply a list of functions to a value.\n\n    Base case: no functions left, return the value.\n    Recursive case: apply the first function, then recurse on the rest.\n    \"\"\"\n    if len(functions) == 0:\n        return value\n    first_result = functions[0](value)\n    return apply_all(functions[1:], first_result)\n\n# Define some transformations\ntransformations = [\n    lambda x: x * 2,      # Double it\n    lambda x: x + 10,     # Add 10\n    lambda x: x ** 2       # Square it\n]\n\nresult = apply_all(transformations, 3)\nprint(result)  # 3 -&gt; 6 -&gt; 16 -&gt; 256\n</code></pre> <p>This combines higher-order functions (passing functions in a list) with recursion (processing the list one function at a time). It's a beautiful example of how these two ideas complement each other.</p>"},{"location":"chapters/07-higher-order-functions-and-recursion/#diagram-recursion-vs-iteration-side-by-side","title":"Diagram: Recursion vs Iteration Side-by-Side","text":"Recursion vs Iteration Side-by-Side Comparison <p>Type: microsim sim-id: recursion-vs-iteration Library: p5.js Status: Specified</p> <p>Bloom Level: Evaluate (L5) Bloom Verb: compare, evaluate</p> <p>Learning Objective: Students will be able to compare recursive and iterative implementations of the same algorithm side by side, tracking execution steps, memory usage, and output for each approach.</p> <p>Layout: - Split screen: left half \"Recursive\", right half \"Iterative\" - Each side shows: code with line highlighting, variable state display, and step counter - Bottom: shared controls and comparison metrics</p> <p>Algorithm selector: Dropdown to choose between: - Factorial - Sum of list - Countdown - Fibonacci (recursive only shows tree; iterative shows loop)</p> <p>Left panel (Recursive): - Code display with line-by-line highlighting - Call stack visualization (mini version): frames stacking up - Current variable values for the active frame - Step counter</p> <p>Right panel (Iterative): - Code display with line-by-line highlighting - Single set of variable values (no stack) - Loop counter display - Step counter</p> <p>Bottom comparison metrics: - Steps taken: Recursive [N] vs Iterative [M] - Memory used: Recursive [call stack depth] vs Iterative [constant] - Output: [same value for both]</p> <p>Interactive controls: - Algorithm dropdown selector - Input field for argument - \"Step Both\" button: Advance both sides one step simultaneously - \"Run Both\" button: Run to completion and show final metrics - \"Reset\" button</p> <p>Color scheme: - Recursive panel: blue tones - Iterative panel: green tones - Active code line: yellow highlight - Metrics: neutral with colored bars for comparison</p> <p>Responsive: Panels side-by-side on wide screens, stacked on narrow screens</p> <p>Instructional Rationale: Direct side-by-side comparison is the most effective way to help students evaluate when to use recursion vs iteration. Seeing the same problem solved both ways -- with step counts and memory usage displayed -- gives students concrete evidence to reason about tradeoffs. This supports the Evaluate level by asking students to judge which approach is more appropriate for different scenarios.</p> <p>Monty says: You've got this!</p> <p> You just conquered one of the toughest topics in all of computer science -- recursion! From lambda functions to map/filter/reduce, from function composition to recursive call stacks, you now have an incredibly powerful toolkit. These ideas will show up again and again as we tackle lists, sorting, and more advanced algorithms. Give yourself a pat on the back, coder!</p>"},{"location":"chapters/07-higher-order-functions-and-recursion/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Function documentation (docstrings) makes your code professional and self-explanatory. Always describe what a function does, its arguments, and its return value.</li> <li>Helper functions break complex tasks into small, testable, reusable pieces.</li> <li>The main function pattern (<code>if __name__ == \"__main__\": main()</code>) organizes your program and makes it importable.</li> <li>Lambda functions let you define small, anonymous functions in a single line using <code>lambda args: expression</code>.</li> <li>Higher-order functions take functions as arguments or return functions as results.</li> <li><code>map()</code> transforms every element in a list. <code>filter()</code> keeps elements that pass a test. <code>reduce()</code> combines all elements into a single value.</li> <li>Function composition chains functions so the output of one becomes the input of the next.</li> <li>Recursion is when a function calls itself. Every recursive function needs a base case (when to stop) and a recursive case (how to break the problem down).</li> <li>The recursive call stack tracks all active function calls. Each call gets its own frame with its own local variables.</li> <li>Stack overflow happens when recursion goes too deep -- usually from a missing or unreachable base case.</li> <li>Recursion vs. iteration: recursion is elegant for naturally recursive problems; iteration is often faster and uses less memory.</li> <li>Common recursive patterns include linear recursion, tree recursion, divide and conquer, and the accumulator pattern.</li> </ul> Check Your Understanding: What's wrong with this recursive function? <pre><code>def count_up(n):\n    print(n)\n    count_up(n + 1)\n</code></pre> This function has no base case, so it will never stop calling itself. Each call increases <code>n</code> by 1, so there's no condition to halt the recursion. It will cause a stack overflow (Python's <code>RecursionError</code>). To fix it, add a base case, such as <code>if n &gt; 10: return</code>. Check Your Understanding: What does this code output? <pre><code>numbers = [1, 2, 3, 4, 5, 6]\nresult = list(filter(lambda x: x &gt; 3, map(lambda x: x * 2, numbers)))\nprint(result)\n</code></pre> First, <code>map(lambda x: x * 2, numbers)</code> doubles each number: <code>[2, 4, 6, 8, 10, 12]</code>. Then, <code>filter(lambda x: x &gt; 3, ...)</code> keeps only values greater than 3: <code>[4, 6, 8, 10, 12]</code>. This is an example of composing <code>map</code> and <code>filter</code> together. Check Your Understanding: Trace factorial(4) and list the call stack at its deepest point. <p>At its deepest point, the call stack contains (from bottom to top): <code>factorial(4)</code>, <code>factorial(3)</code>, <code>factorial(2)</code>, <code>factorial(1)</code>, <code>factorial(0)</code>. That's 5 frames. The base case <code>factorial(0)</code> returns 1, then each frame above computes its result: <code>1*1 = 1</code>, <code>2*1 = 2</code>, <code>3*2 = 6</code>, <code>4*6 = 24</code>. The final answer is 24.</p>"},{"location":"chapters/08-lists/","title":"Lists","text":""},{"location":"chapters/08-lists/#lists","title":"Lists","text":""},{"location":"chapters/08-lists/#summary","title":"Summary","text":"<p>This chapter introduces Python lists, the most versatile built-in data structure. Students will learn to create, index, slice, and modify lists. The chapter covers essential list methods (append, insert, remove, pop, sort, reverse), list comprehensions for concise creation, nested lists, and traversal patterns. Lists are fundamental to nearly every non-trivial Python program.</p>"},{"location":"chapters/08-lists/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 20 concepts from the learning graph:</p> <ol> <li>Lists</li> <li>List Creation</li> <li>List Indexing</li> <li>List Slicing</li> <li>List Mutability</li> <li>List Methods</li> <li>Append Method</li> <li>Insert Method</li> <li>Remove Method</li> <li>Pop Method</li> <li>Sort Method</li> <li>Reverse Method</li> <li>List Comprehension</li> <li>Nested Lists</li> <li>List of Lists</li> <li>List Traversal</li> <li>For Loop with Lists</li> <li>Enumerate Function</li> <li>List Unpacking</li> <li>Zip Function</li> </ol>"},{"location":"chapters/08-lists/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 2: Python Fundamentals</li> <li>Chapter 4: Control Flow</li> <li>Chapter 5: Working with Strings</li> </ul> <p>Monty says: Let's code this!</p> <p> Welcome back, coders! So far you've worked with single values \u2014 a number here, a string there. But what if you need to keep track of dozens of values? A playlist of songs, a roster of students, a shopping list? That's where Python lists come in, and they're about to become your new best friend. Let's dive in!</p>"},{"location":"chapters/08-lists/#what-are-lists","title":"What Are Lists?","text":"<p>Imagine you're packing for a trip, and you write down everything you need: \"phone, charger, snacks, headphones, sunscreen.\" That written packing list is a collection of items grouped together under one name \u2014 your packing list. Python lists work the same way.</p> <p>A list is an ordered collection of items stored in a single variable. Instead of creating five separate variables for five items, you put them all in one list. Lists are like the Swiss Army knife of Python \u2014 they're flexible, powerful, and you'll use them constantly.</p> <p>Here's a taste of what a list looks like in Python:</p> <pre><code>packing_list = [\"phone\", \"charger\", \"snacks\", \"headphones\", \"sunscreen\"]\nprint(packing_list)\n</code></pre> <pre><code>['phone', 'charger', 'snacks', 'headphones', 'sunscreen']\n</code></pre> <p>That's it! Square brackets, items separated by commas, and you've got yourself a list.</p>"},{"location":"chapters/08-lists/#creating-lists","title":"Creating Lists","text":"<p>List creation in Python is straightforward. You use square brackets <code>[]</code> and separate each item with a comma. Here are several ways to create lists:</p> <pre><code># A list of strings\nfruits = [\"apple\", \"banana\", \"cherry\"]\n\n# A list of numbers\nscores = [95, 87, 92, 78, 100]\n\n# A list of mixed types (yes, Python allows this!)\nmixed = [\"Alice\", 16, True, 3.14]\n\n# An empty list (ready to be filled later)\nempty = []\n\n# Using the list() constructor\nletters = list(\"hello\")  # Creates ['h', 'e', 'l', 'l', 'o']\n</code></pre> <p>A few things to notice:</p> <ul> <li>Lists can hold any type of data \u2014 strings, integers, floats, booleans, and even other lists</li> <li>You can mix different types in the same list (though it's usually cleaner to keep them consistent)</li> <li>An empty list <code>[]</code> is totally valid \u2014 think of it as an empty shopping bag waiting to be filled</li> </ul> <p>You can also find out how many items are in a list using the built-in <code>len()</code> function:</p> <pre><code>fruits = [\"apple\", \"banana\", \"cherry\"]\nprint(len(fruits))  # Output: 3\n</code></pre>"},{"location":"chapters/08-lists/#diagram-list-creation-visualizer","title":"Diagram: List Creation Visualizer","text":"List Creation Visualizer <p>Type: microsim sim-id: list-creation-visualizer Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: interpret, illustrate</p> <p>Learning Objective: Students will be able to create Python lists and visualize how items are stored in indexed positions.</p> <p>Purpose: An interactive visualization showing how Python stores list elements in sequential memory positions. Students type items into a text field and see them appear as labeled boxes in a visual list representation.</p> <p>Canvas layout: - Top section: Title \"List Creation Visualizer\" - Text input field where students can type comma-separated values - A \"Create List\" button that renders the list - Visual representation: horizontal row of colored boxes, each containing an item - Above each box: the index number (0, 1, 2, ...) - Below the boxes: the Python code representation (e.g., <code>[\"apple\", \"banana\", \"cherry\"]</code>) - Preset buttons: \"Fruits\", \"Numbers\", \"Mixed Types\", \"Empty\" to load example lists</p> <p>Interactive elements: - Type comma-separated values and press \"Create List\" to see the visual - Click preset buttons to load example data - Hover over any box to highlight the index and the value - A \"Add Item\" button to append one more item to the existing list, animating it sliding into position</p> <p>Visual style: Clean colored boxes with rounded corners, index labels in a contrasting color above Color scheme: Alternating soft blue and green boxes; index labels in dark gray Responsive: Boxes resize based on number of items and window width</p> <p>Instructional Rationale: Visualization of sequential indexed storage helps students build a mental model of how list data is organized internally. The ability to create custom lists encourages experimentation, while preset examples scaffold the experience.</p>"},{"location":"chapters/08-lists/#accessing-list-items-indexing","title":"Accessing List Items: Indexing","text":"<p>Okay, so you've created a list. How do you get a specific item out of it? That's where list indexing comes in.</p> <p>Every item in a list has a position number called an index. And here's the part that trips up almost everyone at first: Python starts counting at 0, not 1. The first item is at index 0, the second at index 1, and so on.</p> <pre><code>fruits = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"]\n#          index 0   index 1   index 2   index 3   index 4\n\nprint(fruits[0])   # apple\nprint(fruits[2])   # cherry\nprint(fruits[4])   # elderberry\n</code></pre> <p>Why does Python start at 0? It's a computer science tradition that goes back to how memory addresses work. Don't fight it \u2014 embrace it. Soon it'll feel completely natural.</p> <p>Python also supports negative indexing, which counts from the end of the list. The last item is index -1, the second-to-last is -2, and so on:</p> <pre><code>print(fruits[-1])   # elderberry (last item)\nprint(fruits[-2])   # date (second to last)\nprint(fruits[-3])   # cherry\n</code></pre> <p>Here's a handy reference table:</p> Item Positive Index Negative Index \"apple\" 0 -5 \"banana\" 1 -4 \"cherry\" 2 -3 \"date\" 3 -2 \"elderberry\" 4 -1 <p>Monty says: You've got this!</p> <p> Think of negative indices as a shortcut. Instead of calculating <code>len(my_list) - 1</code> to find the last item, just use <code>my_list[-1]</code>. It's Python's way of being thoughtful \u2014 because who wants to do extra math when you don't have to?</p> <p>If you try to access an index that doesn't exist, Python raises an <code>IndexError</code>:</p> <pre><code>fruits = [\"apple\", \"banana\", \"cherry\"]\nprint(fruits[10])  # IndexError: list index out of range\n</code></pre> <p>So always make sure your index is within the valid range.</p>"},{"location":"chapters/08-lists/#slicing-getting-multiple-items","title":"Slicing: Getting Multiple Items","text":"<p>What if you want more than one item? List slicing lets you grab a portion of a list using the syntax <code>list[start:stop]</code>. This returns a new list containing items from index <code>start</code> up to (but not including) index <code>stop</code>.</p> <pre><code>fruits = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"]\n\nprint(fruits[1:4])   # ['banana', 'cherry', 'date']\nprint(fruits[0:3])   # ['apple', 'banana', 'cherry']\nprint(fruits[2:])    # ['cherry', 'date', 'elderberry']  (from index 2 to the end)\nprint(fruits[:3])    # ['apple', 'banana', 'cherry']  (from the start to index 3)\nprint(fruits[:])     # A copy of the entire list\n</code></pre> <p>You can also add a step value with <code>list[start:stop:step]</code>:</p> <pre><code>numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nprint(numbers[0:10:2])   # [0, 2, 4, 6, 8]  (every other item)\nprint(numbers[::3])      # [0, 3, 6, 9]  (every third item)\nprint(numbers[::-1])     # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]  (reversed!)\n</code></pre> <p>Here's a quick reference for slicing syntax:</p> Syntax Meaning <code>list[a:b]</code> Items from index <code>a</code> to <code>b-1</code> <code>list[a:]</code> Items from index <code>a</code> to the end <code>list[:b]</code> Items from the start to <code>b-1</code> <code>list[:]</code> A copy of the entire list <code>list[a:b:c]</code> Every <code>c</code>th item from <code>a</code> to <code>b-1</code> <code>list[::-1]</code> The list in reverse"},{"location":"chapters/08-lists/#diagram-list-indexing-and-slicing-explorer","title":"Diagram: List Indexing and Slicing Explorer","text":"List Indexing and Slicing Explorer <p>Type: microsim sim-id: list-index-slice-explorer Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: demonstrate, use</p> <p>Learning Objective: Students will be able to use positive and negative indices to access specific list items and apply slice notation to extract sublists.</p> <p>Purpose: An interactive tool where students type index or slice expressions and immediately see which items are selected from a visual list.</p> <p>Canvas layout: - Top section: Title \"List Indexing &amp; Slicing Explorer\" - A visual horizontal row of 8 colored boxes representing a list: <code>[\"ant\", \"bee\", \"cat\", \"dog\", \"elk\", \"fox\", \"goat\", \"hawk\"]</code> - Above each box: positive index (0-7) - Below each box: negative index (-8 to -1) - An input field labeled \"Enter expression:\" where students type things like <code>[2]</code>, <code>[1:5]</code>, <code>[-3:]</code>, <code>[::2]</code> - A result display showing the Python output - The selected boxes highlight (glow/enlarge) in the visual</p> <p>Interactive elements: - Type any valid index or slice expression and press Enter - Selected items glow bright yellow in the visual row - Preset example buttons: <code>[0]</code>, <code>[-1]</code>, <code>[2:5]</code>, <code>[:3]</code>, <code>[::2]</code>, <code>[::-1]</code> - An \"Explain\" toggle that shows a step-by-step breakdown of how the slice was computed</p> <p>Visual style: Horizontal boxes with item labels inside, index labels above and below in smaller text Color scheme: Default box color is soft blue; selected items highlight in bright gold; error states show red border Responsive: Box sizes adjust for window width</p> <p>Instructional Rationale: Direct manipulation lets students test their understanding of index/slice syntax with immediate visual feedback. The \"Explain\" mode scaffolds learning by showing the computational steps behind each expression. Negative indices and step values are notoriously confusing, and this hands-on approach builds fluency faster than reading alone.</p>"},{"location":"chapters/08-lists/#list-mutability-lists-can-change","title":"List Mutability: Lists Can Change","text":"<p>Here's something that makes lists special compared to strings: list mutability. A mutable object is one you can change after creating it. Lists are mutable, which means you can add items, remove items, or swap out individual elements whenever you want.</p> <pre><code>colors = [\"red\", \"green\", \"blue\"]\ncolors[1] = \"yellow\"       # Replace \"green\" with \"yellow\"\nprint(colors)              # ['red', 'yellow', 'blue']\n</code></pre> <p>Compare this to strings, which are immutable (you can't change them in place):</p> <pre><code>name = \"hello\"\nname[0] = \"H\"    # TypeError! Strings can't be modified\n</code></pre> <p>This mutability is one of the reasons lists are so popular. Think of a list like a whiteboard \u2014 you can erase and rewrite as much as you want. A string is more like a printed poster \u2014 once it's made, you need a whole new poster to change it.</p> <p>You can also replace a range of items using slicing:</p> <pre><code>numbers = [1, 2, 3, 4, 5]\nnumbers[1:4] = [20, 30, 40]\nprint(numbers)  # [1, 20, 30, 40, 5]\n</code></pre>"},{"location":"chapters/08-lists/#list-methods-your-toolkit","title":"List Methods: Your Toolkit","text":"<p>Now let's get to the really good stuff. Python lists come with a bunch of built-in list methods \u2014 special functions attached to lists that let you add, remove, sort, and manipulate items. Think of them as tools in a toolbox, each designed for a specific job.</p> <p>Here's a reference table of the most important list methods:</p> Method What It Does Example Result <code>append(x)</code> Adds <code>x</code> to the end <code>[1, 2].append(3)</code> <code>[1, 2, 3]</code> <code>insert(i, x)</code> Inserts <code>x</code> at index <code>i</code> <code>[1, 3].insert(1, 2)</code> <code>[1, 2, 3]</code> <code>remove(x)</code> Removes the first occurrence of <code>x</code> <code>[1, 2, 3, 2].remove(2)</code> <code>[1, 3, 2]</code> <code>pop(i)</code> Removes and returns item at index <code>i</code> <code>[1, 2, 3].pop(1)</code> Returns <code>2</code>; list becomes <code>[1, 3]</code> <code>sort()</code> Sorts the list in ascending order <code>[3, 1, 2].sort()</code> <code>[1, 2, 3]</code> <code>reverse()</code> Reverses the list in place <code>[1, 2, 3].reverse()</code> <code>[3, 2, 1]</code> <code>index(x)</code> Returns the index of first occurrence of <code>x</code> <code>[10, 20, 30].index(20)</code> <code>1</code> <code>count(x)</code> Counts how many times <code>x</code> appears <code>[1, 2, 2, 3].count(2)</code> <code>2</code> <code>clear()</code> Removes all items <code>[1, 2, 3].clear()</code> <code>[]</code> <code>copy()</code> Returns a shallow copy <code>[1, 2, 3].copy()</code> <code>[1, 2, 3]</code> (new list) <code>extend(L)</code> Adds all items from list <code>L</code> <code>[1, 2].extend([3, 4])</code> <code>[1, 2, 3, 4]</code> <p>Let's look at the most important ones in detail.</p>"},{"location":"chapters/08-lists/#the-append-method","title":"The Append Method","text":"<p>The append method adds a single item to the end of a list. It's like getting in the back of a line \u2014 new items always go last.</p> <pre><code>playlist = [\"Song A\", \"Song B\"]\nplaylist.append(\"Song C\")\nprint(playlist)  # ['Song A', 'Song B', 'Song C']\n\nplaylist.append(\"Song D\")\nprint(playlist)  # ['Song A', 'Song B', 'Song C', 'Song D']\n</code></pre> <p><code>append()</code> is probably the list method you'll use most often. Building a list piece by piece? Start empty and keep appending:</p> <pre><code>squares = []\nfor i in range(1, 6):\n    squares.append(i ** 2)\nprint(squares)  # [1, 4, 9, 16, 25]\n</code></pre>"},{"location":"chapters/08-lists/#the-insert-method","title":"The Insert Method","text":"<p>The insert method lets you add an item at a specific position. It takes two arguments: the index where you want the item to go, and the item itself.</p> <pre><code>guests = [\"Alice\", \"Charlie\", \"Diana\"]\nguests.insert(1, \"Bob\")      # Insert \"Bob\" at index 1\nprint(guests)  # ['Alice', 'Bob', 'Charlie', 'Diana']\n</code></pre> <p>Everything after the insertion point shifts one position to the right to make room. Think of it like cutting in line at a movie theater \u2014 everyone behind you has to take a step back.</p>"},{"location":"chapters/08-lists/#the-remove-method","title":"The Remove Method","text":"<p>The remove method removes the first occurrence of a specified value from the list:</p> <pre><code>colors = [\"red\", \"blue\", \"green\", \"blue\", \"yellow\"]\ncolors.remove(\"blue\")\nprint(colors)  # ['red', 'green', 'blue', 'yellow']\n</code></pre> <p>Notice that only the first \"blue\" was removed. The second \"blue\" is still there. If the value isn't found, Python raises a <code>ValueError</code>:</p> <pre><code>colors.remove(\"purple\")  # ValueError: list.remove(x): x not in list\n</code></pre> <p>Monty says: Watch out!</p> <p> Be careful with <code>remove()</code> \u2014 it only removes the first match, not all of them! If you need to remove every occurrence of a value, you'll need a loop or a list comprehension. Also, calling <code>remove()</code> on a value that isn't in the list will crash your program. Always check first with <code>if value in my_list:</code> before removing.</p>"},{"location":"chapters/08-lists/#the-pop-method","title":"The Pop Method","text":"<p>The pop method removes an item at a given index and returns it. This is handy when you want to use the removed value:</p> <pre><code>tasks = [\"homework\", \"dishes\", \"laundry\", \"coding\"]\ndone = tasks.pop(0)        # Remove and return the first item\nprint(done)                # homework\nprint(tasks)               # ['dishes', 'laundry', 'coding']\n</code></pre> <p>If you call <code>pop()</code> with no argument, it removes and returns the last item:</p> <pre><code>last_task = tasks.pop()\nprint(last_task)           # coding\nprint(tasks)               # ['dishes', 'laundry']\n</code></pre> <p>Think of <code>pop()</code> like a stack of cafeteria trays \u2014 you always take the top one off (the last item added).</p>"},{"location":"chapters/08-lists/#the-sort-method","title":"The Sort Method","text":"<p>The sort method arranges items in ascending order (smallest to largest, A to Z):</p> <pre><code>scores = [85, 92, 78, 95, 88]\nscores.sort()\nprint(scores)  # [78, 85, 88, 92, 95]\n\nnames = [\"Charlie\", \"Alice\", \"Bob\"]\nnames.sort()\nprint(names)  # ['Alice', 'Bob', 'Charlie']\n</code></pre> <p>To sort in descending order, pass <code>reverse=True</code>:</p> <pre><code>scores.sort(reverse=True)\nprint(scores)  # [95, 92, 88, 85, 78]\n</code></pre> <p>Important: <code>sort()</code> modifies the list in place and returns <code>None</code>. If you want a sorted copy without changing the original, use the built-in <code>sorted()</code> function instead:</p> <pre><code>original = [3, 1, 4, 1, 5]\nnew_list = sorted(original)\nprint(original)    # [3, 1, 4, 1, 5]  (unchanged!)\nprint(new_list)    # [1, 1, 3, 4, 5]\n</code></pre>"},{"location":"chapters/08-lists/#the-reverse-method","title":"The Reverse Method","text":"<p>The reverse method flips the list around so the last item becomes the first and vice versa:</p> <pre><code>countdown = [1, 2, 3, 4, 5]\ncountdown.reverse()\nprint(countdown)  # [5, 4, 3, 2, 1]\n</code></pre> <p>Like <code>sort()</code>, <code>reverse()</code> modifies the list in place and returns <code>None</code>.</p>"},{"location":"chapters/08-lists/#diagram-list-methods-playground","title":"Diagram: List Methods Playground","text":"List Methods Playground <p>Type: microsim sim-id: list-methods-playground Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: apply, demonstrate, experiment</p> <p>Learning Objective: Students will be able to apply common list methods (append, insert, remove, pop, sort, reverse) and predict the resulting list state.</p> <p>Purpose: An interactive sandbox where students can apply list methods to a visual list and see the result animated step by step.</p> <p>Canvas layout: - Top section: Title \"List Methods Playground\" - A visual horizontal row of colored boxes representing the current list state - Index labels above each box - Method buttons arranged below the list: \"append\", \"insert\", \"remove\", \"pop\", \"sort\", \"reverse\" - An input field for the value argument (used by append, insert, remove) - An input field for the index argument (used by insert, pop) - A \"History\" panel on the right showing previous operations and their results - A \"Reset\" button to restore the list to its initial state</p> <p>Default list: <code>[64, 25, 12, 78, 36]</code></p> <p>Interactive elements: - Click a method button to apply it to the current list - append: prompts for value, new box slides in from the right with animation - insert: prompts for index and value, box squeezes in at the position and others shift right - remove: prompts for value, the matching box flashes red and disappears, others shift left - pop: prompts for index (optional), the box flies upward and a \"returned value\" label appears - sort: boxes shuffle/slide to their sorted positions with smooth animation - reverse: boxes flip positions with a mirrored animation - History panel logs each operation as Python code (e.g., <code>list.append(42)</code>)</p> <p>Visual style: Rounded rectangle boxes with numbers inside, smooth CSS-style transitions for additions/removals Color scheme: Boxes in various pastel colors, active operation highlighted in gold Responsive: Adjusts box sizes and layout for different screen widths</p> <p>Instructional Rationale: A sandbox environment supports the Apply level by letting students freely experiment with each method and observe the state change. Animated transitions make the \"shift\" behavior of insert/remove visible, which is a common source of confusion. The history panel provides a record for self-review.</p>"},{"location":"chapters/08-lists/#list-comprehensions","title":"List Comprehensions","text":"<p>Ready for one of Python's coolest features? List comprehension is a concise way to create a new list by transforming or filtering items from an existing sequence. It packs a <code>for</code> loop (and optionally an <code>if</code> condition) into a single line.</p> <p>Let's start with a regular loop and then see the comprehension version:</p> <pre><code># Regular loop approach\nsquares = []\nfor x in range(1, 6):\n    squares.append(x ** 2)\nprint(squares)  # [1, 4, 9, 16, 25]\n\n# List comprehension (same result, one line!)\nsquares = [x ** 2 for x in range(1, 6)]\nprint(squares)  # [1, 4, 9, 16, 25]\n</code></pre> <p>The general syntax is:</p> <pre><code>new_list = [expression for item in iterable]\n</code></pre> <p>Read it like a sentence: \"Give me <code>expression</code> for each <code>item</code> in <code>iterable</code>.\"</p> <p>You can also add a filter with an <code>if</code> clause:</p> <pre><code># Only even numbers\nevens = [x for x in range(1, 11) if x % 2 == 0]\nprint(evens)  # [2, 4, 6, 8, 10]\n\n# Uppercase only the long words\nwords = [\"hi\", \"hello\", \"hey\", \"greetings\"]\nlong_words = [w.upper() for w in words if len(w) &gt; 3]\nprint(long_words)  # ['HELLO', 'GREETINGS']\n</code></pre> <p>Here are some more handy examples:</p> Task List Comprehension Squares of 1-10 <code>[x**2 for x in range(1, 11)]</code> Even numbers from a list <code>[x for x in nums if x % 2 == 0]</code> First letters of words <code>[w[0] for w in words]</code> Convert strings to ints <code>[int(s) for s in string_list]</code> Lengths of words <code>[len(w) for w in words]</code> <p>Monty says: Let's debug this together!</p> <p> List comprehensions are powerful, but don't try to cram too much logic into one line. If your comprehension is getting long and hard to read, it's totally fine to use a regular <code>for</code> loop instead. Code clarity beats cleverness every time. Your future self (reading the code six months from now) will thank you!</p>"},{"location":"chapters/08-lists/#nested-lists-and-lists-of-lists","title":"Nested Lists and Lists of Lists","text":"<p>A list can contain anything \u2014 including other lists! When you put a list inside a list, you get a nested list. A collection of lists stored inside an outer list is sometimes called a list of lists.</p> <p>This is super useful for representing grids, tables, and matrix-like data:</p> <pre><code># A 3x3 tic-tac-toe board\nboard = [\n    [\"X\", \"O\", \"X\"],\n    [\"O\", \"X\", \"O\"],\n    [\"O\", \"X\", \"X\"]\n]\n\n# Access a specific cell: row first, then column\nprint(board[0][2])   # X  (row 0, column 2)\nprint(board[1][1])   # X  (row 1, column 1)\nprint(board[2][0])   # O  (row 2, column 0)\n</code></pre> <p>The first index picks the row (the inner list), and the second index picks the item within that row. Think of it like a spreadsheet: <code>board[row][column]</code>.</p> <p>Here's another example \u2014 a gradebook:</p> <pre><code># Each inner list: [student_name, exam1, exam2, exam3]\ngrades = [\n    [\"Alice\", 92, 88, 95],\n    [\"Bob\", 85, 90, 87],\n    [\"Charlie\", 78, 82, 80]\n]\n\n# Get Bob's second exam score\nprint(grades[1][2])  # 90\n\n# Get all of Alice's scores\nprint(grades[0][1:])  # [92, 88, 95]\n</code></pre> <p>You can visualize nested lists like a table:</p> Index [0] Name [1] Exam 1 [2] Exam 2 [3] Exam 3 <code>grades[0]</code> \"Alice\" 92 88 95 <code>grades[1]</code> \"Bob\" 85 90 87 <code>grades[2]</code> \"Charlie\" 78 82 80"},{"location":"chapters/08-lists/#diagram-nested-list-grid-visualizer","title":"Diagram: Nested List Grid Visualizer","text":"Nested List Grid Visualizer <p>Type: microsim sim-id: nested-list-grid Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: interpret, explain</p> <p>Learning Objective: Students will be able to access elements in nested lists using double-index notation and interpret a list of lists as a 2D grid.</p> <p>Purpose: An interactive grid that visualizes a nested list (list of lists) and lets students click on cells to see the double-index expression needed to access each element.</p> <p>Canvas layout: - Top section: Title \"Nested List Grid Visualizer\" - A visual grid of cells representing a 4x4 nested list - Row indices (0-3) labeled on the left - Column indices (0-3) labeled on top - An expression display below the grid showing <code>grid[row][col] = value</code> - A Python code panel showing the full nested list definition - Preset grids: \"Tic-Tac-Toe\", \"Number Grid\", \"Gradebook\"</p> <p>Default grid: </p><pre><code>grid = [\n    [1, 2, 3, 4],\n    [5, 6, 7, 8],\n    [9, 10, 11, 12],\n    [13, 14, 15, 16]\n]\n</code></pre><p></p> <p>Interactive elements: - Click any cell to highlight it and display <code>grid[row][col] = value</code> below - Clicking a row label highlights the entire row and shows <code>grid[row]</code> - A \"Quiz Mode\" button: displays a target expression like <code>grid[2][1]</code> and asks the student to click the correct cell - Preset buttons swap in different grid examples</p> <p>Visual style: Clean grid with labeled axes, selected cells glow gold, row highlight in soft blue Color scheme: Grid cells in alternating light gray and white, indices in dark blue Responsive: Grid cell sizes adjust to window width</p> <p>Instructional Rationale: Clicking individual cells and seeing the double-index expression reinforces the row-then-column access pattern. Quiz Mode provides retrieval practice. Multiple preset grids show that nested lists can represent diverse data types (numbers, strings, mixed).</p>"},{"location":"chapters/08-lists/#list-traversal-walking-through-a-list","title":"List Traversal: Walking Through a List","text":"<p>One of the most common things you'll do with lists is go through each item one at a time. This is called list traversal \u2014 visiting every element in order. Python's <code>for</code> loop makes this incredibly easy.</p>"},{"location":"chapters/08-lists/#for-loop-with-lists","title":"For Loop with Lists","text":"<p>The most basic way to traverse a list is with a for loop:</p> <pre><code>fruits = [\"apple\", \"banana\", \"cherry\", \"date\"]\n\nfor fruit in fruits:\n    print(f\"I like {fruit}!\")\n</code></pre> <pre><code>I like apple!\nI like banana!\nI like cherry!\nI like date!\n</code></pre> <p>On each pass through the loop, the variable <code>fruit</code> takes on the value of the next item in the list. Python handles all the indexing behind the scenes.</p> <p>You can also loop with indices if you need the position:</p> <pre><code>for i in range(len(fruits)):\n    print(f\"Item {i}: {fruits[i]}\")\n</code></pre> <pre><code>Item 0: apple\nItem 1: banana\nItem 2: cherry\nItem 3: date\n</code></pre>"},{"location":"chapters/08-lists/#the-enumerate-function","title":"The Enumerate Function","text":"<p>That <code>range(len(...))</code> pattern works, but Python has a much cleaner solution: the enumerate function. It gives you both the index and the value at the same time:</p> <pre><code>fruits = [\"apple\", \"banana\", \"cherry\", \"date\"]\n\nfor index, fruit in enumerate(fruits):\n    print(f\"{index}: {fruit}\")\n</code></pre> <pre><code>0: apple\n1: banana\n2: cherry\n3: date\n</code></pre> <p>You can even start the count at a different number:</p> <pre><code>for rank, fruit in enumerate(fruits, start=1):\n    print(f\"#{rank}: {fruit}\")\n</code></pre> <pre><code>#1: apple\n#2: banana\n#3: cherry\n#4: date\n</code></pre> <p><code>enumerate()</code> is a favorite among Python programmers. Whenever you need both the position and the value during a loop, reach for <code>enumerate()</code> instead of <code>range(len(...))</code>.</p>"},{"location":"chapters/08-lists/#diagram-list-traversal-animator","title":"Diagram: List Traversal Animator","text":"List Traversal Animator <p>Type: microsim sim-id: list-traversal-animator Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: trace, explain</p> <p>Learning Objective: Students will be able to trace the execution of a for loop over a list and predict the output for each iteration.</p> <p>Purpose: An animated step-through tool that visually shows a pointer moving through a list as a for loop executes, displaying the current variable values and output at each step.</p> <p>Canvas layout: - Top section: Title \"List Traversal Animator\" - Left panel: Python code with the for loop, with the current line highlighted - Center panel: A visual row of list items with a pointer arrow indicating the current element - Right panel: Output console showing printed lines accumulating - Bottom section: Variable watch panel showing the current value of the loop variable and index</p> <p>Code examples (selectable via tabs): 1. Basic for loop: <code>for fruit in fruits: print(fruit)</code> 2. With enumerate: <code>for i, fruit in enumerate(fruits): print(f\"{i}: {fruit}\")</code> 3. With condition: <code>for fruit in fruits: if len(fruit) &gt; 5: print(fruit)</code></p> <p>Interactive controls: - \"Step\" button: Advance one iteration - \"Auto Play\" button: Animate all iterations with a 1-second delay - \"Reset\" button: Return to the start - Speed slider: Adjust animation speed - Tab selector to switch between code examples</p> <p>Visual elements: - Arrow pointer slides from one box to the next during each iteration - Current box glows yellow - Code panel highlights the active line - Output console scrolls as lines are added - Variable watch updates in real-time</p> <p>Visual style: Split-panel layout with code on left, visual in center, output on right Color scheme: Code panel in dark theme, visual list in light pastels, output in monospace green-on-black Responsive: Panels stack vertically on narrow screens</p> <p>Instructional Rationale: Step-by-step animation makes the abstract \"iteration\" concept concrete by showing exactly which element is being accessed on each pass. The variable watch panel reveals what's happening behind the scenes. Multiple code examples let students compare different traversal patterns side by side.</p>"},{"location":"chapters/08-lists/#list-unpacking","title":"List Unpacking","text":"<p>Sometimes you know exactly how many items are in a list, and you want to assign each one to its own variable in a single line. That's called list unpacking (also known as destructuring):</p> <pre><code>coordinates = [42.36, -71.06]\nlatitude, longitude = coordinates\nprint(latitude)    # 42.36\nprint(longitude)   # -71.06\n</code></pre> <p>The number of variables on the left must match the number of items in the list, or you'll get an error:</p> <pre><code>a, b, c = [1, 2]       # ValueError: not enough values to unpack\na, b = [1, 2, 3]       # ValueError: too many values to unpack\n</code></pre> <p>Unpacking is great for swapping values without a temporary variable:</p> <pre><code>x = 10\ny = 20\nx, y = y, x        # Swap!\nprint(x, y)         # 20 10\n</code></pre> <p>You can also use the <code>*</code> operator to capture \"the rest\" of the items:</p> <pre><code>first, *rest = [1, 2, 3, 4, 5]\nprint(first)    # 1\nprint(rest)     # [2, 3, 4, 5]\n\nfirst, *middle, last = [1, 2, 3, 4, 5]\nprint(first)    # 1\nprint(middle)   # [2, 3, 4]\nprint(last)     # 5\n</code></pre> <p>Monty says: Let's code this!</p> <p> List unpacking is especially handy when a function returns multiple values as a list or tuple. Instead of accessing each value by index, you can unpack them into clear, descriptive variable names. Readable code is happy code!</p>"},{"location":"chapters/08-lists/#the-zip-function","title":"The Zip Function","text":"<p>The zip function combines two (or more) lists element by element, pairing up items at the same index. It's like a zipper on a jacket \u2014 it links two sides together, tooth by tooth.</p> <pre><code>names = [\"Alice\", \"Bob\", \"Charlie\"]\nscores = [92, 85, 78]\n\nfor name, score in zip(names, scores):\n    print(f\"{name}: {score}\")\n</code></pre> <pre><code>Alice: 92\nBob: 85\nCharlie: 78\n</code></pre> <p><code>zip()</code> creates pairs (technically tuples) from corresponding items:</p> <pre><code>paired = list(zip(names, scores))\nprint(paired)  # [('Alice', 92), ('Bob', 85), ('Charlie', 78)]\n</code></pre> <p>You can zip more than two lists:</p> <pre><code>names = [\"Alice\", \"Bob\", \"Charlie\"]\nscores = [92, 85, 78]\ngrades = [\"A\", \"B\", \"C+\"]\n\nfor name, score, grade in zip(names, scores, grades):\n    print(f\"{name} scored {score} ({grade})\")\n</code></pre> <pre><code>Alice scored 92 (A)\nBob scored 85 (B)\nCharlie scored 78 (C+)\n</code></pre> <p>If the lists have different lengths, <code>zip()</code> stops at the shortest one:</p> <pre><code>short = [1, 2]\nlong = [10, 20, 30, 40]\nprint(list(zip(short, long)))  # [(1, 10), (2, 20)]\n</code></pre>"},{"location":"chapters/08-lists/#diagram-zip-function-visualizer","title":"Diagram: Zip Function Visualizer","text":"Zip Function Visualizer <p>Type: microsim sim-id: zip-function-visualizer Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: illustrate, explain</p> <p>Learning Objective: Students will be able to use the zip function to combine multiple lists element by element and predict the output of zip operations.</p> <p>Purpose: An animated visualization that shows how zip() pairs up elements from two or three lists, with a zipper metaphor.</p> <p>Canvas layout: - Top section: Title \"Zip Function Visualizer\" - Two (or three) vertical columns representing input lists, with items as labeled boxes - A central \"zipper\" animation zone - Below the zipper: the output \u2014 a row of paired tuples - Editable input fields to customize list contents - Toggle: \"2 Lists\" / \"3 Lists\"</p> <p>Interactive elements: - \"Zip!\" button: Animates the pairing process \u2014 items from each list slide toward the center and merge into tuple boxes - Editable text fields for each list's contents (comma-separated) - A \"Different Lengths\" toggle to demonstrate truncation behavior - Step mode: Pair one element at a time with the \"Step\" button</p> <p>Animation sequence: 1. Items from corresponding positions glow and slide toward center simultaneously 2. They merge into a tuple box at the center 3. The tuple slides down into the output row 4. Repeat for each pair 5. If lists have different lengths, remaining items in the longer list are grayed out with a \"skipped\" label</p> <p>Visual style: Zipper teeth metaphor with interlocking shapes, smooth slide animations Color scheme: List 1 in blue, List 2 in green, List 3 in orange; paired tuples in purple Responsive: Columns stack and resize for different window widths</p> <p>Instructional Rationale: The zipper metaphor makes the pairing behavior intuitive and memorable. Animating the merge step-by-step reveals the element-by-element correspondence that defines zip(). Showing the truncation behavior for unequal lengths prevents a common source of bugs. Editable inputs let students test their own data.</p>"},{"location":"chapters/08-lists/#common-patterns-and-recipes","title":"Common Patterns and Recipes","text":"<p>Before we wrap up, here are some everyday patterns you'll use with lists all the time. Think of these as recipes you can pull out whenever you need them.</p> <p>Finding the sum and average:</p> <pre><code>scores = [85, 92, 78, 95, 88]\ntotal = sum(scores)\naverage = total / len(scores)\nprint(f\"Average: {average}\")  # Average: 87.6\n</code></pre> <p>Finding the minimum and maximum:</p> <pre><code>print(min(scores))   # 78\nprint(max(scores))   # 95\n</code></pre> <p>Checking membership:</p> <pre><code>fruits = [\"apple\", \"banana\", \"cherry\"]\nprint(\"banana\" in fruits)      # True\nprint(\"grape\" in fruits)       # False\nprint(\"grape\" not in fruits)   # True\n</code></pre> <p>Concatenating lists:</p> <pre><code>list1 = [1, 2, 3]\nlist2 = [4, 5, 6]\ncombined = list1 + list2\nprint(combined)  # [1, 2, 3, 4, 5, 6]\n</code></pre> <p>Repeating lists:</p> <pre><code>zeros = [0] * 5\nprint(zeros)  # [0, 0, 0, 0, 0]\n</code></pre> <p>Converting between strings and lists:</p> <pre><code># String to list of words\nsentence = \"Python lists are awesome\"\nwords = sentence.split()\nprint(words)  # ['Python', 'lists', 'are', 'awesome']\n\n# List of words back to string\njoined = \" \".join(words)\nprint(joined)  # Python lists are awesome\n</code></pre> <p>Monty says: You've got this!</p> <p> You just leveled up big time! Lists are the backbone of Python programming, and you now know how to create them, index them, slice them, modify them, sort them, loop through them, and even nest them. In the next chapter, we'll explore advanced list operations that build on everything you learned here. Keep it up, coder!</p>"},{"location":"chapters/08-lists/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>A list is an ordered, mutable collection of items enclosed in square brackets <code>[]</code>.</li> <li>Indexing starts at 0. Use negative indices to count from the end (<code>-1</code> is the last item).</li> <li>Slicing with <code>list[start:stop:step]</code> extracts a sublist without modifying the original.</li> <li>Lists are mutable \u2014 you can change, add, and remove items after creation.</li> <li>Key list methods: <code>append()</code> adds to the end, <code>insert()</code> adds at a position, <code>remove()</code> deletes by value, <code>pop()</code> deletes by index and returns the item, <code>sort()</code> orders items, <code>reverse()</code> flips the order.</li> <li>List comprehensions create lists concisely: <code>[expression for item in iterable if condition]</code>.</li> <li>Nested lists (lists of lists) represent 2D data like grids and tables. Access elements with double indexing: <code>grid[row][col]</code>.</li> <li>Traverse lists with for loops. Use <code>enumerate()</code> when you need both the index and value.</li> <li>List unpacking assigns list items to individual variables in one line.</li> <li>The <code>zip()</code> function combines multiple lists element by element into pairs.</li> </ul> Check Your Understanding: What does <code>fruits[1:4]</code> return if <code>fruits = ['apple', 'banana', 'cherry', 'date', 'elderberry']</code>? <p>It returns <code>['banana', 'cherry', 'date']</code>. Remember, slicing goes from the start index up to (but not including) the stop index. So index 1 through index 3 are included.</p> Check Your Understanding: What's the difference between <code>list.sort()</code> and <code>sorted(list)</code>? <p><code>list.sort()</code> modifies the original list in place and returns <code>None</code>. <code>sorted(list)</code> creates and returns a new sorted list, leaving the original unchanged. Use <code>sort()</code> when you don't need the original order anymore; use <code>sorted()</code> when you want to keep the original list intact.</p> Check Your Understanding: What does this list comprehension produce: <code>[x * 2 for x in range(5) if x % 2 == 0]</code>? <p>It produces <code>[0, 4, 8]</code>. Here's the breakdown: <code>range(5)</code> gives <code>[0, 1, 2, 3, 4]</code>. The <code>if x % 2 == 0</code> filter keeps only the even numbers: <code>[0, 2, 4]</code>. Then <code>x * 2</code> doubles each one: <code>[0, 4, 8]</code>.</p>"},{"location":"chapters/09-advanced-list-operations/","title":"Advanced List Operations","text":""},{"location":"chapters/09-advanced-list-operations/#advanced-list-operations","title":"Advanced List Operations","text":""},{"location":"chapters/09-advanced-list-operations/#summary","title":"Summary","text":"<p>This chapter deepens the understanding of Python lists with advanced operations. Students will learn about shallow and deep copying, list concatenation and repetition, the sorted function, using lists as stacks and queues, and the important distinction between aliasing (identity) and equality. These concepts are critical for writing correct programs that manipulate collections of data.</p>"},{"location":"chapters/09-advanced-list-operations/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 15 concepts from the learning graph:</p> <ol> <li>List Copying</li> <li>Shallow Copy</li> <li>Deep Copy</li> <li>List Concatenation</li> <li>List Repetition</li> <li>In Operator for Lists</li> <li>Index Method</li> <li>Count Method</li> <li>Min Max Sum Functions</li> <li>Len Function for Lists</li> <li>Sorted Function</li> <li>List as Stack</li> <li>List as Queue</li> <li>List Aliasing</li> <li>Identity vs Equality</li> </ol>"},{"location":"chapters/09-advanced-list-operations/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 2: Python Fundamentals</li> <li>Chapter 5: Working with Strings</li> <li>Chapter 8: Lists</li> </ul> <p>Monty says: Let's code this!</p> <p> Welcome back, coders! In the last chapter you learned how to create lists, add items, remove items, and loop through them. Now it's time to level up. This chapter is all about the advanced moves \u2014 the kind of list tricks that separate beginners from confident Python programmers. You'll learn how to copy lists without nasty surprises, search and summarize data like a pro, and even use lists as stacks and queues. Let's do this!</p>"},{"location":"chapters/09-advanced-list-operations/#the-danger-of-copying-lists","title":"The Danger of Copying Lists","text":"<p>In Chapter 8, you learned that a list is a collection of items stored in a single variable. But here's a question that trips up many new programmers: how do you make a copy of a list?</p> <p>Your first instinct might be to write something like this:</p> <pre><code>original = [1, 2, 3]\ncopy = original\n</code></pre> <p>Seems reasonable, right? You've got <code>original</code> and you've made <code>copy</code>. But watch what happens:</p> <pre><code>copy.append(4)\nprint(original)  # [1, 2, 3, 4]  \u2190 Wait, what?!\n</code></pre> <p>Adding <code>4</code> to <code>copy</code> also added it to <code>original</code>! That's not a copy at all. What went wrong?</p>"},{"location":"chapters/09-advanced-list-operations/#list-aliasing","title":"List Aliasing","text":"<p>What actually happened is called list aliasing. When you write <code>copy = original</code>, Python doesn't create a new list. Instead, it makes both variable names point to the same list object in memory. It's like having two name tags pinned to the same shirt. If you spill coffee on the shirt, both name tags get stained.</p> <pre><code>original = [1, 2, 3]\nalias = original\n\n# Both names point to the SAME list\nalias.append(4)\nprint(original)  # [1, 2, 3, 4]\nprint(alias)     # [1, 2, 3, 4]\n</code></pre> <p>This is a feature, not a bug \u2014 but it can definitely surprise you if you don't expect it. Aliasing is useful when you want two variables to share the same data, but it's a common source of bugs when you actually wanted an independent copy.</p> <p>You can verify that two variables are aliases using the <code>is</code> keyword:</p> <pre><code>print(original is alias)  # True \u2014 same object in memory\n</code></pre>"},{"location":"chapters/09-advanced-list-operations/#diagram-list-aliasing-visualizer","title":"Diagram: List Aliasing Visualizer","text":"List Aliasing Visualizer <p>Type: microsim sim-id: list-aliasing-visualizer Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: explain, illustrate</p> <p>Learning Objective: Students will be able to explain the difference between creating an alias and creating an independent copy by observing how variable names point to objects in memory.</p> <p>Purpose: A visual memory diagram that shows how variable names map to list objects. When the student creates an alias, both names point to the same box. When the student creates a copy, a second box appears.</p> <p>Layout:</p> <ul> <li>Left panel: A code editor area showing a short Python snippet (editable via dropdown presets)</li> <li>Right panel: A memory diagram with labeled variable boxes and arrow connections to list objects</li> <li>List objects displayed as rows of cells showing the elements</li> </ul> <p>Preset Code Options (dropdown):</p> <ol> <li>Alias: <code>a = [1,2,3]; b = a</code></li> <li>Slice copy: <code>a = [1,2,3]; b = a[:]</code></li> <li>list() copy: <code>a = [1,2,3]; b = list(a)</code></li> <li>.copy(): <code>a = [1,2,3]; b = a.copy()</code></li> </ol> <p>Interactive elements:</p> <ul> <li>Dropdown to select the code preset; the memory diagram updates instantly</li> <li>\"Append to b\" button: Appends a value to <code>b</code> and animates the change in the diagram</li> <li>After appending, the diagram shows whether <code>a</code> was also affected (alias) or not (copy)</li> <li>Color coding: shared objects in red, independent objects in green</li> </ul> <p>Visual style: Clean boxes with arrows, inspired by Python Tutor memory diagrams Responsive: Panels stack vertically on narrow screens</p> <p>Instructional Rationale: Seeing the memory model makes the abstract concept of aliasing concrete. Comparing side-by-side presets lets students discover the rule themselves rather than memorizing it.</p>"},{"location":"chapters/09-advanced-list-operations/#identity-vs-equality","title":"Identity vs. Equality","text":"<p>This is a great time to talk about one of Python's most important \u2014 and most confusing \u2014 distinctions: identity vs. equality.</p> <ul> <li>Equality (<code>==</code>) asks: \"Do these two variables have the same value?\"</li> <li>Identity (<code>is</code>) asks: \"Do these two variables point to the same object in memory?\"</li> </ul> <p>Here's the difference in action:</p> <pre><code>a = [1, 2, 3]\nb = [1, 2, 3]\nc = a\n\nprint(a == b)  # True  \u2014 same values\nprint(a is b)  # False \u2014 different objects in memory\nprint(a == c)  # True  \u2014 same values\nprint(a is c)  # True  \u2014 same object in memory (alias!)\n</code></pre> <p>Even though <code>a</code> and <code>b</code> contain the exact same numbers, they are two separate list objects. Python created one list for <code>a</code> and a completely different list for <code>b</code> that just happens to contain the same items. They're equal but not identical.</p> <p>Think of it like identical twins. They look the same (equal), but they're still two different people (not identical in the identity sense). Meanwhile, <code>a</code> and <code>c</code> are the same person with two nicknames.</p> <p>Here's a handy reference table:</p> Operator Question It Answers Example Result <code>==</code> Same values? <code>[1,2] == [1,2]</code> <code>True</code> <code>is</code> Same object? <code>a is b</code> (different lists) <code>False</code> <code>!=</code> Different values? <code>[1,2] != [3,4]</code> <code>True</code> <code>is not</code> Different objects? <code>a is not b</code> <code>True</code> <p>Monty says: Let's debug this together!</p> <p> A very common bug is using <code>is</code> when you mean <code>==</code>. Always use <code>==</code> to compare list contents. The <code>is</code> operator checks identity (same object in memory), which is almost never what you want when comparing lists. Save <code>is</code> for special cases like checking <code>if x is None</code>.</p>"},{"location":"chapters/09-advanced-list-operations/#copying-lists-the-right-way","title":"Copying Lists the Right Way","text":"<p>Now that you understand aliasing, let's talk about list copying \u2014 making a truly independent copy of a list so you can modify one without affecting the other.</p>"},{"location":"chapters/09-advanced-list-operations/#shallow-copy","title":"Shallow Copy","text":"<p>A shallow copy creates a new list object and fills it with references to the same elements as the original. For a list of simple values (numbers, strings, booleans), a shallow copy works perfectly.</p> <p>There are several ways to make a shallow copy:</p> <pre><code>original = [10, 20, 30]\n\n# Method 1: The .copy() method\ncopy1 = original.copy()\n\n# Method 2: Slicing with [:]\ncopy2 = original[:]\n\n# Method 3: The list() constructor\ncopy3 = list(original)\n</code></pre> <p>All three methods produce the same result \u2014 a brand new list with the same elements:</p> <pre><code>copy1.append(40)\nprint(original)  # [10, 20, 30]  \u2190 unchanged!\nprint(copy1)     # [10, 20, 30, 40]\n</code></pre> <p>Success! Modifying <code>copy1</code> didn't touch <code>original</code>. But there's a catch.</p>"},{"location":"chapters/09-advanced-list-operations/#the-shallow-copy-trap","title":"The Shallow Copy Trap","text":"<p>A shallow copy works great for \"flat\" lists (lists of numbers, strings, etc.). But what about nested lists \u2014 lists that contain other lists?</p> <pre><code>matrix = [[1, 2], [3, 4], [5, 6]]\nshallow = matrix.copy()\n\nshallow[0][0] = 99\nprint(matrix)   # [[99, 2], [3, 4], [5, 6]]  \u2190 Yikes!\n</code></pre> <p>Even though <code>shallow</code> is a separate list, the inner lists <code>[1, 2]</code>, <code>[3, 4]</code>, and <code>[5, 6]</code> are still shared between <code>matrix</code> and <code>shallow</code>. A shallow copy only copies the top level. It's like photocopying a folder of documents \u2014 you get a new folder, but the documents inside are the same physical pages.</p>"},{"location":"chapters/09-advanced-list-operations/#deep-copy","title":"Deep Copy","text":"<p>When you need a completely independent copy of a nested list (or any complex structure), you need a deep copy. A deep copy recursively copies everything \u2014 the list, its inner lists, and their elements too.</p> <p>Python provides deep copy through the <code>copy</code> module:</p> <pre><code>import copy\n\nmatrix = [[1, 2], [3, 4], [5, 6]]\ndeep = copy.deepcopy(matrix)\n\ndeep[0][0] = 99\nprint(matrix)  # [[1, 2], [3, 4], [5, 6]]  \u2190 safe!\nprint(deep)    # [[99, 2], [3, 4], [5, 6]]\n</code></pre> <p>Now <code>matrix</code> and <code>deep</code> are completely independent. Changing one has zero effect on the other.</p> <p>Here's a summary of when to use each:</p> Scenario Method Why Flat list (numbers, strings) <code>.copy()</code>, <code>[:]</code>, or <code>list()</code> Shallow copy is enough \u2014 no nested objects to worry about Nested list (list of lists) <code>copy.deepcopy()</code> Deep copy ensures inner lists are also independent Intentional sharing <code>alias = original</code> You want both names to point to the same list"},{"location":"chapters/09-advanced-list-operations/#diagram-shallow-vs-deep-copy-visualizer","title":"Diagram: Shallow vs Deep Copy Visualizer","text":"Shallow vs Deep Copy Visualizer <p>Type: microsim sim-id: shallow-vs-deep-copy Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: compare, distinguish</p> <p>Learning Objective: Students will be able to distinguish between shallow and deep copying by observing how changes to nested elements propagate (or don't) in each type of copy.</p> <p>Purpose: A side-by-side memory diagram comparing a shallow copy and a deep copy of a nested list. Students can click to modify an inner element and see which copy is affected.</p> <p>Layout:</p> <ul> <li>Top: A shared \"Original\" nested list display: <code>[[1, 2], [3, 4]]</code></li> <li>Left side: \"Shallow Copy\" panel with its own memory diagram</li> <li>Right side: \"Deep Copy\" panel with its own memory diagram</li> <li>Each panel shows variable boxes, arrows to list objects, and arrows from outer list cells to inner list objects</li> </ul> <p>Interactive elements:</p> <ul> <li>\"Copy\" button: Creates both a shallow and deep copy simultaneously, animating the creation of new boxes/arrows</li> <li>\"Modify inner element\" button: Changes <code>copy[0][0]</code> to 99 in both panels; the shallow copy's change propagates to the original (shown with a red flash), while the deep copy's change does not (green flash)</li> <li>\"Reset\" button: Restores original state</li> <li>Hover over any cell to see its memory address label</li> </ul> <p>Visual style: Memory boxes with arrows; shared objects highlighted in orange; independent objects in green Responsive: Panels stack on narrow screens</p> <p>Instructional Rationale: Side-by-side visual comparison is the most effective way to teach this distinction. Students can predict the outcome before clicking, then verify \u2014 supporting the Understand/distinguish objective.</p> <p>Monty says: You've got this!</p> <p> Here's a quick rule of thumb: if your list only contains numbers, strings, or booleans, a shallow copy is fine. If your list contains other lists (or any mutable objects), reach for <code>copy.deepcopy()</code> to be safe. When in doubt, deep copy it out!</p>"},{"location":"chapters/09-advanced-list-operations/#combining-and-repeating-lists","title":"Combining and Repeating Lists","text":"<p>Now that you can safely copy lists, let's look at some ways to build bigger lists from smaller ones.</p>"},{"location":"chapters/09-advanced-list-operations/#list-concatenation","title":"List Concatenation","text":"<p>List concatenation is just a fancy word for \"joining two lists together.\" You use the <code>+</code> operator, just like adding numbers \u2014 but instead of math, you're gluing lists end to end.</p> <pre><code>fruits = [\"apple\", \"banana\"]\nveggies = [\"carrot\", \"pea\"]\ngroceries = fruits + veggies\nprint(groceries)  # ['apple', 'banana', 'carrot', 'pea']\n</code></pre> <p>The original lists are unchanged \u2014 concatenation always creates a new list. You can also use <code>+=</code> to extend a list in place:</p> <pre><code>fruits += [\"cherry\"]\nprint(fruits)  # ['apple', 'banana', 'cherry']\n</code></pre> <p>This is equivalent to <code>fruits.extend([\"cherry\"])</code>, which you learned in Chapter 8.</p>"},{"location":"chapters/09-advanced-list-operations/#list-repetition","title":"List Repetition","text":"<p>List repetition uses the <code>*</code> operator to repeat a list multiple times. It's great for initializing lists with default values.</p> <pre><code>zeros = [0] * 5\nprint(zeros)  # [0, 0, 0, 0, 0]\n\npattern = [1, 2] * 3\nprint(pattern)  # [1, 2, 1, 2, 1, 2]\n</code></pre> <p>This is a real time-saver. Instead of typing out <code>[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</code>, you just write <code>[0] * 10</code>. Much cleaner.</p> <p>But watch out for a sneaky trap with nested lists:</p> <pre><code># This looks like it creates 3 independent rows...\ngrid = [[0, 0]] * 3\ngrid[0][0] = 99\nprint(grid)  # [[99, 0], [99, 0], [99, 0]]  \u2190 All three changed!\n</code></pre> <p>The <code>*</code> operator copies references, not values. All three rows point to the same inner list \u2014 just like aliasing! To create truly independent rows, use a list comprehension instead:</p> <pre><code>grid = [[0, 0] for _ in range(3)]\ngrid[0][0] = 99\nprint(grid)  # [[99, 0], [0, 0], [0, 0]]  \u2190 Only the first row changed\n</code></pre> <p>Here's a quick comparison of combining operations:</p> Operation Syntax Result Concatenation <code>[1, 2] + [3, 4]</code> <code>[1, 2, 3, 4]</code> Repetition <code>[0] * 3</code> <code>[0, 0, 0]</code> Extend in place <code>a += [5, 6]</code> <code>a</code> is modified"},{"location":"chapters/09-advanced-list-operations/#searching-and-querying-lists","title":"Searching and Querying Lists","text":"<p>Python gives you several powerful tools for finding things in a list and asking questions about its contents.</p>"},{"location":"chapters/09-advanced-list-operations/#the-in-operator","title":"The In Operator","text":"<p>The in operator checks whether a value exists in a list. It returns <code>True</code> or <code>False</code>:</p> <pre><code>colors = [\"red\", \"green\", \"blue\"]\nprint(\"green\" in colors)   # True\nprint(\"yellow\" in colors)  # False\nprint(\"red\" not in colors) # False\n</code></pre> <p>This is incredibly useful in <code>if</code> statements:</p> <pre><code>menu = [\"pizza\", \"burger\", \"salad\", \"tacos\"]\norder = \"tacos\"\n\nif order in menu:\n    print(f\"Great choice! One {order} coming up!\")\nelse:\n    print(f\"Sorry, we don't have {order}.\")\n</code></pre> <p>The <code>in</code> operator works by checking each item from left to right. For a list with (n) items, this takes up to (n) comparisons in the worst case \u2014 what computer scientists call (O(n)) time.</p>"},{"location":"chapters/09-advanced-list-operations/#the-index-method","title":"The Index Method","text":"<p>The index method tells you where a value appears in a list. It returns the position (index) of the first occurrence:</p> <pre><code>animals = [\"cat\", \"dog\", \"bird\", \"dog\", \"fish\"]\nprint(animals.index(\"dog\"))   # 1 (first occurrence)\nprint(animals.index(\"fish\"))  # 4\n</code></pre> <p>If the value isn't in the list, you'll get a <code>ValueError</code>:</p> <pre><code># animals.index(\"elephant\")  # ValueError: 'elephant' is not in list\n</code></pre> <p>A safe pattern is to check with <code>in</code> before calling <code>.index()</code>:</p> <pre><code>if \"elephant\" in animals:\n    pos = animals.index(\"elephant\")\nelse:\n    print(\"Not found!\")\n</code></pre>"},{"location":"chapters/09-advanced-list-operations/#the-count-method","title":"The Count Method","text":"<p>The count method tells you how many times a value appears in a list:</p> <pre><code>votes = [\"yes\", \"no\", \"yes\", \"yes\", \"no\", \"yes\"]\nprint(votes.count(\"yes\"))  # 4\nprint(votes.count(\"no\"))   # 2\nprint(votes.count(\"maybe\"))  # 0\n</code></pre> <p>This is handy for tallying results, counting duplicates, or checking if something is unique:</p> <pre><code>grades = [90, 85, 90, 78, 92, 90]\nif grades.count(90) &gt; 1:\n    print(\"There are multiple 90s!\")\n</code></pre> <p>Here's a summary of the search methods:</p> Method Purpose Returns If Not Found <code>x in list</code> Check existence <code>True</code> / <code>False</code> Returns <code>False</code> <code>list.index(x)</code> Find position Integer index Raises <code>ValueError</code> <code>list.count(x)</code> Count occurrences Integer count Returns <code>0</code>"},{"location":"chapters/09-advanced-list-operations/#built-in-list-functions","title":"Built-In List Functions","text":"<p>Python comes with several built-in functions that work on lists right out of the box. These are your power tools for summarizing and measuring data.</p>"},{"location":"chapters/09-advanced-list-operations/#the-len-function","title":"The Len Function","text":"<p>The len function returns the number of items in a list. You've probably already used this one, but it's worth a quick review:</p> <pre><code>scores = [88, 92, 75, 100, 64]\nprint(len(scores))  # 5\n\nempty = []\nprint(len(empty))   # 0\n</code></pre> <p><code>len()</code> is one of the most frequently used functions in Python. You'll use it constantly with loops, conditions, and calculations:</p> <pre><code># Calculate average score\ntotal = sum(scores)\naverage = total / len(scores)\nprint(f\"Average: {average}\")  # Average: 83.8\n</code></pre>"},{"location":"chapters/09-advanced-list-operations/#min-max-and-sum-functions","title":"Min, Max, and Sum Functions","text":"<p>The min, max, and sum functions do exactly what their names suggest:</p> <pre><code>temps = [72, 68, 75, 80, 65, 71]\n\nprint(min(temps))  # 65 \u2014 coldest temperature\nprint(max(temps))  # 80 \u2014 hottest temperature\nprint(sum(temps))  # 431 \u2014 total of all temperatures\n</code></pre> <p>These functions work on any list of comparable items. For strings, <code>min()</code> and <code>max()</code> use alphabetical order:</p> <pre><code>names = [\"Zara\", \"Alice\", \"Milo\"]\nprint(min(names))  # 'Alice'\nprint(max(names))  # 'Zara'\n</code></pre> <p>You can combine these functions for powerful one-liners:</p> <pre><code>scores = [88, 92, 75, 100, 64]\n\naverage = sum(scores) / len(scores)\nscore_range = max(scores) - min(scores)\n\nprint(f\"Average: {average}\")       # Average: 83.8\nprint(f\"Range: {score_range}\")     # Range: 36\n</code></pre> <p>In math, the range of a dataset is defined as:</p> <p>[ \\text{range} = \\max(x) - \\min(x) ]</p> <p>And the mean (average) is:</p> <p>[ \\bar{x} = \\frac{\\sum_{i=1}^{n} x_i}{n} ]</p> <p>Python makes computing both of these trivial with <code>max()</code>, <code>min()</code>, <code>sum()</code>, and <code>len()</code>.</p>"},{"location":"chapters/09-advanced-list-operations/#diagram-list-statistics-dashboard","title":"Diagram: List Statistics Dashboard","text":"List Statistics Dashboard MicroSim <p>Type: microsim sim-id: list-statistics-dashboard Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: calculate, use</p> <p>Learning Objective: Students will be able to use len, min, max, and sum to compute basic statistics on a list of numbers and interpret the results visually.</p> <p>Purpose: An interactive dashboard where students enter or generate a list of numbers and see real-time calculations of len, min, max, sum, and average displayed both numerically and as a bar chart.</p> <p>Layout:</p> <ul> <li>Top: Input area \u2014 a text field where students can type comma-separated numbers, plus a \"Random List\" button</li> <li>Middle: A horizontal bar chart showing each number in the list</li> <li>Bottom: A statistics panel showing:</li> <li><code>len()</code> result</li> <li><code>min()</code> result (highlighted on the bar chart in blue)</li> <li><code>max()</code> result (highlighted on the bar chart in red)</li> <li><code>sum()</code> result</li> <li>Average (sum/len) with a dashed line drawn across the bar chart</li> </ul> <p>Interactive elements:</p> <ul> <li>Type numbers into the text field and press Enter to update the chart</li> <li>\"Random List\" button generates 5-10 random integers between 1 and 100</li> <li>\"Add Number\" button adds a new random number to the existing list</li> <li>\"Remove Last\" button removes the last number</li> <li>All statistics update in real time as the list changes</li> <li>Hovering over a bar shows that number's value</li> </ul> <p>Visual style: Clean dashboard with soft colors, sans-serif fonts Color scheme: Bars in light green; min bar in blue; max bar in red; average line as dashed orange Responsive: Chart scales with window width</p> <p>Instructional Rationale: Manipulating the list and immediately seeing the statistics update builds intuitive understanding of how len, min, max, and sum relate to the data. The visual bar chart makes abstract statistics concrete.</p>"},{"location":"chapters/09-advanced-list-operations/#sorting-lists","title":"Sorting Lists","text":"<p>In Chapter 8, you learned about the <code>.sort()</code> method, which sorts a list in place. Now let's meet its cousin.</p>"},{"location":"chapters/09-advanced-list-operations/#the-sorted-function","title":"The Sorted Function","text":"<p>The sorted function is a built-in function that returns a new sorted list without modifying the original:</p> <pre><code>scores = [88, 45, 92, 73, 100]\n\nordered = sorted(scores)\nprint(ordered)  # [45, 73, 88, 92, 100]\nprint(scores)   # [88, 45, 92, 73, 100]  \u2190 unchanged!\n</code></pre> <p>This is the key difference:</p> Feature <code>.sort()</code> method <code>sorted()</code> function Modifies original? Yes (in place) No (returns new list) Return value <code>None</code> A new sorted list Works on Lists only Any iterable (lists, tuples, strings, etc.) <p>The <code>sorted()</code> function accepts two useful optional arguments:</p> <pre><code># Reverse order\nprint(sorted(scores, reverse=True))  # [100, 92, 88, 73, 45]\n\n# Custom sort key\nwords = [\"banana\", \"apple\", \"cherry\", \"date\"]\nprint(sorted(words, key=len))  # ['date', 'apple', 'banana', 'cherry']\n</code></pre> <p>The <code>key=len</code> argument tells Python to sort by the length of each word instead of alphabetical order. You can use any function as a key \u2014 this makes <code>sorted()</code> incredibly flexible.</p> <p>Monty says: Let's debug this together!</p> <p> Use <code>sorted()</code> when you need the original list to stay unchanged. Use <code>.sort()</code> when you don't need the original order anymore. A common mistake is writing <code>my_list = my_list.sort()</code> \u2014 this sets <code>my_list</code> to <code>None</code> because <code>.sort()</code> returns <code>None</code>!</p>"},{"location":"chapters/09-advanced-list-operations/#lists-as-data-structures","title":"Lists as Data Structures","text":"<p>One of the coolest things about Python lists is that they're flexible enough to act as other data structures. Two of the most important ones in computer science are stacks and queues.</p>"},{"location":"chapters/09-advanced-list-operations/#list-as-stack","title":"List as Stack","text":"<p>A stack is a data structure that follows the LIFO principle: Last In, First Out. Think of a stack of plates in a cafeteria. You always take the plate from the top of the stack, and you always add new plates on top. The last plate placed on the stack is the first one removed.</p> <pre><code>    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  plate 3  \u2502  \u2190 top (added last, removed first)\n    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    \u2502  plate 2  \u2502\n    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    \u2502  plate 1  \u2502  \u2190 bottom (added first, removed last)\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>In Python, you can use a list as a stack with two operations:</p> <ul> <li>Push (add to top): <code>list.append(item)</code></li> <li>Pop (remove from top): <code>list.pop()</code></li> </ul> <pre><code>stack = []\n\n# Push items onto the stack\nstack.append(\"pancake 1\")\nstack.append(\"pancake 2\")\nstack.append(\"pancake 3\")\nprint(stack)  # ['pancake 1', 'pancake 2', 'pancake 3']\n\n# Pop items off the stack (LIFO order)\ntop = stack.pop()\nprint(top)    # 'pancake 3'  \u2190 last one added, first one removed\nprint(stack)  # ['pancake 1', 'pancake 2']\n</code></pre> <p>Stacks show up everywhere in computing:</p> <ul> <li>Undo/Redo in text editors \u2014 each action is pushed onto a stack; pressing Ctrl+Z pops the most recent one</li> <li>Browser back button \u2014 pages you visit are pushed onto a stack; clicking \"back\" pops the most recent page</li> <li>Function calls \u2014 Python itself uses a \"call stack\" to keep track of which functions are running</li> </ul>"},{"location":"chapters/09-advanced-list-operations/#diagram-stack-simulator","title":"Diagram: Stack Simulator","text":"Stack Simulator MicroSim <p>Type: microsim sim-id: stack-simulator Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: demonstrate, use</p> <p>Learning Objective: Students will be able to demonstrate LIFO (Last In, First Out) behavior by pushing and popping items on a visual stack and predicting the next item to be removed.</p> <p>Purpose: An interactive stack visualization where students push and pop items, seeing the stack grow and shrink visually. Includes a \"predict\" mode where students guess which item will be popped next.</p> <p>Layout:</p> <ul> <li>Center: A vertical stack of rectangular blocks, growing upward from a base platform</li> <li>Each block displays the item value and the order it was pushed (e.g., \"#1: pancake\")</li> <li>Left panel: \"Push\" controls \u2014 a text input and \"Push\" button</li> <li>Right panel: \"Pop\" button and a display area showing the most recently popped item</li> <li>Bottom: A history log of all push/pop operations</li> </ul> <p>Interactive elements:</p> <ul> <li>Type a value and click \"Push\" to add it to the top of the stack (animated slide-in from above)</li> <li>Click \"Pop\" to remove the top item (animated slide-out)</li> <li>\"Predict Mode\" toggle: Before popping, the student must type which item they think will be removed; the sim shows correct/incorrect feedback</li> <li>\"Clear\" button resets the stack</li> </ul> <p>Visual style: Colorful blocks stacked vertically; new items slide in from above; popped items slide out and fade Color scheme: Each block gets a unique color from a palette; top block has a subtle glow Responsive: Stack scales to fit window height</p> <p>Instructional Rationale: Hands-on push/pop interaction with animated feedback makes the LIFO principle intuitive. Predict mode encourages students to internalize the ordering rule before seeing the answer.</p>"},{"location":"chapters/09-advanced-list-operations/#list-as-queue","title":"List as Queue","text":"<p>A queue is a data structure that follows the FIFO principle: First In, First Out. Think of a line at a movie theater. The first person in line is the first person to get a ticket. New people join at the back of the line.</p> <pre><code>  front \u2192 [person 1] [person 2] [person 3] \u2190 back\n            (served      (waiting)    (just\n             first)                   arrived)\n</code></pre> <p>You can use a Python list as a queue, but it's not ideal. Removing from the front with <code>list.pop(0)</code> is slow because Python has to shift every remaining element one position to the left. For a list with (n) items, that's an (O(n)) operation.</p> <p>Here's the basic idea, though:</p> <pre><code>queue = []\n\n# Enqueue (add to back)\nqueue.append(\"Alice\")\nqueue.append(\"Bob\")\nqueue.append(\"Charlie\")\nprint(queue)  # ['Alice', 'Bob', 'Charlie']\n\n# Dequeue (remove from front)\nfirst = queue.pop(0)\nprint(first)  # 'Alice'  \u2190 first one in, first one out\nprint(queue)  # ['Bob', 'Charlie']\n</code></pre> <p>For better performance, Python provides <code>collections.deque</code> (pronounced \"deck\"), which is optimized for adding and removing from both ends:</p> <pre><code>from collections import deque\n\nqueue = deque()\nqueue.append(\"Alice\")\nqueue.append(\"Bob\")\nqueue.append(\"Charlie\")\n\nfirst = queue.popleft()  # O(1) \u2014 fast!\nprint(first)  # 'Alice'\n</code></pre> <p>Queues show up in real life and computing all the time:</p> <ul> <li>Print jobs \u2014 documents are printed in the order they were sent</li> <li>Customer service \u2014 calls are answered in the order they were received</li> <li>Task scheduling \u2014 the operating system uses queues to manage which programs run next</li> </ul> <p>Here's a comparison of stacks and queues:</p> Feature Stack (LIFO) Queue (FIFO) Analogy Stack of plates Line at a movie theater Add item <code>append()</code> (to top) <code>append()</code> (to back) Remove item <code>pop()</code> (from top) <code>pop(0)</code> or <code>popleft()</code> (from front) Order Last in, first out First in, first out Common uses Undo, back button, call stack Print queue, task scheduling"},{"location":"chapters/09-advanced-list-operations/#diagram-queue-simulator","title":"Diagram: Queue Simulator","text":"Queue Simulator MicroSim <p>Type: microsim sim-id: queue-simulator Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: demonstrate, compare</p> <p>Learning Objective: Students will be able to demonstrate FIFO (First In, First Out) behavior by enqueuing and dequeuing items and contrast it with stack (LIFO) behavior.</p> <p>Purpose: An interactive queue visualization where students add and remove items, seeing the queue grow and shrink horizontally. Includes a side-by-side comparison mode with a stack.</p> <p>Layout:</p> <ul> <li>Center: A horizontal row of rectangular blocks, growing to the right. New items enter from the right; items are removed from the left.</li> <li>Each block displays the item value and arrival order</li> <li>Left side: \"Dequeue\" button (removes from front, animated slide-out to the left)</li> <li>Right side: Text input and \"Enqueue\" button (adds to back, animated slide-in from the right)</li> <li>Bottom: History log of all operations</li> </ul> <p>Interactive elements:</p> <ul> <li>Type a value and click \"Enqueue\" to add it to the back of the queue</li> <li>Click \"Dequeue\" to remove the front item</li> <li>\"Compare Mode\" toggle: Shows a stack above and a queue below, both receiving the same input; students observe the different removal order</li> <li>\"Predict Mode\": Before dequeuing, the student guesses which item will be removed</li> <li>\"Clear\" button resets</li> </ul> <p>Visual style: Horizontal row of colored blocks; front item has a subtle arrow indicator; items animate in from right and out from left Color scheme: Blocks colored by arrival order; front block highlighted Responsive: Blocks scale to fit window width</p> <p>Instructional Rationale: Horizontal layout naturally maps to the mental model of a \"line\" or \"queue.\" Compare mode makes the FIFO vs LIFO distinction vivid by showing both structures process the same input differently.</p> <p>Monty says: Let's code this!</p> <p> Here's a mnemonic to remember the difference: Stack = Stack of plates (you grab from the top). Queue = Q for \"Queue up\" (you wait your turn in line). LIFO for stacks, FIFO for queues!</p>"},{"location":"chapters/09-advanced-list-operations/#putting-it-all-together-a-complete-example","title":"Putting It All Together: A Complete Example","text":"<p>Let's combine several concepts from this chapter in a realistic example. Imagine you're building a simple grade tracker for a class:</p> <pre><code>import copy\n\n# Student grades for the semester\ngrades = [85, 92, 78, 95, 88, 72, 90, 85, 91, 85]\n\n# --- Basic statistics using built-in functions ---\nprint(f\"Number of grades: {len(grades)}\")\nprint(f\"Highest grade: {max(grades)}\")\nprint(f\"Lowest grade: {min(grades)}\")\nprint(f\"Total points: {sum(grades)}\")\nprint(f\"Class average: {sum(grades) / len(grades):.1f}\")\n\n# --- Searching ---\nif 100 in grades:\n    print(\"Someone got a perfect score!\")\nelse:\n    print(\"No perfect scores this time.\")\n\nprint(f\"Number of students who scored 85: {grades.count(85)}\")\nprint(f\"First 85 is at index: {grades.index(85)}\")\n\n# --- Sorting without modifying original ---\nranked = sorted(grades, reverse=True)\nprint(f\"Grades ranked highest to lowest: {ranked}\")\nprint(f\"Original order preserved: {grades}\")\n\n# --- Safe copying ---\ngrades_backup = grades.copy()\ngrades_backup.append(100)  # Add a late submission\nprint(f\"Original unchanged: {grades}\")\nprint(f\"Backup with new grade: {grades_backup}\")\n\n# --- Using a list as a stack (undo system) ---\nundo_stack = []\nundo_stack.append(\"Added grade 85\")\nundo_stack.append(\"Added grade 92\")\nundo_stack.append(\"Changed grade from 78 to 80\")\n\n# Undo the last action\nlast_action = undo_stack.pop()\nprint(f\"Undid: {last_action}\")\n</code></pre> <p>This single example uses 11 of the 15 concepts from this chapter: <code>len()</code>, <code>min()</code>, <code>max()</code>, <code>sum()</code>, <code>in</code> operator, <code>.count()</code>, <code>.index()</code>, <code>sorted()</code>, <code>.copy()</code>, list as stack, and the difference between modifying a copy vs. the original (aliasing awareness).</p>"},{"location":"chapters/09-advanced-list-operations/#diagram-list-operations-cheat-sheet","title":"Diagram: List Operations Cheat Sheet","text":"List Operations Cheat Sheet Interactive Reference <p>Type: infographic sim-id: list-operations-cheat-sheet Library: p5.js Status: Specified</p> <p>Bloom Level: Remember (L1) Bloom Verb: recall, identify</p> <p>Learning Objective: Students will be able to quickly recall the syntax and purpose of all advanced list operations covered in this chapter.</p> <p>Purpose: An interactive cheat sheet organized by category (copying, combining, searching, statistics, sorting, data structures) where students can click on any operation to see its syntax, a code example, and the output.</p> <p>Layout:</p> <ul> <li>Six category panels arranged in a 2x3 grid:</li> <li>Copying (alias, shallow, deep)</li> <li>Combining (concatenation, repetition)</li> <li>Searching (in, index, count)</li> <li>Statistics (len, min, max, sum)</li> <li>Sorting (sort vs sorted)</li> <li>Data Structures (stack, queue)</li> <li>Each panel shows 2-4 operations as clickable tiles</li> </ul> <p>Interactive elements:</p> <ul> <li>Click any operation tile to expand it, showing:</li> <li>Syntax with color-coded highlighting</li> <li>A short code example</li> <li>The output</li> <li>A one-line \"gotcha\" or tip</li> <li>Only one tile expanded at a time (accordion behavior)</li> <li>A \"Quiz Me\" button: hides the descriptions and shows just the operation name; students must recall what it does before clicking to reveal</li> </ul> <p>Visual style: Card-based layout with category colors matching the chapter sections Color scheme: Each category has its own color; tiles have subtle shadows Responsive: Grid collapses to 1 column on narrow screens</p> <p>Instructional Rationale: A reference organized by category helps students build a mental model of when to use each operation. The \"Quiz Me\" mode supports active recall, which is more effective than passive review.</p> <p>Monty says: You've got this!</p> <p> Incredible work, coders! You've leveled up your list skills to advanced status. You now know how to copy lists safely, search and summarize data, sort without destroying, and use lists as stacks and queues. These skills will come in handy in every Python project you build from here on out. Take a victory lap \u2014 you've earned it!</p>"},{"location":"chapters/09-advanced-list-operations/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>List aliasing happens when two variables point to the same list. Changes to one affect the other.</li> <li>Use <code>==</code> to compare list values (equality) and <code>is</code> to check if two variables point to the same object (identity).</li> <li>A shallow copy (<code>.copy()</code>, <code>[:]</code>, <code>list()</code>) creates a new list but shares inner objects. A deep copy (<code>copy.deepcopy()</code>) copies everything recursively.</li> <li>Concatenation (<code>+</code>) joins two lists into a new one. Repetition (<code>*</code>) repeats a list multiple times.</li> <li>The in operator checks membership. The index method finds position. The count method tallies occurrences.</li> <li><code>len()</code>, <code>min()</code>, <code>max()</code>, and <code>sum()</code> are built-in functions for measuring and summarizing list data.</li> <li><code>sorted()</code> returns a new sorted list without modifying the original, unlike <code>.sort()</code> which sorts in place.</li> <li>A stack (LIFO) uses <code>append()</code> and <code>pop()</code>. A queue (FIFO) uses <code>append()</code> and <code>pop(0)</code> (or <code>deque.popleft()</code> for better performance).</li> </ul> Check Your Understanding: What's the difference between a shallow copy and a deep copy? <p>A shallow copy creates a new list object but does not copy nested objects inside it \u2014 the inner lists are still shared between the original and the copy. A deep copy (using <code>copy.deepcopy()</code>) recursively copies everything, so the original and the copy are completely independent. Use shallow copies for flat lists (numbers, strings) and deep copies for nested lists (lists of lists).</p> Check Your Understanding: If you have <code>a = [1, 2, 3]</code> and <code>b = [1, 2, 3]</code>, what do <code>a == b</code> and <code>a is b</code> return? <p><code>a == b</code> returns True because both lists contain the same values. <code>a is b</code> returns False because they are two separate list objects in memory \u2014 they just happen to have the same contents. Remember: <code>==</code> checks equality (same values), while <code>is</code> checks identity (same object).</p> Check Your Understanding: You push 'A', 'B', and 'C' onto a stack. What order are they popped? <p>They are popped in reverse order: 'C', 'B', 'A'. A stack follows LIFO (Last In, First Out), so the last item pushed ('C') is the first one popped. If this were a queue (FIFO), the order would be 'A', 'B', 'C' \u2014 first in, first out.</p>"},{"location":"chapters/10-tuples-and-sets/","title":"Tuples and Sets","text":""},{"location":"chapters/10-tuples-and-sets/#tuples-and-sets","title":"Tuples and Sets","text":""},{"location":"chapters/10-tuples-and-sets/#summary","title":"Summary","text":"<p>This chapter covers two important Python collection types: tuples and sets. Students will learn about tuple creation, immutability, packing and unpacking, and when to use tuples vs lists. The chapter then introduces sets and their mathematical operations (union, intersection, difference, symmetric difference), membership testing, and frozensets. These data structures complement lists and dictionaries for different use cases.</p>"},{"location":"chapters/10-tuples-and-sets/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 19 concepts from the learning graph:</p> <ol> <li>Tuples</li> <li>Tuple Creation</li> <li>Tuple Immutability</li> <li>Tuple Packing</li> <li>Tuple Unpacking</li> <li>Tuple Methods</li> <li>Tuples as Keys</li> <li>Tuples vs Lists</li> <li>Sets</li> <li>Set Creation</li> <li>Set Operations</li> <li>Set Union</li> <li>Set Intersection</li> <li>Set Difference</li> <li>Set Symmetric Difference</li> <li>Set Methods</li> <li>Membership Testing</li> <li>Frozenset</li> <li>Removing Duplicates</li> </ol>"},{"location":"chapters/10-tuples-and-sets/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 2: Python Fundamentals</li> <li>Chapter 3: Boolean Logic and Comparisons</li> <li>Chapter 5: Working with Strings</li> <li>Chapter 8: Lists</li> </ul> <p>Monty says: Let's code this!</p> <p> Welcome back, coders! You already know how to work with lists -- those flexible, ordered containers that hold just about anything. Now it's time to meet two more collection types: tuples and sets. Think of tuples as lists that can't be changed (like a GPS coordinate that's locked in place) and sets as bags of unique marbles where no two are the same. By the end of this chapter, you'll know exactly when to reach for each one. Let's do this!</p>"},{"location":"chapters/10-tuples-and-sets/#part-1-tuples","title":"Part 1: Tuples","text":""},{"location":"chapters/10-tuples-and-sets/#what-is-a-tuple","title":"What Is a Tuple?","text":"<p>A tuple is an ordered, immutable sequence of values. If you've already worked with lists, tuples will feel familiar -- they look similar, act similar, and can hold the same kinds of data. The big difference? Once you create a tuple, you cannot change it. No adding, no removing, no swapping elements. What you see is what you get.</p> <p>Why would you want a collection that can't be changed? Great question! Sometimes you want data to be locked down. Think about GPS coordinates: the latitude and longitude of the Eiffel Tower are (48.8584, 2.2945). Those numbers shouldn't accidentally change in your program. A tuple is the perfect fit.</p> <p>Here are some real-world examples of tuple-like data:</p> <ul> <li>(x, y) coordinates on a graph</li> <li>(red, green, blue) color values</li> <li>(month, day, year) date components</li> <li>(latitude, longitude) map positions</li> <li>(name, student_id) a student record</li> </ul>"},{"location":"chapters/10-tuples-and-sets/#tuple-creation","title":"Tuple Creation","text":"<p>Tuple creation is straightforward. You use parentheses <code>()</code> instead of the square brackets <code>[]</code> that lists use.</p> <pre><code># Creating tuples with parentheses\ncoordinates = (48.8584, 2.2945)\nrgb_color = (255, 128, 0)\nstudent = (\"Alice\", 10, 3.8)\n\nprint(coordinates)  # (48.8584, 2.2945)\nprint(rgb_color)    # (255, 128, 0)\nprint(student)      # ('Alice', 10, 3.8)\n</code></pre> <p>You can also create a tuple without parentheses -- Python figures it out from the commas:</p> <pre><code># Parentheses are optional!\nfruits = \"apple\", \"banana\", \"cherry\"\nprint(fruits)       # ('apple', 'banana', 'cherry')\nprint(type(fruits)) # &lt;class 'tuple'&gt;\n</code></pre> <p>Watch out for the single-element tuple -- this one trips up a lot of beginners:</p> <pre><code># This is NOT a tuple -- it's just a string in parentheses\nnot_a_tuple = (\"hello\")\nprint(type(not_a_tuple))  # &lt;class 'str'&gt;\n\n# THIS is a single-element tuple -- notice the trailing comma!\nactually_a_tuple = (\"hello\",)\nprint(type(actually_a_tuple))  # &lt;class 'tuple'&gt;\n</code></pre> <p>That trailing comma after <code>\"hello\"</code> is what tells Python \"this is a tuple with one item, not just a value in parentheses.\" It looks a little weird, but you get used to it.</p> <p>You can also create tuples from other sequences using the <code>tuple()</code> function:</p> <pre><code># Convert a list to a tuple\nmy_list = [1, 2, 3]\nmy_tuple = tuple(my_list)\nprint(my_tuple)  # (1, 2, 3)\n\n# Convert a string to a tuple of characters\nletters = tuple(\"Python\")\nprint(letters)  # ('P', 'y', 't', 'h', 'o', 'n')\n\n# Create an empty tuple\nempty = tuple()\nprint(empty)  # ()\n</code></pre> <p>Monty says: Let's debug this together!</p> <p> The number one tuple mistake? Forgetting the comma in a single-element tuple. <code>(42)</code> is just the number 42, but <code>(42,)</code> is a tuple containing 42. That tiny comma makes a huge difference!</p>"},{"location":"chapters/10-tuples-and-sets/#tuple-immutability","title":"Tuple Immutability","text":"<p>Tuple immutability means that once a tuple is created, you cannot modify its contents. You can't add items, remove items, or change existing items. If you try, Python will raise a <code>TypeError</code>.</p> <pre><code>colors = (\"red\", \"green\", \"blue\")\n\n# Trying to change an element? Nope!\ncolors[0] = \"yellow\"  # TypeError: 'tuple' object does not support item assignment\n\n# Trying to append? Also nope!\ncolors.append(\"purple\")  # AttributeError: 'tuple' object has no attribute 'append'\n</code></pre> <p>But wait -- you can still do these things with tuples:</p> <ul> <li>Access elements by index: <code>colors[0]</code> returns <code>\"red\"</code></li> <li>Slice tuples: <code>colors[1:]</code> returns <code>(\"green\", \"blue\")</code></li> <li>Concatenate tuples to make a new tuple: <code>colors + (\"yellow\",)</code> returns <code>(\"red\", \"green\", \"blue\", \"yellow\")</code></li> <li>Repeat tuples: <code>(1, 2) * 3</code> returns <code>(1, 2, 1, 2, 1, 2)</code></li> <li>Check membership: <code>\"red\" in colors</code> returns <code>True</code></li> <li>Loop through elements: <code>for color in colors:</code></li> </ul> <pre><code>colors = (\"red\", \"green\", \"blue\")\n\n# Accessing by index\nprint(colors[0])    # red\nprint(colors[-1])   # blue\n\n# Slicing\nprint(colors[1:])   # ('green', 'blue')\n\n# Concatenation (creates a NEW tuple)\nmore_colors = colors + (\"yellow\", \"purple\")\nprint(more_colors)  # ('red', 'green', 'blue', 'yellow', 'purple')\n\n# The original tuple is unchanged!\nprint(colors)       # ('red', 'green', 'blue')\n</code></pre> <p>The key idea is: you're never modifying the original tuple. You're always creating a new one.</p>"},{"location":"chapters/10-tuples-and-sets/#diagram-tuple-vs-list-mutability","title":"Diagram: Tuple vs List Mutability","text":"Tuple vs List Mutability Visualizer <p>Type: microsim sim-id: tuple-vs-list-mutability Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: compare, explain</p> <p>Learning Objective: Students will be able to explain the difference between mutable lists and immutable tuples by observing how modification operations succeed on lists but fail on tuples.</p> <p>Purpose: A side-by-side interactive visualization showing a list and a tuple containing the same data, where students can attempt operations (append, remove, change item) and see them succeed on the list but produce error messages on the tuple.</p> <p>Layout: - Left panel: \"List\" with bracket notation <code>[1, 2, 3]</code> displayed as boxes - Right panel: \"Tuple\" with parenthesis notation <code>(1, 2, 3)</code> displayed as boxes with a lock icon - Bottom: Three operation buttons: \"Change Item\", \"Add Item\", \"Remove Item\"</p> <p>Interactive elements: - Click \"Change Item\" to attempt to change index 0 on both sides. List side updates successfully (green flash). Tuple side shows a red flash and a <code>TypeError</code> message. - Click \"Add Item\" to attempt appending a value. List grows; tuple shows <code>AttributeError</code>. - Click \"Remove Item\" to attempt removing the last item. List shrinks; tuple shows an error. - A \"Reset\" button restores both to their original state.</p> <p>Visual elements: - List boxes are drawn with a green border (modifiable) - Tuple boxes are drawn with a gold border and a small lock icon (immutable) - Success operations produce a green glow animation - Failed operations produce a red shake animation and display the error type</p> <p>Instructional Rationale: Direct comparison with immediate feedback helps students internalize the mutability difference. Attempting the same operation on both structures makes the contrast vivid and memorable.</p>"},{"location":"chapters/10-tuples-and-sets/#tuple-packing-and-unpacking","title":"Tuple Packing and Unpacking","text":"<p>Tuple packing is what happens when you assign multiple values to a single variable. Python automatically \"packs\" them into a tuple:</p> <pre><code># Tuple packing -- Python bundles these into a tuple\nperson = \"Alice\", 16, \"10th grade\"\nprint(person)       # ('Alice', 16, '10th grade')\nprint(type(person)) # &lt;class 'tuple'&gt;\n</code></pre> <p>Tuple unpacking is the reverse -- you pull individual values out of a tuple and assign them to separate variables:</p> <pre><code># Tuple unpacking -- pull values out into individual variables\nperson = (\"Alice\", 16, \"10th grade\")\nname, age, grade = person\n\nprint(name)   # Alice\nprint(age)    # 16\nprint(grade)  # 10th grade\n</code></pre> <p>This is incredibly useful! You'll see tuple unpacking all over Python code. Here are some common patterns:</p> <pre><code># Swapping two variables (no temp variable needed!)\na = 10\nb = 20\na, b = b, a\nprint(a)  # 20\nprint(b)  # 10\n\n# Unpacking in a for loop with enumerate\nfruits = [\"apple\", \"banana\", \"cherry\"]\nfor index, fruit in enumerate(fruits):\n    print(f\"{index}: {fruit}\")\n# 0: apple\n# 1: banana\n# 2: cherry\n\n# Returning multiple values from a function\ndef get_min_max(numbers):\n    return min(numbers), max(numbers)\n\nlow, high = get_min_max([4, 7, 2, 9, 1])\nprint(f\"Min: {low}, Max: {high}\")  # Min: 1, Max: 9\n</code></pre> <p>The variable swap trick (<code>a, b = b, a</code>) is one of Python's most elegant features. In many other languages, you'd need a temporary variable to pull this off. Python makes it a one-liner thanks to tuple packing and unpacking.</p> <p>Monty says: You've got this!</p> <p> Here's something neat: when a function returns multiple values separated by commas, it's actually returning a tuple! So <code>return min(numbers), max(numbers)</code> is really <code>return (min(numbers), max(numbers))</code>. Tuple packing happens automatically.</p>"},{"location":"chapters/10-tuples-and-sets/#tuple-methods","title":"Tuple Methods","text":"<p>Since tuples are immutable, they don't have methods that modify the tuple (like <code>append()</code> or <code>remove()</code>). But they do have two useful tuple methods:</p> Method What It Does Example <code>count(value)</code> Returns how many times <code>value</code> appears <code>(1, 2, 2, 3).count(2)</code> returns <code>2</code> <code>index(value)</code> Returns the index of the first occurrence of <code>value</code> <code>(1, 2, 3).index(3)</code> returns <code>2</code> <pre><code>grades = (95, 87, 95, 92, 88, 95)\n\n# How many times does 95 appear?\nprint(grades.count(95))  # 3\n\n# Where is the first 87?\nprint(grades.index(87))  # 1\n\n# What about a value that's not there?\n# grades.index(100)  # ValueError: tuple.index(x): x not in tuple\n</code></pre> <p>Just two methods -- that's it! Compare that to lists, which have eleven methods. Fewer methods means there's less to memorize, and it reflects the simplicity of tuples: they hold data, they don't change, and they keep things simple.</p>"},{"location":"chapters/10-tuples-and-sets/#tuples-as-dictionary-keys","title":"Tuples as Dictionary Keys","text":"<p>Here's a superpower that lists don't have: you can use tuples as keys in a dictionary. Why? Because dictionary keys must be immutable (unchangeable), and tuples fit that requirement perfectly. Lists are mutable, so they can't be used as keys.</p> <pre><code># Using tuples as dictionary keys -- great for coordinate grids!\nchess_board = {}\nchess_board[(0, 0)] = \"Rook\"\nchess_board[(0, 1)] = \"Knight\"\nchess_board[(0, 2)] = \"Bishop\"\nchess_board[(0, 3)] = \"Queen\"\nchess_board[(0, 4)] = \"King\"\n\nprint(chess_board[(0, 3)])  # Queen\n\n# Storing city distances with (city1, city2) as keys\ndistances = {\n    (\"New York\", \"Boston\"): 215,\n    (\"New York\", \"Chicago\"): 790,\n    (\"Boston\", \"Chicago\"): 983,\n}\n\nprint(distances[(\"New York\", \"Boston\")])  # 215\n</code></pre> <p>This is a common pattern in games, maps, and scientific computing. Any time you need to look something up by a pair (or group) of values, tuple keys are your friend.</p> <pre><code># This would FAIL with a list:\n# bad_dict = {[0, 0]: \"Rook\"}  # TypeError: unhashable type: 'list'\n</code></pre>"},{"location":"chapters/10-tuples-and-sets/#tuples-vs-lists","title":"Tuples vs Lists","text":"<p>So when should you use a tuple, and when should you use a list? Here's a clear comparison of tuples vs lists:</p> Feature Tuple List Syntax <code>(1, 2, 3)</code> <code>[1, 2, 3]</code> Mutable? No (immutable) Yes (mutable) Can be a dict key? Yes No Methods available 2 (<code>count</code>, <code>index</code>) 11+ (<code>append</code>, <code>remove</code>, etc.) Speed Slightly faster Slightly slower Memory Uses less memory Uses more memory Use case Fixed data, coordinates, records Data that changes, collections you grow <p>Rules of thumb:</p> <ul> <li>If the data should never change, use a tuple (coordinates, RGB values, database records)</li> <li>If you need to add, remove, or modify items, use a list (shopping lists, game inventories, user inputs)</li> <li>If you need to use the collection as a dictionary key, use a tuple</li> <li>When in doubt, ask yourself: \"Will I need to change this later?\" If yes, use a list. If no, use a tuple.</li> </ul>"},{"location":"chapters/10-tuples-and-sets/#diagram-tuples-vs-lists-comparison","title":"Diagram: Tuples vs Lists Comparison","text":"Tuples vs Lists Interactive Comparison <p>Type: infographic sim-id: tuples-vs-lists Library: p5.js Status: Specified</p> <p>Bloom Level: Analyze (L4) Bloom Verb: compare, differentiate</p> <p>Learning Objective: Students will be able to choose between tuples and lists for a given scenario by comparing their properties and trade-offs.</p> <p>Purpose: An interactive decision-helper that presents real-world scenarios and asks students to choose tuple or list, providing immediate feedback and explanations.</p> <p>Layout: - Top section: Side-by-side visual comparison of a tuple (locked box with parentheses) and a list (open box with brackets) showing key properties - Middle section: A scenario card with a description like \"You need to store the (x, y) coordinates of a point on a map\" - Bottom section: Two large buttons \"Use a Tuple\" and \"Use a List\" for the student's choice</p> <p>Interactive elements: - Click \"Use a Tuple\" or \"Use a List\" to answer - Correct answer: green highlight with a brief explanation of why - Wrong answer: red highlight with a gentle explanation of why the other choice is better - \"Next Scenario\" button loads a new scenario - A score counter tracks correct answers out of total attempts - Scenarios cycle through 8-10 different real-world use cases</p> <p>Scenario examples: 1. \"Store GPS coordinates (lat, lon)\" -- Tuple (fixed data) 2. \"Track items in a shopping cart\" -- List (items get added/removed) 3. \"Store an RGB color value (255, 128, 0)\" -- Tuple (fixed data) 4. \"Manage a playlist of songs\" -- List (songs get added/removed) 5. \"Use as a dictionary key\" -- Tuple (lists can't be keys) 6. \"Store daily temperatures to analyze later\" -- List (growing collection) 7. \"Represent a database row (name, age, email)\" -- Tuple (fixed record) 8. \"Build a stack of undo operations\" -- List (needs push/pop)</p> <p>Instructional Rationale: Scenario-based practice at the Analyze level forces students to evaluate properties and make justified decisions, moving beyond simple recall of tuple vs list differences.</p>"},{"location":"chapters/10-tuples-and-sets/#part-2-sets","title":"Part 2: Sets","text":""},{"location":"chapters/10-tuples-and-sets/#what-is-a-set","title":"What Is a Set?","text":"<p>A set is an unordered collection of unique elements. If tuples are like GPS coordinates (fixed and reliable), sets are like a bag of unique marbles -- you can toss marbles in, pull them out, and check what's inside, but there are never any duplicates. If you try to add a marble that's already in the bag, nothing happens.</p> <p>If you've studied sets in math class, Python sets work the same way. They support union, intersection, difference, and more. It's like your math textbook came to life!</p> <p>Key properties of sets:</p> <ul> <li>Unordered: Items have no position or index. You can't access <code>my_set[0]</code>.</li> <li>Unique elements: Every item appears at most once. Duplicates are automatically removed.</li> <li>Mutable: You can add and remove items (unlike tuples).</li> <li>No duplicate values: Adding a value that already exists has no effect.</li> </ul>"},{"location":"chapters/10-tuples-and-sets/#set-creation","title":"Set Creation","text":"<p>Set creation uses curly braces <code>{}</code> or the <code>set()</code> function:</p> <pre><code># Creating a set with curly braces\nfruits = {\"apple\", \"banana\", \"cherry\"}\nprint(fruits)  # {'cherry', 'banana', 'apple'}  (order may vary!)\n\n# Duplicates are automatically removed\nnumbers = {1, 2, 2, 3, 3, 3, 4}\nprint(numbers)  # {1, 2, 3, 4}\n\n# Creating a set from a list\ncolors = set([\"red\", \"green\", \"blue\", \"red\"])\nprint(colors)  # {'red', 'green', 'blue'}\n\n# Creating an empty set (careful -- {} creates an empty DICT, not a set!)\nempty_set = set()\nprint(type(empty_set))  # &lt;class 'set'&gt;\n\n# This creates a dictionary, NOT a set!\nnot_a_set = {}\nprint(type(not_a_set))  # &lt;class 'dict'&gt;\n</code></pre> <p>Notice that when you print a set, the elements might appear in a different order than you entered them. That's because sets are unordered -- Python stores them however it finds most efficient internally. Don't rely on set ordering!</p> <p>Monty says: Let's debug this together!</p> <p> Heads up: <code>{}</code> creates an empty dictionary, not an empty set! To make an empty set, you must use <code>set()</code>. This trips up even experienced programmers. Remember: curly braces with key-value pairs = dictionary. Curly braces with just values = set. Empty curly braces = dictionary (because dicts came first in Python's history).</p>"},{"location":"chapters/10-tuples-and-sets/#membership-testing","title":"Membership Testing","text":"<p>One of the most powerful features of sets is fast membership testing -- checking whether an element is in the set. Sets use a clever internal structure (called a hash table) that makes <code>in</code> checks almost instant, no matter how big the set is.</p> <pre><code>valid_colors = {\"red\", \"green\", \"blue\", \"yellow\", \"purple\"}\n\n# Checking membership\nprint(\"red\" in valid_colors)     # True\nprint(\"orange\" in valid_colors)  # False\nprint(\"pink\" not in valid_colors) # True\n</code></pre> <p>Lists can do membership testing too, but they're slower. A list has to check every single element one by one (that's (O(n)) time). A set jumps straight to the answer (that's (O(1)) time on average). For small collections it doesn't matter, but for thousands or millions of items, sets are dramatically faster.</p> <pre><code># Practical example: checking if a username is taken\ntaken_usernames = {\"gamer42\", \"pythonista\", \"codequeen\", \"hackmaster\"}\n\nnew_user = \"pythonista\"\nif new_user in taken_usernames:\n    print(f\"Sorry, '{new_user}' is already taken!\")\nelse:\n    print(f\"'{new_user}' is available!\")\n# Output: Sorry, 'pythonista' is already taken!\n</code></pre>"},{"location":"chapters/10-tuples-and-sets/#set-operations","title":"Set Operations","text":"<p>Set operations are where sets really shine. Python supports all the classic mathematical set operations. If you've seen Venn diagrams in math class, you already understand the concepts -- Python just gives you the code to compute them.</p> <p>The four main set operations are:</p> Operation Symbol Method What It Returns Union <code>\\|</code> <code>.union()</code> Everything in either set (or both) Intersection <code>&amp;</code> <code>.intersection()</code> Only items in both sets Difference <code>-</code> <code>.difference()</code> Items in the first set but not the second Symmetric Difference <code>^</code> <code>.symmetric_difference()</code> Items in one set or the other, but not both <p>Let's walk through each one with a concrete example. Imagine two friend groups:</p> <pre><code>alice_friends = {\"Bob\", \"Charlie\", \"Diana\", \"Eve\"}\nbob_friends = {\"Alice\", \"Charlie\", \"Eve\", \"Frank\"}\n</code></pre>"},{"location":"chapters/10-tuples-and-sets/#set-union","title":"Set Union","text":"<p>Set union combines everything from both sets. If a name appears in either set (or both), it's in the union. Think of it as \"everyone invited to the combined party.\"</p> <pre><code># Union: everyone in either group\nall_friends = alice_friends | bob_friends\nprint(all_friends)\n# {'Bob', 'Charlie', 'Diana', 'Eve', 'Alice', 'Frank'}\n\n# Same thing using the method:\nall_friends = alice_friends.union(bob_friends)\n</code></pre>"},{"location":"chapters/10-tuples-and-sets/#set-intersection","title":"Set Intersection","text":"<p>Set intersection returns only the items that appear in both sets. These are the mutual friends -- people in Alice's group and Bob's group.</p> <pre><code># Intersection: friends they have in common\nmutual_friends = alice_friends &amp; bob_friends\nprint(mutual_friends)\n# {'Charlie', 'Eve'}\n\n# Same thing using the method:\nmutual_friends = alice_friends.intersection(bob_friends)\n</code></pre>"},{"location":"chapters/10-tuples-and-sets/#set-difference","title":"Set Difference","text":"<p>Set difference returns items in the first set that are not in the second. It answers \"who is in Alice's group but NOT in Bob's group?\"</p> <pre><code># Difference: Alice's friends who are NOT Bob's friends\nalice_only = alice_friends - bob_friends\nprint(alice_only)\n# {'Bob', 'Diana'}\n\n# The other direction gives different results:\nbob_only = bob_friends - alice_friends\nprint(bob_only)\n# {'Alice', 'Frank'}\n</code></pre> <p>Notice that difference is not symmetric -- <code>A - B</code> is different from <code>B - A</code>.</p>"},{"location":"chapters/10-tuples-and-sets/#set-symmetric-difference","title":"Set Symmetric Difference","text":"<p>Set symmetric difference returns items that are in one set or the other, but not in both. It's like the union minus the intersection. Think of it as \"friends who are exclusive to one group.\"</p> <pre><code># Symmetric difference: friends in one group but not both\nexclusive_friends = alice_friends ^ bob_friends\nprint(exclusive_friends)\n# {'Bob', 'Diana', 'Alice', 'Frank'}\n\n# Same thing using the method:\nexclusive_friends = alice_friends.symmetric_difference(bob_friends)\n</code></pre>"},{"location":"chapters/10-tuples-and-sets/#diagram-venn-diagram-set-operations","title":"Diagram: Venn Diagram Set Operations","text":"Venn Diagram Set Operations MicroSim <p>Type: microsim sim-id: venn-diagram-sets Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: demonstrate, compute</p> <p>Learning Objective: Students will be able to compute union, intersection, difference, and symmetric difference of two sets by interacting with a Venn diagram and seeing the results highlighted visually and computed in code.</p> <p>Purpose: An interactive Venn diagram that lets students add elements to two sets, then select an operation and see the result highlighted on the diagram and displayed as Python code.</p> <p>Layout: - Top section: Title \"Set Operations with Venn Diagrams\" - Middle section: Two overlapping circles (classic Venn diagram) labeled \"Set A\" and \"Set B\" - Elements displayed as labels within the appropriate circle regions - Below the diagram: Four operation buttons: \"Union\", \"Intersection\", \"Difference (A-B)\", \"Symmetric Difference\" - Bottom section: Python code output showing the operation and result</p> <p>Default data: - Set A: {\"apple\", \"banana\", \"cherry\", \"date\"} - Set B: {\"cherry\", \"date\", \"elderberry\", \"fig\"}</p> <p>Interactive elements: - Click an operation button to highlight the corresponding region of the Venn diagram   - Union: both entire circles highlighted   - Intersection: only the overlapping region highlighted   - Difference (A-B): only the left-only region highlighted   - Symmetric Difference: both non-overlapping regions highlighted (overlap is excluded) - Input fields to add/remove items from Set A and Set B - Python code output updates to show the operation symbol and result - A \"Swap A and B\" button to see how it affects difference</p> <p>Visual elements: - Circle A: blue with semi-transparent fill - Circle B: orange with semi-transparent fill - Overlap region: green when intersection is selected - Highlighted regions pulse gently - Elements in the highlighted region appear in bold - Elements outside the highlighted region appear dimmed</p> <p>Code output examples: - Union: <code>A | B = {'apple', 'banana', 'cherry', 'date', 'elderberry', 'fig'}</code> - Intersection: <code>A &amp; B = {'cherry', 'date'}</code> - Difference: <code>A - B = {'apple', 'banana'}</code> - Symmetric Difference: <code>A ^ B = {'apple', 'banana', 'elderberry', 'fig'}</code></p> <p>Instructional Rationale: Venn diagrams are the classic visual for set operations. Interactive highlighting connects the visual regions to the mathematical operations and Python syntax. Showing the equivalent Python code bridges the gap between the visual representation and programming.</p>"},{"location":"chapters/10-tuples-and-sets/#set-methods","title":"Set Methods","text":"<p>Beyond the operators, Python provides many useful set methods for adding, removing, and manipulating set contents:</p> Method What It Does Example <code>add(x)</code> Add element <code>x</code> to the set <code>s.add(\"kiwi\")</code> <code>remove(x)</code> Remove <code>x</code>; raises <code>KeyError</code> if missing <code>s.remove(\"apple\")</code> <code>discard(x)</code> Remove <code>x</code>; does nothing if missing <code>s.discard(\"mango\")</code> <code>pop()</code> Remove and return an arbitrary element <code>s.pop()</code> <code>clear()</code> Remove all elements <code>s.clear()</code> <code>copy()</code> Return a shallow copy of the set <code>s2 = s.copy()</code> <code>update(other)</code> Add all elements from <code>other</code> <code>s.update({4, 5, 6})</code> <code>issubset(other)</code> Is every element of <code>s</code> in <code>other</code>? <code>{1, 2}.issubset({1, 2, 3})</code> -- <code>True</code> <code>issuperset(other)</code> Does <code>s</code> contain every element of <code>other</code>? <code>{1, 2, 3}.issuperset({1, 2})</code> -- <code>True</code> <code>isdisjoint(other)</code> Do <code>s</code> and <code>other</code> share no elements? <code>{1, 2}.isdisjoint({3, 4})</code> -- <code>True</code> <pre><code># Using set methods\nbasket = {\"apple\", \"banana\", \"cherry\"}\n\n# Add an item\nbasket.add(\"date\")\nprint(basket)  # {'apple', 'banana', 'cherry', 'date'}\n\n# Try to add a duplicate -- nothing happens\nbasket.add(\"apple\")\nprint(basket)  # {'apple', 'banana', 'cherry', 'date'}\n\n# Remove an item safely with discard (no error if missing)\nbasket.discard(\"mango\")  # No error, even though mango isn't there\nprint(basket)  # {'apple', 'banana', 'cherry', 'date'}\n\n# Check subset/superset relationships\nsmall = {1, 2}\nbig = {1, 2, 3, 4, 5}\nprint(small.issubset(big))    # True  (every element of small is in big)\nprint(big.issuperset(small))  # True  (big contains all of small)\nprint(small.isdisjoint({6, 7}))  # True  (no elements in common)\n</code></pre> <p>Monty says: Let's debug this together!</p> <p> Use <code>discard()</code> instead of <code>remove()</code> when you're not sure if an element exists. <code>remove()</code> will crash your program with a <code>KeyError</code> if the item is missing, but <code>discard()</code> just quietly does nothing. It's the polite version!</p>"},{"location":"chapters/10-tuples-and-sets/#removing-duplicates","title":"Removing Duplicates","text":"<p>One of the most common practical uses of sets is removing duplicates from a list. Since sets automatically discard duplicates, you can convert a list to a set and back to get a list with unique elements only:</p> <pre><code># A list with duplicates\nscores = [95, 87, 95, 92, 88, 87, 95, 100, 88]\n\n# Remove duplicates by converting to a set, then back to a list\nunique_scores = list(set(scores))\nprint(unique_scores)  # [100, 87, 88, 92, 95]  (order may vary)\n</code></pre> <p>Notice that the order might change because sets are unordered. If you need to preserve the original order while removing duplicates, you can use a different approach:</p> <pre><code># Remove duplicates while preserving order\nscores = [95, 87, 95, 92, 88, 87, 95, 100, 88]\nseen = set()\nunique_ordered = []\nfor score in scores:\n    if score not in seen:\n        seen.add(score)\n        unique_ordered.append(score)\n\nprint(unique_ordered)  # [95, 87, 92, 88, 100]\n</code></pre> <p>This pattern uses a set (<code>seen</code>) for fast membership testing and a list (<code>unique_ordered</code>) to maintain insertion order. It's a perfect example of using the right tool for each job.</p> <pre><code># Real-world example: finding unique words in a sentence\nsentence = \"the cat sat on the mat and the cat slept\"\nwords = sentence.split()\nunique_words = set(words)\nprint(unique_words)\n# {'and', 'cat', 'mat', 'on', 'sat', 'slept', 'the'}\nprint(f\"Total words: {len(words)}, Unique words: {len(unique_words)}\")\n# Total words: 10, Unique words: 7\n</code></pre>"},{"location":"chapters/10-tuples-and-sets/#diagram-removing-duplicates-visualizer","title":"Diagram: Removing Duplicates Visualizer","text":"Removing Duplicates Step-by-Step Visualizer <p>Type: microsim sim-id: removing-duplicates Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: demonstrate, apply</p> <p>Learning Objective: Students will be able to use a set to remove duplicate values from a list by stepping through the conversion process and observing how duplicates are discarded.</p> <p>Purpose: An animated step-by-step visualization that shows how converting a list to a set removes duplicates, and how converting back to a list produces unique values.</p> <p>Layout: - Top: Input list displayed as a row of colored boxes with values (some duplicated) - Middle: A set container (shown as a circle or cloud shape) where values are added one by one - Bottom: Output list (unique values) - Left side: Step counter and current operation description</p> <p>Default data: <code>[3, 7, 3, 1, 7, 9, 1, 3, 5]</code></p> <p>Interactive elements: - \"Step\" button: Advance one element at a time. Each step shows:   - The current element highlighted in the input list   - An arrow animation showing the element moving toward the set   - If the element is new, it enters the set (green flash)   - If the element is a duplicate, it bounces off the set (red flash, \"Already in set!\" message) - \"Auto Play\" button: Animate all steps with a pause between each - \"Reset\" button: Return to the initial state - \"Custom Input\" text field: Enter your own comma-separated list of numbers - After all elements are processed, a \"Convert to List\" button copies set elements to the output list</p> <p>Visual elements: - Input boxes: color-coded so duplicates share the same color - Set container: circular/oval shape that grows as new elements are added - Duplicate attempts: element bounces off the set with a \"poof\" animation - New elements: smooth slide into the set with a green glow</p> <p>Instructional Rationale: Step-by-step processing reveals the mechanism behind duplicate removal. The bounce-off animation for duplicates makes the uniqueness constraint tangible and memorable. Custom input lets students experiment with their own data.</p>"},{"location":"chapters/10-tuples-and-sets/#frozenset","title":"Frozenset","text":"<p>We just learned that tuples are like immutable lists. Is there an immutable version of sets? Yes! It's called a frozenset.</p> <p>A frozenset has all the same elements and supports all the same operations (union, intersection, etc.) but you cannot add or remove elements after creation. Just like tuples can be dictionary keys, frozensets can too.</p> <pre><code># Creating a frozenset\nfrozen = frozenset([1, 2, 3, 4])\nprint(frozen)       # frozenset({1, 2, 3, 4})\nprint(type(frozen))  # &lt;class 'frozenset'&gt;\n\n# Frozensets support set operations\nother = frozenset([3, 4, 5, 6])\nprint(frozen | other)  # frozenset({1, 2, 3, 4, 5, 6})\nprint(frozen &amp; other)  # frozenset({3, 4})\n\n# But you CAN'T modify them\n# frozen.add(5)  # AttributeError: 'frozenset' object has no attribute 'add'\n</code></pre> <p>When would you use a frozenset? Here are some common scenarios:</p> <ul> <li>When you need a set that's a dictionary key (regular sets can't be keys because they're mutable)</li> <li>When you want to make sure a set doesn't get accidentally modified</li> <li>When you need a set inside another set (sets can't contain other sets, but they can contain frozensets)</li> </ul> <pre><code># Frozenset as a dictionary key\npermissions = {\n    frozenset({\"read\", \"write\"}): \"Editor\",\n    frozenset({\"read\"}): \"Viewer\",\n    frozenset({\"read\", \"write\", \"admin\"}): \"Administrator\",\n}\n\nuser_perms = frozenset({\"read\", \"write\"})\nprint(permissions[user_perms])  # Editor\n\n# A set of frozensets (set of sets!)\ngroups = {\n    frozenset({\"Alice\", \"Bob\"}),\n    frozenset({\"Charlie\", \"Diana\"}),\n    frozenset({\"Eve\", \"Frank\"}),\n}\nprint(groups)\n</code></pre> <p>Here's a quick comparison of all four collection types you've learned so far:</p> Feature List Tuple Set Frozenset Syntax <code>[1, 2, 3]</code> <code>(1, 2, 3)</code> <code>{1, 2, 3}</code> <code>frozenset({1, 2, 3})</code> Ordered? Yes Yes No No Mutable? Yes No Yes No Duplicates? Allowed Allowed Not allowed Not allowed Indexable? Yes Yes No No Dict key? No Yes No Yes"},{"location":"chapters/10-tuples-and-sets/#diagram-python-collections-overview","title":"Diagram: Python Collections Overview","text":"Python Collections Overview Interactive Chart <p>Type: infographic sim-id: python-collections-overview Library: p5.js Status: Specified</p> <p>Bloom Level: Analyze (L4) Bloom Verb: compare, classify</p> <p>Learning Objective: Students will be able to classify Python's four core collection types (list, tuple, set, frozenset) by their properties and select the appropriate type for a given scenario.</p> <p>Purpose: A 2x2 matrix chart showing all four collection types organized by two axes: ordered vs unordered (horizontal) and mutable vs immutable (vertical), with hover details for each.</p> <p>Layout: - A 2x2 grid with:   - Top-left (Ordered + Mutable): List   - Top-right (Unordered + Mutable): Set   - Bottom-left (Ordered + Immutable): Tuple   - Bottom-right (Unordered + Immutable): Frozenset - X-axis labeled \"Ordered &lt;---&gt; Unordered\" - Y-axis labeled \"Mutable &lt;---&gt; Immutable\" - Each quadrant contains a card for the collection type</p> <p>Interactive elements: - Hover over any quadrant card to see:   - Syntax example   - Key properties (duplicates allowed?, indexable?, can be dict key?)   - Best use case   - Icon representation (list = numbered boxes, tuple = locked numbered boxes, set = unique marbles, frozenset = locked unique marbles) - A \"Quiz Me\" button presents a property (e.g., \"Immutable + Ordered\") and asks which type fits - Click a quadrant to expand it with more examples and code snippets</p> <p>Visual elements: - Each quadrant has a distinct color: List (green), Tuple (gold), Set (blue), Frozenset (purple) - Lock icons on immutable types - Number badges on ordered types - \"No duplicates\" icons on set types</p> <p>Instructional Rationale: A 2x2 matrix organized by the two most important properties (ordered/unordered and mutable/immutable) gives students a clear mental model for classification. The spatial layout makes the relationships between types immediately visible, supporting the Analyze level.</p>"},{"location":"chapters/10-tuples-and-sets/#putting-it-all-together","title":"Putting It All Together","text":"<p>Let's see tuples and sets working together in a realistic example. Imagine you're building a simple student grade tracker:</p> <pre><code># Student records as tuples (name, grade, gpa) -- fixed data\nstudents = [\n    (\"Alice\", 10, 3.8),\n    (\"Bob\", 11, 3.2),\n    (\"Charlie\", 10, 3.5),\n    (\"Diana\", 12, 3.9),\n    (\"Eve\", 10, 3.1),\n]\n\n# Unpack tuples in a loop\nfor name, grade, gpa in students:\n    if gpa &gt;= 3.5:\n        print(f\"{name} (Grade {grade}) made the honor roll!\")\n\n# Use a set to find unique grade levels\ngrade_levels = {grade for name, grade, gpa in students}\nprint(f\"Grade levels represented: {grade_levels}\")\n# Grade levels represented: {10, 11, 12}\n\n# Use tuple as dictionary key: (grade_level,) -&gt; list of students\nby_grade = {}\nfor name, grade, gpa in students:\n    if grade not in by_grade:\n        by_grade[grade] = []\n    by_grade[grade].append(name)\n\nprint(by_grade)\n# {10: ['Alice', 'Charlie', 'Eve'], 11: ['Bob'], 12: ['Diana']}\n\n# Find students in BOTH the math club and science club\nmath_club = {\"Alice\", \"Bob\", \"Charlie\"}\nscience_club = {\"Bob\", \"Diana\", \"Charlie\", \"Eve\"}\n\nboth_clubs = math_club &amp; science_club\nprint(f\"In both clubs: {both_clubs}\")      # {'Bob', 'Charlie'}\n\neither_club = math_club | science_club\nprint(f\"In at least one club: {either_club}\")  # All five students\n</code></pre> <p>This example uses tuples for fixed student records, unpacking to access individual fields, sets for finding unique values and computing overlaps, and dictionaries with integer keys. Each data structure plays to its strengths.</p>"},{"location":"chapters/10-tuples-and-sets/#diagram-tuple-and-set-concept-map","title":"Diagram: Tuple and Set Concept Map","text":"Tuple and Set Concept Map <p>Type: diagram sim-id: tuple-set-concept-map Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: summarize, relate</p> <p>Learning Objective: Students will be able to summarize the relationships between tuples, sets, frozensets, and lists by exploring a concept map that connects their shared and distinct properties.</p> <p>Purpose: An interactive concept map showing how tuples and sets relate to each other and to lists and frozensets, with nodes for key properties and operations.</p> <p>Layout: - Central column: Four nodes vertically for List, Tuple, Set, Frozenset - Connected property nodes branching out:   - \"Ordered\" connects to List and Tuple   - \"Unordered\" connects to Set and Frozenset   - \"Mutable\" connects to List and Set   - \"Immutable\" connects to Tuple and Frozenset   - \"Allows Duplicates\" connects to List and Tuple   - \"Unique Elements\" connects to Set and Frozenset   - \"Can Be Dict Key\" connects to Tuple and Frozenset - Operation nodes for sets: Union, Intersection, Difference, Symmetric Difference</p> <p>Interactive elements: - Hover over any collection type node to highlight all its connected properties - Hover over a property node to highlight all collection types that share it - Click a collection type to see a code example in a tooltip - Animated connection lines that pulse when highlighted</p> <p>Visual elements: - Collection type nodes: large rounded rectangles with distinct colors - Property nodes: smaller ovals - Connection lines: color-coded to match the property - Pulse animation on hover for connected nodes</p> <p>Instructional Rationale: A concept map supports the Understand level by making relationships explicit and visual. Highlighting connections on hover helps students see patterns (e.g., \"immutable types can be dict keys\") that might not be obvious from reading text alone.</p> <p>Monty says: You've got this!</p> <p> Awesome work, coder! You've just added two powerful tools to your Python toolkit. Tuples keep your data safe and unchangeable, and sets make finding unique values and comparing groups a breeze. In the next chapter, we'll tackle dictionaries -- the ultimate key-value data structure. Get ready for even more collection power!</p>"},{"location":"chapters/10-tuples-and-sets/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>A tuple is an ordered, immutable sequence created with parentheses <code>()</code>. Once created, it can't be changed.</li> <li>Tuple packing bundles values into a tuple; tuple unpacking extracts them into separate variables. The swap trick <code>a, b = b, a</code> uses both.</li> <li>Tuples have only two methods: <code>count()</code> and <code>index()</code>. Their simplicity is a feature, not a limitation.</li> <li>Tuples can be dictionary keys because they're immutable. Lists cannot.</li> <li>Use tuples for fixed data (coordinates, records) and lists for data that changes.</li> <li>A set is an unordered collection of unique elements created with <code>{}</code> or <code>set()</code>.</li> <li>Sets support union (<code>|</code>), intersection (<code>&amp;</code>), difference (<code>-</code>), and symmetric difference (<code>^</code>).</li> <li>Membership testing (<code>in</code>) is much faster with sets than with lists -- (O(1)) vs (O(n)).</li> <li>Convert a list to a set and back to remove duplicates quickly.</li> <li>A frozenset is an immutable set -- it can be used as a dictionary key or stored inside another set.</li> <li>Use <code>discard()</code> instead of <code>remove()</code> when you're unsure if an element exists in a set.</li> </ul> Check Your Understanding: What's the difference between <code>(42)</code> and <code>(42,)</code> in Python? <p><code>(42)</code> is just the integer <code>42</code> -- the parentheses are treated as grouping, like in a math expression. <code>(42,)</code> is a tuple containing one element. The trailing comma is what tells Python it's a tuple. You can verify with <code>type((42))</code> which returns <code>&lt;class 'int'&gt;</code> and <code>type((42,))</code> which returns <code>&lt;class 'tuple'&gt;</code>.</p> Check Your Understanding: Given <code>A = {1, 2, 3, 4}</code> and <code>B = {3, 4, 5, 6}</code>, what is <code>A &amp; B</code> and <code>A ^ B</code>? <p><code>A &amp; B</code> is the intersection -- elements in both sets: <code>{3, 4}</code>. <code>A ^ B</code> is the symmetric difference -- elements in one set but not both: <code>{1, 2, 5, 6}</code>. Think of symmetric difference as the union minus the intersection.</p> Check Your Understanding: Why can tuples be used as dictionary keys but lists cannot? <p>Dictionary keys must be immutable (unchangeable). Tuples are immutable, so Python can compute a stable hash value for them. Lists are mutable -- if you changed a list after using it as a key, the hash would become invalid and the dictionary wouldn't work correctly. For the same reason, regular sets can't be dict keys, but frozensets can.</p>"},{"location":"chapters/11-dictionaries/","title":"Dictionaries","text":""},{"location":"chapters/11-dictionaries/#dictionaries","title":"Dictionaries","text":""},{"location":"chapters/11-dictionaries/#summary","title":"Summary","text":"<p>This chapter introduces Python dictionaries, the powerful key-value data structure. Students will learn to create dictionaries, access and modify values, use essential methods (get, keys, values, items), iterate over dictionaries, and write dictionary comprehensions. The chapter also covers practical patterns including counting, grouping, caching, and understanding hashable keys. Dictionaries are one of Python's most important and frequently used data structures.</p>"},{"location":"chapters/11-dictionaries/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 21 concepts from the learning graph:</p> <ol> <li>Dictionaries</li> <li>Dictionary Creation</li> <li>Key-Value Pairs</li> <li>Dictionary Access</li> <li>Dictionary Methods</li> <li>Get Method</li> <li>Keys Method</li> <li>Values Method</li> <li>Items Method</li> <li>Dictionary Iteration</li> <li>Dictionary Comprehension</li> <li>Nested Dictionaries</li> <li>Default Values</li> <li>Update Method</li> <li>Pop Method for Dicts</li> <li>Dictionary Merging</li> <li>Counting with Dicts</li> <li>Grouping with Dicts</li> <li>Dictionary as Cache</li> <li>Hashable Keys</li> <li>Dict vs List Lookup</li> </ol>"},{"location":"chapters/11-dictionaries/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 2: Python Fundamentals</li> <li>Chapter 4: Control Flow</li> <li>Chapter 6: Functions and Modular Design</li> <li>Chapter 8: Lists</li> <li>Chapter 10: Tuples and Sets</li> </ul> <p>Monty says: Let's code this!</p> <p> Welcome back, coders! You've already mastered lists, tuples, and sets. Now it's time to unlock one of Python's most powerful data structures: the dictionary. Think of it like a real dictionary \u2014 you look up a word and get its definition. Python dictionaries work the same way, except you can look up anything and get anything back. Let's dive in!</p>"},{"location":"chapters/11-dictionaries/#what-are-dictionaries","title":"What Are Dictionaries?","text":"<p>Have you ever used a real dictionary? You look up a word (like \"python\") and find its definition (\"a large heavy-bodied nonvenomous snake\"). You don't start at page 1 and read every entry until you find the word. You jump straight to the right spot. That's incredibly fast.</p> <p>Dictionaries in Python work the same way. Instead of storing items in a numbered sequence like a list, a dictionary stores key-value pairs \u2014 a key that you look up, paired with a value that you get back. The key is like the word you're looking up, and the value is like the definition you find.</p> <p>Here's why dictionaries matter: they let you store relationships between pieces of data. A student's name maps to their grade. A product code maps to its price. A username maps to their profile. Anywhere you have a \"this goes with that\" relationship, dictionaries are your best friend.</p>"},{"location":"chapters/11-dictionaries/#creating-dictionaries","title":"Creating Dictionaries","text":"<p>Dictionary creation in Python uses curly braces <code>{}</code> with keys and values separated by colons. Let's see a few ways to build one.</p> <pre><code># Method 1: Curly braces with key: value pairs\nstudent = {\"name\": \"Alice\", \"grade\": 10, \"gpa\": 3.8}\n\n# Method 2: The dict() constructor\nstudent = dict(name=\"Alice\", grade=10, gpa=3.8)\n\n# Method 3: From a list of tuples\npairs = [(\"name\", \"Alice\"), (\"grade\", 10), (\"gpa\", 3.8)]\nstudent = dict(pairs)\n\n# Method 4: An empty dictionary\nempty = {}\nalso_empty = dict()\n</code></pre> <p>All three methods above create the same dictionary. Method 1 is the most common \u2014 you'll see it everywhere.</p> <p>Notice that keys and values can be different types. In our <code>student</code> dictionary, the keys are all strings, but the values include a string (<code>\"Alice\"</code>), an integer (<code>10</code>), and a float (<code>3.8</code>). Python is flexible like that.</p>"},{"location":"chapters/11-dictionaries/#diagram-dictionary-structure-visualizer","title":"Diagram: Dictionary Structure Visualizer","text":"Dictionary Structure Visualizer MicroSim <p>Type: diagram sim-id: dictionary-structure Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: describe, illustrate</p> <p>Learning Objective: Students will be able to visualize how a Python dictionary stores key-value pairs and understand the mapping relationship between keys and values.</p> <p>Purpose: An interactive visualization showing the internal structure of a dictionary as a set of key-value pairs, with arrows mapping each key to its corresponding value.</p> <p>Layout:</p> <ul> <li>Left column: Keys displayed as labeled boxes (e.g., \"name\", \"grade\", \"gpa\")</li> <li>Right column: Values displayed as labeled boxes (e.g., \"Alice\", 10, 3.8)</li> <li>Arrows connecting each key to its value</li> <li>Bottom: A text input for adding new key-value pairs and a button to add them</li> </ul> <p>Interactive elements:</p> <ul> <li>Hover over a key to highlight the arrow and its corresponding value</li> <li>Click \"Add Pair\" to add a new key-value pair to the visualization</li> <li>Click \"Remove\" on any pair to delete it</li> <li>A \"Show Code\" toggle that displays the Python code that would create the shown dictionary</li> </ul> <p>Color scheme: Keys in blue boxes, values in green boxes, arrows in gray Responsive: Layout adjusts to window width; boxes resize proportionally</p> <p>Instructional Rationale: Visualizing the mapping relationship between keys and values makes the abstract concept of key-value storage concrete. Interactive add/remove operations let students see how dictionaries grow and change.</p>"},{"location":"chapters/11-dictionaries/#key-value-pairs","title":"Key-Value Pairs","text":"<p>Let's zoom in on key-value pairs, because they're the heart of every dictionary. A key-value pair is a single entry in the dictionary: the key is the label, and the value is the data associated with that label.</p> <pre><code>phone_book = {\n    \"Alice\": \"555-1234\",\n    \"Bob\": \"555-5678\",\n    \"Charlie\": \"555-9012\"\n}\n</code></pre> <p>In this phone book dictionary:</p> <ul> <li><code>\"Alice\"</code> is a key, and <code>\"555-1234\"</code> is its value</li> <li><code>\"Bob\"</code> is a key, and <code>\"555-5678\"</code> is its value</li> <li><code>\"Charlie\"</code> is a key, and <code>\"555-9012\"</code> is its value</li> </ul> <p>A few important rules about keys:</p> <ul> <li>Keys must be unique. You can't have two entries for \"Alice.\" If you assign a new value to an existing key, it overwrites the old one.</li> <li>Keys must be immutable. You can use strings, numbers, or tuples as keys \u2014 but not lists or other dictionaries. (We'll explain why in the Hashable Keys section.)</li> <li>Values can be anything. Strings, numbers, lists, other dictionaries \u2014 even functions!</li> </ul>"},{"location":"chapters/11-dictionaries/#accessing-dictionary-values","title":"Accessing Dictionary Values","text":"<p>Dictionary access is how you retrieve a value using its key. The most straightforward way is with square brackets.</p> <pre><code>student = {\"name\": \"Alice\", \"grade\": 10, \"gpa\": 3.8}\n\nprint(student[\"name\"])    # Output: Alice\nprint(student[\"grade\"])   # Output: 10\nprint(student[\"gpa\"])     # Output: 3.8\n</code></pre> <p>You can also modify values or add new key-value pairs using the same bracket notation:</p> <pre><code># Change an existing value\nstudent[\"gpa\"] = 3.9\n\n# Add a new key-value pair\nstudent[\"school\"] = \"Westside High\"\n\nprint(student)\n# {'name': 'Alice', 'grade': 10, 'gpa': 3.9, 'school': 'Westside High'}\n</code></pre> <p>Monty says: Watch out!</p> <p> Be careful! If you try to access a key that doesn't exist using square brackets, Python will raise a <code>KeyError</code>. For example, <code>student[\"age\"]</code> would crash your program if <code>\"age\"</code> isn't a key in the dictionary. Use the <code>get</code> method (covered next) for safer lookups!</p> <pre><code># This will crash with a KeyError!\nprint(student[\"age\"])  # KeyError: 'age'\n</code></pre>"},{"location":"chapters/11-dictionaries/#dictionary-methods","title":"Dictionary Methods","text":"<p>Python dictionary methods give you a toolkit for working with dictionaries without writing everything from scratch. Let's explore the most important ones.</p>"},{"location":"chapters/11-dictionaries/#the-get-method","title":"The Get Method","text":"<p>The get method is a safer way to access dictionary values. Instead of crashing with a <code>KeyError</code> when a key doesn't exist, <code>get()</code> returns <code>None</code> (or a default value you specify).</p> <pre><code>student = {\"name\": \"Alice\", \"grade\": 10}\n\n# Safe lookup \u2014 returns None if key not found\nage = student.get(\"age\")\nprint(age)  # Output: None\n\n# Safe lookup with a default value\nage = student.get(\"age\", 16)\nprint(age)  # Output: 16\n\n# Key exists \u2014 works normally\nname = student.get(\"name\")\nprint(name)  # Output: Alice\n</code></pre> <p>Default values are incredibly useful. They let you provide a fallback when a key might not exist, without any extra if/else logic. You'll see this pattern constantly in real-world Python code.</p>"},{"location":"chapters/11-dictionaries/#the-keys-method","title":"The Keys Method","text":"<p>The keys method returns all the keys in a dictionary. It gives you a special view object that you can loop through or convert to a list.</p> <pre><code>student = {\"name\": \"Alice\", \"grade\": 10, \"gpa\": 3.8}\n\nprint(student.keys())\n# Output: dict_keys(['name', 'grade', 'gpa'])\n\n# Convert to a list\nkey_list = list(student.keys())\nprint(key_list)  # Output: ['name', 'grade', 'gpa']\n</code></pre>"},{"location":"chapters/11-dictionaries/#the-values-method","title":"The Values Method","text":"<p>The values method does the same thing, but for values instead of keys.</p> <pre><code>print(student.values())\n# Output: dict_values(['Alice', 10, 3.8])\n\n# Convert to a list\nvalue_list = list(student.values())\nprint(value_list)  # Output: ['Alice', 10, 3.8]\n</code></pre>"},{"location":"chapters/11-dictionaries/#the-items-method","title":"The Items Method","text":"<p>The items method returns both keys and values as a collection of tuples. This is especially powerful when looping.</p> <pre><code>print(student.items())\n# Output: dict_items([('name', 'Alice'), ('grade', 10), ('gpa', 3.8)])\n\n# Loop through key-value pairs\nfor key, value in student.items():\n    print(f\"{key}: {value}\")\n# Output:\n# name: Alice\n# grade: 10\n# gpa: 3.8\n</code></pre>"},{"location":"chapters/11-dictionaries/#the-update-method","title":"The Update Method","text":"<p>The update method merges another dictionary into the current one. If both dictionaries share a key, the value from the new dictionary wins.</p> <pre><code>student = {\"name\": \"Alice\", \"grade\": 10}\nnew_info = {\"gpa\": 3.8, \"grade\": 11}\n\nstudent.update(new_info)\nprint(student)\n# Output: {'name': 'Alice', 'grade': 11, 'gpa': 3.8}\n</code></pre> <p>Notice that <code>\"grade\"</code> was updated from <code>10</code> to <code>11</code> because <code>new_info</code> had a different value for that key.</p>"},{"location":"chapters/11-dictionaries/#the-pop-method-for-dicts","title":"The Pop Method for Dicts","text":"<p>The pop method for dicts removes a key-value pair and returns the value. It's like reaching into the dictionary and pulling out an entry.</p> <pre><code>student = {\"name\": \"Alice\", \"grade\": 10, \"gpa\": 3.8}\n\nremoved_value = student.pop(\"gpa\")\nprint(removed_value)  # Output: 3.8\nprint(student)        # Output: {'name': 'Alice', 'grade': 10}\n\n# With a default to avoid KeyError\nmissing = student.pop(\"age\", \"Not found\")\nprint(missing)  # Output: Not found\n</code></pre>"},{"location":"chapters/11-dictionaries/#dictionary-methods-reference-table","title":"Dictionary Methods Reference Table","text":"<p>Here's a comprehensive reference for the most common dictionary methods:</p> Method Description Example Returns <code>d.get(key, default)</code> Safe value lookup <code>d.get(\"age\", 0)</code> Value or default <code>d.keys()</code> All keys <code>d.keys()</code> <code>dict_keys</code> view <code>d.values()</code> All values <code>d.values()</code> <code>dict_values</code> view <code>d.items()</code> All key-value pairs <code>d.items()</code> <code>dict_items</code> view <code>d.update(other)</code> Merge another dict <code>d.update({\"a\": 1})</code> <code>None</code> (modifies <code>d</code>) <code>d.pop(key, default)</code> Remove and return <code>d.pop(\"name\")</code> Removed value <code>d.clear()</code> Remove all items <code>d.clear()</code> <code>None</code> <code>d.copy()</code> Shallow copy <code>d.copy()</code> New dict <code>d.setdefault(key, val)</code> Get or set default <code>d.setdefault(\"x\", 0)</code> Existing or new value <code>key in d</code> Check membership <code>\"name\" in d</code> <code>True</code> / <code>False</code> <code>len(d)</code> Number of pairs <code>len(d)</code> Integer <p>Monty says: Let's debug this together!</p> <p> Here's a trick that'll save you tons of time: use <code>in</code> to check if a key exists before accessing it. <code>if \"name\" in student:</code> is clean, readable, and avoids <code>KeyError</code> crashes. But honestly? The <code>get()</code> method is even cleaner for most situations.</p>"},{"location":"chapters/11-dictionaries/#dictionary-iteration","title":"Dictionary Iteration","text":"<p>Dictionary iteration means looping through a dictionary's contents. There are several ways to do it, depending on whether you need the keys, the values, or both.</p> <pre><code>scores = {\"Alice\": 95, \"Bob\": 87, \"Charlie\": 92}\n\n# Loop through keys (the default)\nfor name in scores:\n    print(name)\n# Alice, Bob, Charlie\n\n# Loop through values\nfor score in scores.values():\n    print(score)\n# 95, 87, 92\n\n# Loop through key-value pairs (most common)\nfor name, score in scores.items():\n    print(f\"{name} scored {score}\")\n# Alice scored 95\n# Bob scored 87\n# Charlie scored 92\n</code></pre> <p>The <code>items()</code> approach is the most versatile because you get both the key and the value in each iteration. You'll use it all the time.</p>"},{"location":"chapters/11-dictionaries/#diagram-dictionary-iteration-flowchart","title":"Diagram: Dictionary Iteration Flowchart","text":"Dictionary Iteration Flowchart MicroSim <p>Type: diagram sim-id: dictionary-iteration Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: trace, explain</p> <p>Learning Objective: Students will be able to trace through different dictionary iteration patterns (keys, values, items) and predict the output at each step.</p> <p>Purpose: An animated flowchart that visually steps through a for loop iterating over a dictionary, showing which key-value pair is being visited at each step and what the loop variable holds.</p> <p>Layout:</p> <ul> <li>Top: A dictionary visualized as a table with keys and values</li> <li>Middle: A for-loop code block with the current iteration highlighted</li> <li>Bottom: The output console showing what has been printed so far</li> </ul> <p>Interactive elements:</p> <ul> <li>Dropdown to select iteration type: \"keys\", \"values\", \"items\"</li> <li>\"Step\" button to advance one iteration at a time</li> <li>\"Auto Play\" button with speed control</li> <li>\"Reset\" button to restart</li> <li>The current key-value pair highlights in the dictionary table as the loop visits it</li> </ul> <p>Color scheme: Current item highlighted in yellow, visited items in light gray, unvisited in white Responsive: Canvas adjusts to window width</p> <p>Instructional Rationale: Stepping through iteration one element at a time with visual highlighting helps students build a mental model of how Python traverses dictionary contents. Comparing the three iteration modes side by side reveals when to use each one.</p>"},{"location":"chapters/11-dictionaries/#dictionary-comprehension","title":"Dictionary Comprehension","text":"<p>Just like list comprehensions, dictionary comprehensions let you build a dictionary in a single, elegant line. The syntax looks similar, but you provide both a key expression and a value expression.</p> <pre><code># Basic syntax: {key_expr: value_expr for item in iterable}\n\n# Create a dict of numbers and their squares\nsquares = {n: n ** 2 for n in range(1, 6)}\nprint(squares)\n# Output: {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}\n\n# With a condition: only even numbers\neven_squares = {n: n ** 2 for n in range(1, 11) if n % 2 == 0}\nprint(even_squares)\n# Output: {2: 4, 4: 16, 6: 36, 8: 64, 10: 100}\n\n# Transform an existing dictionary: convert scores to letter grades\nscores = {\"Alice\": 95, \"Bob\": 87, \"Charlie\": 72}\ngrades = {name: (\"A\" if s &gt;= 90 else \"B\" if s &gt;= 80 else \"C\")\n          for name, s in scores.items()}\nprint(grades)\n# Output: {'Alice': 'A', 'Bob': 'B', 'Charlie': 'C'}\n</code></pre> <p>Dictionary comprehensions are perfect for transforming data. Need to flip a dictionary's keys and values? One line:</p> <pre><code>original = {\"a\": 1, \"b\": 2, \"c\": 3}\nflipped = {v: k for k, v in original.items()}\nprint(flipped)\n# Output: {1: 'a', 2: 'b', 3: 'c'}\n</code></pre>"},{"location":"chapters/11-dictionaries/#nested-dictionaries","title":"Nested Dictionaries","text":"<p>Nested dictionaries are dictionaries that contain other dictionaries as values. They're great for representing structured, multi-level data \u2014 like a class roster where each student has multiple attributes.</p> <pre><code>classroom = {\n    \"Alice\": {\"grade\": 10, \"gpa\": 3.8, \"clubs\": [\"Chess\", \"Coding\"]},\n    \"Bob\": {\"grade\": 10, \"gpa\": 3.5, \"clubs\": [\"Soccer\"]},\n    \"Charlie\": {\"grade\": 11, \"gpa\": 3.9, \"clubs\": [\"Coding\", \"Math\"]}\n}\n\n# Access nested values by chaining brackets\nprint(classroom[\"Alice\"][\"gpa\"])         # Output: 3.8\nprint(classroom[\"Charlie\"][\"clubs\"][0])  # Output: Coding\n\n# Add a new student\nclassroom[\"Diana\"] = {\"grade\": 10, \"gpa\": 3.7, \"clubs\": [\"Art\"]}\n</code></pre> <p>Think of nested dictionaries like folders inside folders on your computer. The outer dictionary is the main folder, and each value is a subfolder containing more detailed information.</p>"},{"location":"chapters/11-dictionaries/#diagram-nested-dictionary-explorer","title":"Diagram: Nested Dictionary Explorer","text":"Nested Dictionary Explorer MicroSim <p>Type: microsim sim-id: nested-dictionary Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: navigate, construct</p> <p>Learning Objective: Students will be able to navigate through nested dictionaries by clicking through levels of keys and constructing the bracket-chain notation needed to access deeply nested values.</p> <p>Purpose: An interactive tree visualization of a nested dictionary where students can expand and collapse levels, and the tool generates the Python access expression for any selected value.</p> <p>Layout:</p> <ul> <li>Left panel: A tree view of the nested dictionary, with expandable/collapsible nodes</li> <li>Right panel: The Python code showing the full access expression for the currently selected node</li> <li>Bottom: An input field where students can type an access expression and see the resulting value</li> </ul> <p>Interactive elements:</p> <ul> <li>Click a key node to expand/collapse its children</li> <li>Click a leaf value to highlight it and display the full access path (e.g., <code>classroom[\"Alice\"][\"gpa\"]</code>)</li> <li>Type an access expression in the input field and press Enter to see if it returns the correct value</li> <li>\"Add Entry\" button to add a new key-value pair at any level</li> </ul> <p>Visual style: Tree layout with indented levels, color-coded by depth Responsive: Panels stack vertically on narrow screens</p> <p>Instructional Rationale: Interactive tree navigation lets students build intuition for how nested access works. Seeing the access expression update as they click through levels connects the visual structure to the Python syntax.</p>"},{"location":"chapters/11-dictionaries/#dictionary-merging","title":"Dictionary Merging","text":"<p>Dictionary merging combines two or more dictionaries into one. Python 3.9 introduced the <code>|</code> operator for this, making it clean and readable.</p> <pre><code>defaults = {\"color\": \"blue\", \"size\": \"medium\", \"font\": \"Arial\"}\nuser_prefs = {\"color\": \"red\", \"size\": \"large\"}\n\n# Method 1: The | operator (Python 3.9+)\nmerged = defaults | user_prefs\nprint(merged)\n# Output: {'color': 'red', 'size': 'large', 'font': 'Arial'}\n\n# Method 2: The ** unpacking operator (Python 3.5+)\nmerged = {**defaults, **user_prefs}\nprint(merged)\n# Output: {'color': 'red', 'size': 'large', 'font': 'Arial'}\n\n# Method 3: The update method (modifies in place)\ncombined = defaults.copy()\ncombined.update(user_prefs)\nprint(combined)\n# Output: {'color': 'red', 'size': 'large', 'font': 'Arial'}\n</code></pre> <p>In all three cases, when both dictionaries have the same key, the right-hand dictionary's value wins. In the example above, <code>user_prefs</code> overrides <code>defaults</code> for <code>\"color\"</code> and <code>\"size\"</code>, while <code>\"font\"</code> carries over from <code>defaults</code> since the user didn't set one.</p> <p>Monty says: Here's a handy trick!</p> <p> The <code>|</code> merge operator is my favorite way to combine dictionaries. It's clean, it's readable, and it doesn't modify either original dictionary. If you're using Python 3.9 or later (which you probably are), give it a try!</p>"},{"location":"chapters/11-dictionaries/#practical-patterns-with-dictionaries","title":"Practical Patterns with Dictionaries","text":"<p>Now that you know the fundamentals, let's look at some real-world patterns where dictionaries really shine. These patterns come up constantly in programming \u2014 from homework assignments to professional software.</p>"},{"location":"chapters/11-dictionaries/#counting-with-dicts","title":"Counting with Dicts","text":"<p>Counting with dicts is one of the most common dictionary patterns. The idea is simple: use keys to represent the items you're counting, and values to track how many times each item appears.</p> <pre><code># Count letter frequencies in a word\nword = \"mississippi\"\nletter_counts = {}\n\nfor letter in word:\n    letter_counts[letter] = letter_counts.get(letter, 0) + 1\n\nprint(letter_counts)\n# Output: {'m': 1, 'i': 4, 's': 4, 'p': 2}\n</code></pre> <p>Let's trace through how this works:</p> <ol> <li>We start with an empty dictionary</li> <li>For each letter, <code>get(letter, 0)</code> returns the current count (or <code>0</code> if it's the first time)</li> <li>We add <code>1</code> and store the new count back</li> </ol> <p>This pattern is so useful that Python has a built-in shortcut for it in the <code>collections</code> module called <code>Counter</code>, but understanding the manual approach teaches you a lot about how dictionaries work.</p> <pre><code># Bonus: Count word frequencies in a sentence\nsentence = \"the cat sat on the mat the cat\"\nword_counts = {}\n\nfor w in sentence.split():\n    word_counts[w] = word_counts.get(w, 0) + 1\n\nprint(word_counts)\n# Output: {'the': 3, 'cat': 2, 'sat': 1, 'on': 1, 'mat': 1}\n</code></pre>"},{"location":"chapters/11-dictionaries/#grouping-with-dicts","title":"Grouping with Dicts","text":"<p>Grouping with dicts organizes items into categories. Each key is a category, and each value is a list of items that belong to that category.</p> <pre><code># Group students by grade level\nstudents = [\n    (\"Alice\", 10), (\"Bob\", 11), (\"Charlie\", 10),\n    (\"Diana\", 11), (\"Eve\", 10), (\"Frank\", 12)\n]\n\nby_grade = {}\nfor name, grade in students:\n    if grade not in by_grade:\n        by_grade[grade] = []\n    by_grade[grade].append(name)\n\nprint(by_grade)\n# Output: {10: ['Alice', 'Charlie', 'Eve'], 11: ['Bob', 'Diana'], 12: ['Frank']}\n</code></pre> <p>Here's a cleaner version using <code>setdefault()</code>:</p> <pre><code>by_grade = {}\nfor name, grade in students:\n    by_grade.setdefault(grade, []).append(name)\n\nprint(by_grade)\n# Same output: {10: ['Alice', 'Charlie', 'Eve'], 11: ['Bob', 'Diana'], 12: ['Frank']}\n</code></pre> <p>The <code>setdefault()</code> method checks if the key exists. If it does, it returns the existing value. If not, it sets the default value (an empty list here) and returns it. Either way, you can immediately call <code>.append()</code> on the result.</p>"},{"location":"chapters/11-dictionaries/#diagram-counting-and-grouping-patterns","title":"Diagram: Counting and Grouping Patterns","text":"Counting and Grouping Patterns MicroSim <p>Type: microsim sim-id: dict-patterns Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: implement, demonstrate</p> <p>Learning Objective: Students will be able to implement counting and grouping patterns by watching how a dictionary builds up step by step as data is processed.</p> <p>Purpose: A step-by-step animated visualization that shows how a dictionary grows as items are counted or grouped, with the dictionary state updating after each iteration.</p> <p>Layout:</p> <ul> <li>Top: A selector to toggle between \"Counting Mode\" and \"Grouping Mode\"</li> <li>Left panel: The input data (a word for counting, or a list of student-grade tuples for grouping)</li> <li>Center: The current item being processed, highlighted</li> <li>Right panel: The dictionary, updated in real-time after each step</li> </ul> <p>Interactive elements:</p> <ul> <li>\"Step\" button to process one item at a time</li> <li>\"Auto Play\" button with speed slider</li> <li>\"Reset\" button</li> <li>Toggle between counting and grouping modes</li> <li>Custom input field to type your own word or data set</li> </ul> <p>Visual style: Dictionary displayed as a growing table with animated row additions and value updates Responsive: Panels stack vertically on narrow screens</p> <p>Instructional Rationale: Watching the dictionary build up one entry at a time demystifies the counting and grouping patterns. Students can predict what the next step will produce before clicking \"Step,\" turning observation into active practice.</p>"},{"location":"chapters/11-dictionaries/#dictionary-as-cache","title":"Dictionary as Cache","text":"<p>A dictionary as cache (also called memoization) stores the results of expensive calculations so you don't have to repeat them. It's like keeping a cheat sheet of answers you've already figured out.</p> <pre><code># Without caching: slow recursive Fibonacci\ndef fib_slow(n):\n    if n &lt;= 1:\n        return n\n    return fib_slow(n - 1) + fib_slow(n - 2)\n\n# With caching: fast Fibonacci\ncache = {}\n\ndef fib_fast(n):\n    if n in cache:\n        return cache[n]\n    if n &lt;= 1:\n        result = n\n    else:\n        result = fib_fast(n - 1) + fib_fast(n - 2)\n    cache[n] = result\n    return result\n\nprint(fib_fast(50))  # Instant! Output: 12586269025\n</code></pre> <p>Without caching, computing <code>fib_slow(50)</code> would take an absurdly long time because it recalculates the same values millions of times. With a dictionary cache, each value is calculated only once and then remembered. The 50th Fibonacci number comes back instantly.</p> <p>This pattern works because dictionary lookups are incredibly fast \u2014 almost instant, no matter how many items are in the dictionary. Speaking of which...</p>"},{"location":"chapters/11-dictionaries/#hashable-keys","title":"Hashable Keys","text":"<p>Why can strings and numbers be dictionary keys, but lists can't? The answer involves something called a hash.</p> <p>Hashable keys are keys that Python can convert into a fixed-size integer called a hash code. Python uses this hash code to figure out where to store the key-value pair internally, making lookups blazingly fast. It's like assigning each book in a library a specific shelf number \u2014 instead of searching every shelf, you go directly to the right one.</p> <p>For this to work, keys must be immutable (unchangeable). If a key could change after being stored, its hash code would change, and Python wouldn't be able to find it anymore. It'd be like moving a library book to a different shelf without updating the catalog.</p> <p>Here's what's hashable and what's not:</p> Type Hashable? Can Be a Key? Why? <code>str</code> Yes Yes Strings are immutable <code>int</code> Yes Yes Integers are immutable <code>float</code> Yes Yes Floats are immutable <code>tuple</code> Yes* Yes* *Only if it contains only hashable items <code>bool</code> Yes Yes Booleans are immutable <code>list</code> No No Lists are mutable (can change) <code>dict</code> No No Dicts are mutable <code>set</code> No No Sets are mutable <pre><code># These work\nd = {}\nd[\"hello\"] = 1        # String key\nd[42] = 2             # Integer key\nd[(1, 2)] = 3         # Tuple key\n\n# These DON'T work\nd[[1, 2]] = 4         # TypeError: unhashable type: 'list'\nd[{\"a\": 1}] = 5       # TypeError: unhashable type: 'dict'\n</code></pre> <p>Monty says: You've got this!</p> <p> Here's an easy rule of thumb: if you can't change it, you can hash it. Strings, numbers, and tuples are locked in place once created, so they make great dictionary keys. Lists, dictionaries, and sets can be modified, so Python won't let you use them as keys.</p>"},{"location":"chapters/11-dictionaries/#dict-vs-list-lookup","title":"Dict vs List Lookup","text":"<p>Now for one of the most powerful reasons to use dictionaries: dict vs list lookup performance. Dictionaries are dramatically faster than lists when you need to check if something exists.</p> <p>With a list, Python has to check each item one by one from the beginning. If the list has a million items, that could mean up to a million comparisons. This is called linear search \u2014 the time grows proportionally with the size of the list.</p> <p>With a dictionary, Python uses the hash code to jump directly to the right spot. It doesn't matter if the dictionary has 10 items or 10 million \u2014 the lookup takes roughly the same amount of time. This is called constant time or O(1) lookup.</p> <p>Here's a comparison:</p> Operation List Dictionary Check if item exists O(n) \u2014 slow for large data O(1) \u2014 fast regardless of size Look up by index/key O(1) by index O(1) by key Insert at end O(1) O(1) Search for a value Scan every element Instant by key Best for Ordered sequences Key-value lookups <pre><code># List lookup: gets slower as the list grows\nbig_list = list(range(1_000_000))\n999_999 in big_list   # Checks up to 1 million items!\n\n# Dict lookup: always fast\nbig_dict = {n: True for n in range(1_000_000)}\n999_999 in big_dict   # Jumps straight to it!\n</code></pre>"},{"location":"chapters/11-dictionaries/#diagram-dict-vs-list-lookup-performance","title":"Diagram: Dict vs List Lookup Performance","text":"Dict vs List Lookup Performance MicroSim <p>Type: microsim sim-id: dict-vs-list Library: p5.js Status: Specified</p> <p>Bloom Level: Analyze (L4) Bloom Verb: compare, differentiate</p> <p>Learning Objective: Students will be able to compare the lookup performance of lists vs dictionaries and explain why dictionaries are faster for membership testing.</p> <p>Purpose: An animated race visualization that searches for a value in both a list and a dictionary simultaneously, showing the dramatic speed difference as data sizes grow.</p> <p>Layout:</p> <ul> <li>Top: Slider to set the collection size (100, 1000, 10000, 100000)</li> <li>Center: Two lanes labeled \"List Search\" and \"Dict Search\"</li> <li>The list lane shows an animated cursor scanning through elements one by one</li> <li>The dict lane shows the hash calculation and direct jump</li> <li>Bottom: Timer showing elapsed comparison steps for each</li> </ul> <p>Interactive elements:</p> <ul> <li>Size slider to change the number of items (demonstrates how list search time grows while dict stays constant)</li> <li>\"Race!\" button to start the comparison</li> <li>\"Search for:\" input to choose which value to search for</li> <li>Results display showing the number of steps each method took</li> </ul> <p>Visual style: Racing lanes with animated search cursors, bar chart of steps taken Responsive: Canvas width adjusts to window</p> <p>Instructional Rationale: A race visualization makes the abstract concept of time complexity visceral and memorable. Adjusting the data size lets students see firsthand that dictionary lookup time stays flat while list lookup time grows, building intuition for Big-O analysis.</p> <p>In real programs, this performance difference matters a lot. If you're checking whether a username exists in a system with millions of users, a dictionary (or set) gives you an instant answer. A list would make your users wait.</p> <pre><code># Real-world example: checking if a username is taken\n# BAD approach with a list\ntaken_usernames_list = [\"alice\", \"bob\", \"charlie\", ...]  # millions of names\n\nif \"newuser\" in taken_usernames_list:  # Potentially slow!\n    print(\"Username taken\")\n\n# GOOD approach with a dictionary (or set)\ntaken_usernames_dict = {\"alice\": True, \"bob\": True, \"charlie\": True, ...}\n\nif \"newuser\" in taken_usernames_dict:  # Always fast!\n    print(\"Username taken\")\n</code></pre>"},{"location":"chapters/11-dictionaries/#diagram-dictionary-use-cases-infographic","title":"Diagram: Dictionary Use Cases Infographic","text":"Dictionary Use Cases Infographic <p>Type: infographic sim-id: dict-use-cases Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: classify, summarize</p> <p>Learning Objective: Students will be able to identify common real-world scenarios where dictionaries are the appropriate data structure and explain why.</p> <p>Purpose: An interactive infographic showing 6 real-world dictionary use cases (phone book, word counter, grade book, shopping cart, game inventory, translation dictionary) with hover-to-reveal Python code examples.</p> <p>Layout:</p> <ul> <li>6 cards arranged in a 3x2 grid, each showing an icon and title for a use case</li> <li>Hovering over a card expands it to show a brief description and a Python code snippet</li> </ul> <p>Interactive elements:</p> <ul> <li>Hover/click to expand each card</li> <li>A \"Which data structure?\" quiz mode where students see a scenario and choose between list, dictionary, tuple, or set</li> </ul> <p>Visual style: Card-based layout with icons, clean typography Responsive: Cards reflow to 2x3 or 1x6 on narrower screens</p> <p>Instructional Rationale: Connecting dictionary concepts to familiar real-world scenarios (phone books, grade books, shopping carts) helps students transfer abstract knowledge to practical application. Quiz mode provides immediate self-assessment.</p>"},{"location":"chapters/11-dictionaries/#putting-it-all-together","title":"Putting It All Together","text":"<p>Let's combine several dictionary techniques into a practical example. Imagine you're building a simple grade tracker for a class:</p> <pre><code># Grade tracker using multiple dictionary patterns\ndef grade_tracker():\n    grades = {}\n\n    # Add some test scores\n    student_scores = [\n        (\"Alice\", 95), (\"Bob\", 87), (\"Alice\", 91),\n        (\"Charlie\", 78), (\"Bob\", 92), (\"Alice\", 88),\n        (\"Charlie\", 85), (\"Bob\", 79)\n    ]\n\n    # Group scores by student (grouping pattern)\n    for name, score in student_scores:\n        grades.setdefault(name, []).append(score)\n\n    print(\"All scores:\", grades)\n    # {'Alice': [95, 91, 88], 'Bob': [87, 92, 79], 'Charlie': [78, 85]}\n\n    # Calculate averages (dictionary comprehension)\n    averages = {name: sum(scores) / len(scores)\n                for name, scores in grades.items()}\n\n    print(\"Averages:\", averages)\n    # {'Alice': 91.33, 'Bob': 86.0, 'Charlie': 81.5}\n\n    # Assign letter grades\n    letter_grades = {}\n    for name, avg in averages.items():\n        if avg &gt;= 90:\n            letter_grades[name] = \"A\"\n        elif avg &gt;= 80:\n            letter_grades[name] = \"B\"\n        elif avg &gt;= 70:\n            letter_grades[name] = \"C\"\n        else:\n            letter_grades[name] = \"F\"\n\n    print(\"Letter grades:\", letter_grades)\n    # {'Alice': 'A', 'Bob': 'B', 'Charlie': 'B'}\n\ngrade_tracker()\n</code></pre> <p>This example uses grouping with <code>setdefault</code>, dictionary comprehensions, and iteration \u2014 all in one natural, readable program. That's the power of dictionaries!</p> <p>Monty says: You've got this!</p> <p> Amazing work, coder! You've just learned one of the most important and versatile tools in Python. Dictionaries are everywhere \u2014 in web development, data science, game programming, and beyond. Every time you need to connect one piece of data to another, think dictionary!</p>"},{"location":"chapters/11-dictionaries/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Dictionaries store data as key-value pairs \u2014 like a real dictionary maps words to definitions.</li> <li>Create dictionaries with curly braces: <code>{\"key\": \"value\"}</code> or the <code>dict()</code> constructor.</li> <li>Access values with square brackets <code>d[\"key\"]</code> or the safer <code>get()</code> method with a default value.</li> <li>Essential methods: <code>keys()</code>, <code>values()</code>, <code>items()</code>, <code>update()</code>, <code>pop()</code>.</li> <li>Dictionary iteration with <code>items()</code> gives you both keys and values in each loop.</li> <li>Dictionary comprehensions let you build dictionaries in a single line: <code>{k: v for k, v in data}</code>.</li> <li>Nested dictionaries store structured, multi-level data by putting dictionaries inside dictionaries.</li> <li>Merge dictionaries with the <code>|</code> operator (Python 3.9+), <code>**</code> unpacking, or <code>update()</code>.</li> <li>Counting and grouping are the two most common dictionary patterns in real-world code.</li> <li>Caching (memoization) uses a dictionary to store previously computed results for speed.</li> <li>Keys must be hashable (immutable): strings, numbers, and tuples work; lists and dicts don't.</li> <li>Dict lookup is O(1) (constant time) vs list lookup which is O(n) (linear time) \u2014 dictionaries are dramatically faster for searching.</li> </ul> Check Your Understanding: What happens if you try to use a list as a dictionary key? <p>Python raises a <code>TypeError: unhashable type: 'list'</code>. Lists are mutable (they can be changed), which means Python can't compute a reliable hash code for them. Only immutable types like strings, integers, floats, and tuples (containing only hashable elements) can be used as dictionary keys. If you need a list-like key, convert it to a tuple first: <code>d[tuple(my_list)] = value</code>.</p> Check Your Understanding: Write a dictionary comprehension that maps each number from 1 to 5 to its cube. <p></p><pre><code>cubes = {n: n ** 3 for n in range(1, 6)}\nprint(cubes)\n# Output: {1: 1, 2: 8, 3: 27, 4: 64, 5: 125}\n</code></pre> The expression <code>n ** 3</code> calculates the cube (n times n times n). The <code>range(1, 6)</code> generates numbers 1 through 5. The result is a dictionary where each key is a number and each value is its cube.<p></p> Check Your Understanding: Why are dictionary lookups faster than list lookups? <p>Dictionaries use hash codes to jump directly to where a key is stored, giving them O(1) constant time lookups \u2014 the speed doesn't depend on how many items are in the dictionary. Lists, on the other hand, must scan through elements one by one (O(n) linear time), so the more items in the list, the longer it takes. For a dictionary with a million entries, lookup is still essentially instant. For a list with a million entries, you might need to check all million items in the worst case.</p>"},{"location":"chapters/12-classes-and-objects/","title":"Classes and Objects","text":""},{"location":"chapters/12-classes-and-objects/#classes-and-objects","title":"Classes and Objects","text":""},{"location":"chapters/12-classes-and-objects/#summary","title":"Summary","text":"<p>This chapter introduces object-oriented programming in Python. Students will learn to define classes, create objects, work with instance and class attributes, write constructors and methods, and understand the self parameter. The chapter covers encapsulation through private attributes, getter/setter methods, and the property decorator. These concepts enable students to model real-world entities in their programs.</p>"},{"location":"chapters/12-classes-and-objects/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 20 concepts from the learning graph:</p> <ol> <li>Object-Oriented Programming</li> <li>Classes</li> <li>Objects</li> <li>Class Definition</li> <li>Class Instantiation</li> <li>Instance Attributes</li> <li>Class Attributes</li> <li>The Self Parameter</li> <li>Init Method</li> <li>Constructor</li> <li>Methods</li> <li>Instance Methods</li> <li>Str Method</li> <li>Repr Method</li> <li>Encapsulation</li> <li>Private Attributes</li> <li>Getter Methods</li> <li>Setter Methods</li> <li>Property Decorator</li> <li>Class Methods</li> </ol>"},{"location":"chapters/12-classes-and-objects/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 1: Introduction to Computer Science</li> <li>Chapter 6: Functions and Modular Design</li> <li>Chapter 7: Higher-Order Functions and Recursion</li> </ul> <p>Monty says: Let's code this!</p> <p> Welcome back, coders! Up until now, you've been storing data in variables, lists, and dictionaries, and organizing your logic with functions. That's powerful stuff. But today we're unlocking a whole new way of thinking about your programs. Get ready to meet classes and objects \u2014 the building blocks of modern software!</p>"},{"location":"chapters/12-classes-and-objects/#what-is-object-oriented-programming","title":"What Is Object-Oriented Programming?","text":"<p>Imagine you're building a video game with dozens of characters. Each character has a name, a health level, and a special ability. Each character can attack, defend, and move. You could store all of that in separate lists and write a bunch of loose functions to manage everything \u2014 but it would get messy fast. There has to be a better way.</p> <p>There is. It's called Object-Oriented Programming (OOP for short), and it's one of the most important ideas in all of computer science. OOP is a programming style where you bundle related data and behavior together into a single unit called an object. Instead of scattering your character's data across multiple lists and writing unrelated functions, you create a self-contained \"character package\" that knows its own name, tracks its own health, and has its own methods for attacking and defending.</p> <p>Why does this matter? Because the real world is full of objects. A car has attributes (color, speed, fuel level) and behaviors (accelerate, brake, turn). A student has attributes (name, grade, GPA) and behaviors (enroll, study, graduate). OOP lets you model real-world things in your code in a way that feels natural and organized.</p> <p>Here's the big-picture analogy that will carry us through the entire chapter:</p> Real World OOP Concept Cookie cutter Class Cookie Object Shape, flavor, size Attributes Eating, decorating Methods <p>A class is like a cookie cutter \u2014 it's the template or blueprint that defines what a cookie looks like. An object is the actual cookie you press out of the dough. You can make dozens of different cookies from the same cutter, just like you can create many objects from one class. Each cookie can have different sprinkles on top (different data), but they all share the same basic shape (the same structure).</p> <p>Let's keep this cookie-cutter analogy in our back pocket. We'll use it throughout the chapter.</p>"},{"location":"chapters/12-classes-and-objects/#defining-your-first-class","title":"Defining Your First Class","text":"<p>Time to write some code. A class definition tells Python the name of your new type and what data and behavior it should have. Here's the simplest possible class:</p> <pre><code>class Dog:\n    pass\n</code></pre> <p>That's it! The <code>class</code> keyword followed by a name (capitalized by convention) and a colon creates a brand-new type called <code>Dog</code>. The <code>pass</code> statement is just a placeholder that means \"nothing here yet.\" Think of this as building an empty cookie cutter \u2014 it exists, but it doesn't do much.</p> <p>Let's make it more interesting by adding some real structure. We're going to build a <code>Dog</code> class throughout this chapter and keep adding features as we learn new concepts.</p>"},{"location":"chapters/12-classes-and-objects/#diagram-class-vs-object-visual","title":"Diagram: Class vs. Object Visual","text":"Class vs. Object Cookie Cutter Diagram <p>Type: infographic sim-id: class-vs-object-diagram Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: compare, explain</p> <p>Learning Objective: Students will be able to distinguish between a class (blueprint/template) and an object (instance) by seeing a visual analogy of a cookie cutter producing multiple cookies with different attributes.</p> <p>Purpose: A visual diagram showing a class as a cookie cutter on the left and multiple objects (cookies) on the right, each with different attribute values. Arrows show the \"instantiation\" process from class to objects.</p> <p>Layout:</p> <ul> <li>Left side: A single \"cookie cutter\" shape labeled \"Dog class\" with a list of attributes (name, breed, age) and methods (bark, sit, fetch)</li> <li>Right side: Three \"cookie\" shapes, each labeled as a Dog object with different values:</li> <li>Dog 1: name=\"Buddy\", breed=\"Golden Retriever\", age=3</li> <li>Dog 2: name=\"Luna\", breed=\"Poodle\", age=5</li> <li>Dog 3: name=\"Max\", breed=\"Beagle\", age=1</li> <li>Arrows from the cookie cutter to each cookie labeled \"instantiation\"</li> </ul> <p>Interactive elements:</p> <ul> <li>Hover over the class to highlight all shared structure</li> <li>Hover over any object to see its unique attribute values</li> <li>Click a \"Create New Dog\" button to animate a new cookie being \"pressed out\" with random attributes</li> </ul> <p>Color scheme: Class in blue, objects in warm cookie-brown tones with colored sprinkle accents Responsive: Layout adjusts from horizontal (wide screens) to vertical (narrow screens)</p> <p>Instructional Rationale: The concrete visual analogy of cookie cutter to cookies makes the abstract class-vs-object distinction tangible. Interactive creation of new objects reinforces that many instances come from one class.</p>"},{"location":"chapters/12-classes-and-objects/#creating-objects-class-instantiation","title":"Creating Objects: Class Instantiation","text":"<p>Now that we have a class, let's make some objects. Class instantiation is the process of creating an actual object from a class. You \"call\" the class like a function:</p> <pre><code>class Dog:\n    pass\n\nmy_dog = Dog()\nyour_dog = Dog()\n</code></pre> <p>Each call to <code>Dog()</code> creates a brand-new, independent object \u2014 a specific instance of the <code>Dog</code> class. Right now our dogs are pretty boring (they have no data), but we've proven the concept: one class, multiple objects.</p> <p>Think of it this way: <code>Dog</code> is the blueprint, <code>my_dog</code> and <code>your_dog</code> are two separate houses built from that blueprint. They share the same layout, but they're different houses on different streets.</p>"},{"location":"chapters/12-classes-and-objects/#the-constructor-the-__init__-method","title":"The Constructor: The <code>__init__</code> Method","text":"<p>When you buy a new phone, it doesn't come blank \u2014 it has some starting setup. A constructor does the same thing for objects. It's a special method that runs automatically every time you create a new object, setting up its initial data.</p> <p>In Python, the constructor is the <code>__init__</code> method (that's two underscores on each side of \"init,\" short for \"initialize\"). Let's give our dogs some personality:</p> <pre><code>class Dog:\n    def __init__(self, name, breed, age):\n        self.name = name\n        self.breed = breed\n        self.age = age\n</code></pre> <p>Now when we create a Dog, we pass in the starting values:</p> <pre><code>buddy = Dog(\"Buddy\", \"Golden Retriever\", 3)\nluna = Dog(\"Luna\", \"Poodle\", 5)\n</code></pre> <p>Each dog gets its own <code>name</code>, <code>breed</code>, and <code>age</code>. These are stored right inside the object, and we can access them anytime:</p> <pre><code>print(buddy.name)   # Output: Buddy\nprint(luna.breed)    # Output: Poodle\nprint(luna.age)      # Output: 5\n</code></pre> <p>Monty says: You've got this!</p> <p> You might be wondering about those double underscores around <code>__init__</code>. In Python, methods with double underscores on both sides are called \"dunder\" methods (short for \"double underscore\"). They have special powers \u2014 Python calls them automatically at certain moments. <code>__init__</code> is called when an object is born. You'll meet more dunder methods later in this chapter!</p>"},{"location":"chapters/12-classes-and-objects/#understanding-the-self-parameter","title":"Understanding the <code>self</code> Parameter","text":"<p>You probably noticed that weird first parameter in the <code>__init__</code> method \u2014 <code>self</code>. What is that? The <code>self</code> parameter is how an object refers to itself. When you write <code>self.name = name</code>, you're saying \"store this value inside me.\"</p> <p>Here's the key insight: when you call <code>Dog(\"Buddy\", \"Golden Retriever\", 3)</code>, Python automatically passes the new object as the first argument. You never type <code>self</code> in the function call \u2014 Python handles it behind the scenes. You only see <code>self</code> in the method definition.</p> <p>Think of <code>self</code> like the word \"my\" in everyday speech. When Buddy the dog says \"my name is Buddy,\" the word \"my\" refers to Buddy himself. When Luna says \"my name is Luna,\" the same word \"my\" refers to Luna. <code>self</code> works the same way \u2014 it points to whichever object is running the code.</p> <pre><code># You write this:\nbuddy = Dog(\"Buddy\", \"Golden Retriever\", 3)\n\n# Python sees it as:\nDog.__init__(buddy, \"Buddy\", \"Golden Retriever\", 3)\n#             ^^^^^ this becomes \"self\"\n</code></pre>"},{"location":"chapters/12-classes-and-objects/#instance-attributes-vs-class-attributes","title":"Instance Attributes vs. Class Attributes","text":"<p>The <code>name</code>, <code>breed</code>, and <code>age</code> that we set in <code>__init__</code> are called instance attributes \u2014 they belong to one specific object. Buddy's name is \"Buddy\" and Luna's name is \"Luna.\" Each instance carries its own copy.</p> <p>But sometimes you want a piece of data shared by all objects of a class. That's a class attribute. It lives on the class itself, not on any individual object:</p> <pre><code>class Dog:\n    species = \"Canis familiaris\"  # Class attribute \u2014 shared by ALL dogs\n\n    def __init__(self, name, breed, age):\n        self.name = name    # Instance attribute \u2014 unique to each dog\n        self.breed = breed   # Instance attribute\n        self.age = age       # Instance attribute\n</code></pre> <p>Every Dog object can access <code>species</code>, but it's defined once and shared:</p> <pre><code>buddy = Dog(\"Buddy\", \"Golden Retriever\", 3)\nluna = Dog(\"Luna\", \"Poodle\", 5)\n\nprint(buddy.species)  # Output: Canis familiaris\nprint(luna.species)    # Output: Canis familiaris\nprint(buddy.name)     # Output: Buddy\nprint(luna.name)      # Output: Luna\n</code></pre> <p>Here's a handy comparison:</p> Feature Instance Attribute Class Attribute Defined in <code>__init__</code> using <code>self.</code> Directly inside the class body Belongs to One specific object The class itself (shared by all) Can differ between objects? Yes No (unless overridden) Example <code>self.name = \"Buddy\"</code> <code>species = \"Canis familiaris\"</code>"},{"location":"chapters/12-classes-and-objects/#diagram-instance-vs-class-attributes","title":"Diagram: Instance vs. Class Attributes","text":"Instance vs. Class Attributes Memory Diagram <p>Type: diagram sim-id: instance-vs-class-attributes Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: differentiate, explain</p> <p>Learning Objective: Students will be able to differentiate between instance attributes (unique per object) and class attributes (shared across all objects) by viewing a memory diagram.</p> <p>Purpose: An interactive memory model showing a Dog class with a shared class attribute (<code>species</code>) and multiple Dog objects, each with unique instance attributes (<code>name</code>, <code>breed</code>, <code>age</code>). Arrows show that class attributes are referenced from the class, not duplicated per object.</p> <p>Layout:</p> <ul> <li>Top: A blue box representing the <code>Dog</code> class, showing <code>species = \"Canis familiaris\"</code></li> <li>Below: Three green boxes representing Dog instances (buddy, luna, max)</li> <li>Each instance box shows its own name, breed, age values</li> <li>Dashed arrows from each instance to the class attribute box for <code>species</code></li> <li>Solid borders around instance attributes to show they are \"owned\" by the object</li> </ul> <p>Interactive elements:</p> <ul> <li>Hover over <code>species</code> in the class box to highlight all dashed arrows connecting to instances</li> <li>Hover over any instance attribute to see it highlighted only on that one object</li> <li>Click \"Add Dog\" to create a new instance box with random attributes and a new dashed arrow</li> <li>Toggle \"Show Memory Addresses\" to reveal that all instances reference the same class attribute location</li> </ul> <p>Color scheme: Class box in blue, instance boxes in green, shared attribute arrows in orange dashed lines Responsive: Boxes reflow vertically on narrow screens</p> <p>Instructional Rationale: Memory diagrams make the invisible visible. Seeing that class attributes live in one place (the class) while instance attributes are stored per object reinforces the conceptual difference. Interactive arrows clarify the reference relationship.</p>"},{"location":"chapters/12-classes-and-objects/#writing-methods","title":"Writing Methods","text":"<p>Data is only half the story. Objects don't just have information \u2014 they do things. A method is a function that lives inside a class and describes the behavior of an object.</p>"},{"location":"chapters/12-classes-and-objects/#instance-methods","title":"Instance Methods","text":"<p>An instance method is the most common type of method. It operates on a specific object and has access to that object's data through <code>self</code>:</p> <pre><code>class Dog:\n    species = \"Canis familiaris\"\n\n    def __init__(self, name, breed, age):\n        self.name = name\n        self.breed = breed\n        self.age = age\n\n    def bark(self):\n        return f\"{self.name} says: Woof!\"\n\n    def describe(self):\n        return f\"{self.name} is a {self.age}-year-old {self.breed}.\"\n\n    def birthday(self):\n        self.age += 1\n        return f\"Happy birthday, {self.name}! You're now {self.age}.\"\n</code></pre> <p>Now our dogs can do things:</p> <pre><code>buddy = Dog(\"Buddy\", \"Golden Retriever\", 3)\n\nprint(buddy.bark())       # Output: Buddy says: Woof!\nprint(buddy.describe())   # Output: Buddy is a 3-year-old Golden Retriever.\nprint(buddy.birthday())   # Output: Happy birthday, Buddy! You're now 4.\nprint(buddy.describe())   # Output: Buddy is a 4-year-old Golden Retriever.\n</code></pre> <p>Notice that <code>birthday()</code> actually changes the object's data \u2014 it increments <code>self.age</code>. Methods can both read and modify an object's attributes. That's the beauty of bundling data and behavior together.</p> <p>Monty says: Let's debug this together!</p> <p> Every instance method must take <code>self</code> as its first parameter. If you forget it, Python will throw an error like <code>TypeError: bark() takes 0 positional arguments but 1 was given</code>. That error message is confusing until you realize Python is secretly passing the object as the first argument. Always include <code>self</code>!</p>"},{"location":"chapters/12-classes-and-objects/#special-methods-__str__-and-__repr__","title":"Special Methods: <code>__str__</code> and <code>__repr__</code>","text":"<p>What happens when you try to print an object?</p> <pre><code>buddy = Dog(\"Buddy\", \"Golden Retriever\", 3)\nprint(buddy)\n# Output: &lt;__main__.Dog object at 0x7f8b8c0d2e90&gt;\n</code></pre> <p>Yikes. That memory address isn't helpful at all. Python doesn't magically know how to display your custom object \u2014 you need to tell it. That's where the <code>__str__</code> method comes in.</p>"},{"location":"chapters/12-classes-and-objects/#the-__str__-method","title":"The <code>__str__</code> Method","text":"<p>The <code>__str__</code> method defines the \"user-friendly\" string version of your object. It's what Python uses when you call <code>print()</code> or <code>str()</code> on your object:</p> <pre><code>class Dog:\n    def __init__(self, name, breed, age):\n        self.name = name\n        self.breed = breed\n        self.age = age\n\n    def __str__(self):\n        return f\"{self.name} the {self.breed}, age {self.age}\"\n</code></pre> <p>Now printing works beautifully:</p> <pre><code>buddy = Dog(\"Buddy\", \"Golden Retriever\", 3)\nprint(buddy)  # Output: Buddy the Golden Retriever, age 3\n</code></pre>"},{"location":"chapters/12-classes-and-objects/#the-__repr__-method","title":"The <code>__repr__</code> Method","text":"<p>The <code>__repr__</code> method is similar, but it's meant for developers, not end users. It should return a string that could recreate the object. Think of <code>__str__</code> as the \"pretty\" version and <code>__repr__</code> as the \"technical\" version:</p> <pre><code>class Dog:\n    def __init__(self, name, breed, age):\n        self.name = name\n        self.breed = breed\n        self.age = age\n\n    def __str__(self):\n        return f\"{self.name} the {self.breed}, age {self.age}\"\n\n    def __repr__(self):\n        return f\"Dog('{self.name}', '{self.breed}', {self.age})\"\n</code></pre> <p>Here's the difference in action:</p> <pre><code>buddy = Dog(\"Buddy\", \"Golden Retriever\", 3)\n\nprint(str(buddy))    # Output: Buddy the Golden Retriever, age 3\nprint(repr(buddy))   # Output: Dog('Buddy', 'Golden Retriever', 3)\n</code></pre> <p>When you type an object's name in the Python interactive shell (without <code>print</code>), Python uses <code>__repr__</code>. When you use <code>print()</code>, Python uses <code>__str__</code>. If you only define one, define <code>__repr__</code> \u2014 Python will fall back to it when <code>__str__</code> isn't available.</p> Method Audience Called by Purpose <code>__str__</code> End users <code>print()</code>, <code>str()</code> Readable, friendly display <code>__repr__</code> Developers Interactive shell, <code>repr()</code> Precise, recreatable representation"},{"location":"chapters/12-classes-and-objects/#diagram-dog-class-complete-structure","title":"Diagram: Dog Class Complete Structure","text":"Dog Class UML-Style Diagram <p>Type: diagram sim-id: dog-class-uml-diagram Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: describe, summarize</p> <p>Learning Objective: Students will be able to read a class diagram showing the structure of a Python class, identifying its attributes and methods.</p> <p>Purpose: A UML-style class diagram for the Dog class showing the class name, attributes (instance and class), and methods in a clear three-section box format.</p> <p>Layout:</p> <ul> <li>A single box divided into three horizontal sections:</li> <li>Top section (header): Class name \"Dog\"</li> <li>Middle section: Attributes listed with types<ul> <li><code>species: str</code> (labeled \"class attribute\")</li> <li><code>name: str</code> (labeled \"instance\")</li> <li><code>breed: str</code> (labeled \"instance\")</li> <li><code>age: int</code> (labeled \"instance\")</li> </ul> </li> <li>Bottom section: Methods<ul> <li><code>__init__(name, breed, age)</code></li> <li><code>bark() -&gt; str</code></li> <li><code>describe() -&gt; str</code></li> <li><code>birthday() -&gt; str</code></li> <li><code>__str__() -&gt; str</code></li> <li><code>__repr__() -&gt; str</code></li> </ul> </li> </ul> <p>Interactive elements:</p> <ul> <li>Hover over any attribute to see its description and whether it is instance or class level</li> <li>Hover over any method to see a brief description of what it does</li> <li>Click \"Show Code\" to toggle a code panel beside the diagram showing the full Python class definition</li> </ul> <p>Color scheme: Header in dark blue, attributes in light blue, methods in light green Responsive: Box scales with window width; minimum readable size maintained</p> <p>Instructional Rationale: Class diagrams are a standard tool in software design. Introducing students to this visual format early helps them plan classes before coding and read documentation that uses UML notation.</p>"},{"location":"chapters/12-classes-and-objects/#a-complete-example-building-it-up","title":"A Complete Example: Building It Up","text":"<p>Let's see our full <code>Dog</code> class with everything we've learned so far in one place:</p> <pre><code>class Dog:\n    # Class attribute \u2014 shared by all dogs\n    species = \"Canis familiaris\"\n\n    def __init__(self, name, breed, age):\n        \"\"\"Constructor: initialize a new Dog.\"\"\"\n        self.name = name\n        self.breed = breed\n        self.age = age\n\n    def bark(self):\n        \"\"\"Make the dog bark.\"\"\"\n        return f\"{self.name} says: Woof!\"\n\n    def describe(self):\n        \"\"\"Return a description of the dog.\"\"\"\n        return f\"{self.name} is a {self.age}-year-old {self.breed}.\"\n\n    def birthday(self):\n        \"\"\"Celebrate the dog's birthday.\"\"\"\n        self.age += 1\n        return f\"Happy birthday, {self.name}! You're now {self.age}.\"\n\n    def __str__(self):\n        \"\"\"User-friendly string representation.\"\"\"\n        return f\"{self.name} the {self.breed}, age {self.age}\"\n\n    def __repr__(self):\n        \"\"\"Developer-friendly string representation.\"\"\"\n        return f\"Dog('{self.name}', '{self.breed}', {self.age})\"\n</code></pre> <p>Let's take it for a spin:</p> <pre><code># Create two dog objects\nbuddy = Dog(\"Buddy\", \"Golden Retriever\", 3)\nluna = Dog(\"Luna\", \"Poodle\", 5)\n\n# Use instance methods\nprint(buddy.bark())       # Buddy says: Woof!\nprint(luna.describe())    # Luna is a 5-year-old Poodle.\n\n# Access class attribute\nprint(Dog.species)        # Canis familiaris\nprint(buddy.species)     # Canis familiaris (same thing)\n\n# Use special methods\nprint(buddy)             # Buddy the Golden Retriever, age 3\nprint(repr(luna))        # Dog('Luna', 'Poodle', 5)\n\n# Modify an object\nbuddy.birthday()\nprint(buddy.describe())  # Buddy is a 4-year-old Golden Retriever.\n</code></pre> <p>This is the power of OOP: all of Buddy's data and behavior live together in one tidy package. You don't need to track separate lists of names, breeds, and ages. Everything is organized and self-contained.</p>"},{"location":"chapters/12-classes-and-objects/#encapsulation-protecting-your-data","title":"Encapsulation: Protecting Your Data","text":"<p>Here's a question: what stops someone from doing this?</p> <pre><code>buddy = Dog(\"Buddy\", \"Golden Retriever\", 3)\nbuddy.age = -5  # Uh oh... a dog with negative age?\n</code></pre> <p>Nothing! Right now, anyone can reach in and set <code>buddy.age</code> to any value, even one that makes no sense. That's a problem if you're building real software.</p> <p>Encapsulation is the OOP principle of hiding an object's internal data and controlling access to it. Instead of letting the outside world poke around directly, you provide controlled doors (methods) that validate changes before allowing them. Think of it like a bank vault \u2014 you don't let customers walk in and grab cash. They go through a teller who checks their identity and balance first.</p>"},{"location":"chapters/12-classes-and-objects/#private-attributes","title":"Private Attributes","text":"<p>In Python, you signal that an attribute is \"private\" \u2014 meaning it shouldn't be accessed directly from outside the class \u2014 by prefixing its name with an underscore. These are called private attributes:</p> <pre><code>class Dog:\n    def __init__(self, name, breed, age):\n        self.name = name\n        self.breed = breed\n        self._age = age  # Private attribute (single underscore)\n</code></pre> <p>The single underscore <code>_age</code> is a convention, not a hard rule. Python won't actually prevent someone from accessing <code>buddy._age</code>, but the underscore is a clear signal: \"Hey, this is internal. Don't touch it directly.\"</p> <p>For stronger privacy, you can use a double underscore, which triggers name mangling \u2014 Python renames the attribute internally to make it harder to access from outside:</p> <pre><code>class Dog:\n    def __init__(self, name, breed, age):\n        self.name = name\n        self.breed = breed\n        self.__age = age  # \"Mangled\" private attribute\n\nbuddy = Dog(\"Buddy\", \"Golden Retriever\", 3)\n# print(buddy.__age)  # AttributeError! Can't access it directly.\n</code></pre> <p>Monty says: Watch out, coders!</p> <p> Python's privacy system is based on trust, not enforcement. The single underscore convention (<code>_age</code>) is like a \"Do Not Disturb\" sign on a hotel door \u2014 polite but not a physical barrier. The double underscore (<code>__age</code>) is more like a locked door, but a determined person can still pick the lock. In Python culture, we follow the conventions because we're good citizens, not because we're forced to.</p>"},{"location":"chapters/12-classes-and-objects/#getter-methods","title":"Getter Methods","text":"<p>If attributes are private, how do we read them? We write getter methods \u2014 methods that return the value of a private attribute:</p> <pre><code>class Dog:\n    def __init__(self, name, breed, age):\n        self.name = name\n        self.breed = breed\n        self._age = age\n\n    def get_age(self):\n        \"\"\"Getter: return the dog's age.\"\"\"\n        return self._age\n</code></pre> <p>Now outside code reads the age through the getter:</p> <pre><code>buddy = Dog(\"Buddy\", \"Golden Retriever\", 3)\nprint(buddy.get_age())  # Output: 3\n</code></pre>"},{"location":"chapters/12-classes-and-objects/#setter-methods","title":"Setter Methods","text":"<p>To change a private attribute safely, we write setter methods \u2014 methods that validate the new value before applying it:</p> <pre><code>class Dog:\n    def __init__(self, name, breed, age):\n        self.name = name\n        self.breed = breed\n        self._age = age\n\n    def get_age(self):\n        \"\"\"Getter: return the dog's age.\"\"\"\n        return self._age\n\n    def set_age(self, new_age):\n        \"\"\"Setter: update the dog's age with validation.\"\"\"\n        if new_age &lt; 0:\n            print(\"Error: Age can't be negative!\")\n        elif new_age &gt; 30:\n            print(\"Error: That's too old for a dog!\")\n        else:\n            self._age = new_age\n</code></pre> <p>Now we get protection:</p> <pre><code>buddy = Dog(\"Buddy\", \"Golden Retriever\", 3)\n\nbuddy.set_age(4)    # Works fine\nprint(buddy.get_age())  # Output: 4\n\nbuddy.set_age(-5)   # Output: Error: Age can't be negative!\nprint(buddy.get_age())  # Output: 4 (unchanged)\n</code></pre> <p>The setter acts as a gatekeeper, only allowing valid changes through.</p>"},{"location":"chapters/12-classes-and-objects/#diagram-encapsulation-bank-vault-analogy","title":"Diagram: Encapsulation Bank Vault Analogy","text":"Encapsulation Bank Vault Analogy <p>Type: infographic sim-id: encapsulation-bank-vault Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: explain, illustrate</p> <p>Learning Objective: Students will be able to explain how encapsulation protects an object's internal data by restricting direct access and using getter/setter methods as controlled access points.</p> <p>Purpose: A visual analogy showing a bank vault (the object) with a teller window (getter/setter methods) as the only way to interact with the money inside (private attributes). Direct access to the vault is blocked.</p> <p>Layout:</p> <ul> <li>Center: A large \"vault\" box representing the Dog object, with private attributes (<code>_age</code>, <code>_breed</code>) shown inside</li> <li>Front of vault: Two windows labeled \"Getter\" and \"Setter\"</li> <li>Outside: A figure representing \"outside code\" trying to access the vault</li> <li>Path 1 (green, allowed): Outside code -&gt; Getter window -&gt; receives age value</li> <li>Path 2 (green, allowed): Outside code -&gt; Setter window -&gt; value validated -&gt; stored in vault</li> <li>Path 3 (red, blocked): Outside code -&gt; tries to reach directly into vault -&gt; big red X</li> </ul> <p>Interactive elements:</p> <ul> <li>Click \"Try Direct Access\" to animate the blocked attempt with a red flash and error message</li> <li>Click \"Use Getter\" to animate a successful read through the getter window</li> <li>Click \"Use Setter (valid)\" to animate a successful write with a green checkmark</li> <li>Click \"Use Setter (invalid)\" to animate a blocked write with a validation error</li> </ul> <p>Color scheme: Vault in dark gray, getter window in green, setter window in blue, blocked paths in red Responsive: Single-column layout on narrow screens</p> <p>Instructional Rationale: The bank vault analogy makes the abstract concept of encapsulation concrete. Animating both allowed and blocked access paths helps students understand why getters and setters exist and how they protect data integrity.</p>"},{"location":"chapters/12-classes-and-objects/#the-property-decorator-the-best-of-both-worlds","title":"The Property Decorator: The Best of Both Worlds","text":"<p>Getters and setters work, but calling <code>buddy.get_age()</code> and <code>buddy.set_age(4)</code> feels clunky compared to the clean <code>buddy.age</code> syntax. Wouldn't it be great if you could write <code>buddy.age</code> but still get the protection of a setter?</p> <p>That's exactly what the property decorator does. It lets you define getter and setter methods that look like regular attribute access. It's the best of both worlds \u2014 clean syntax and data validation:</p> <pre><code>class Dog:\n    def __init__(self, name, breed, age):\n        self.name = name\n        self.breed = breed\n        self._age = age  # Store privately\n\n    @property\n    def age(self):\n        \"\"\"Getter using @property.\"\"\"\n        return self._age\n\n    @age.setter\n    def age(self, new_age):\n        \"\"\"Setter with validation.\"\"\"\n        if new_age &lt; 0:\n            raise ValueError(\"Age can't be negative!\")\n        elif new_age &gt; 30:\n            raise ValueError(\"That's too old for a dog!\")\n        self._age = new_age\n</code></pre> <p>Now you get clean, natural syntax with hidden protection:</p> <pre><code>buddy = Dog(\"Buddy\", \"Golden Retriever\", 3)\n\n# Reads like a regular attribute (but calls the getter behind the scenes)\nprint(buddy.age)    # Output: 3\n\n# Writes like a regular attribute (but calls the setter behind the scenes)\nbuddy.age = 4\nprint(buddy.age)    # Output: 4\n\n# Validation still works!\nbuddy.age = -5      # Raises ValueError: Age can't be negative!\n</code></pre> <p>The <code>@property</code> decorator is a favorite tool among Python developers. It keeps your code clean on the outside while maintaining all the safety checks on the inside. You'll see it in professional Python code everywhere.</p> <p>Here's a summary of the three approaches to attribute access:</p> Approach Read Write Validation? Pythonic? Public attribute <code>buddy.age</code> <code>buddy.age = 4</code> No Simple but risky Getter/setter methods <code>buddy.get_age()</code> <code>buddy.set_age(4)</code> Yes Works but verbose Property decorator <code>buddy.age</code> <code>buddy.age = 4</code> Yes Clean and safe"},{"location":"chapters/12-classes-and-objects/#class-methods","title":"Class Methods","text":"<p>So far, every method we've written operates on an individual object \u2014 it uses <code>self</code> to access that specific dog's data. But sometimes you want a method that belongs to the class itself, not to any particular object. That's a class method.</p> <p>A class method is created using the <code>@classmethod</code> decorator, and its first parameter is <code>cls</code> (the class) instead of <code>self</code> (the object):</p> <pre><code>class Dog:\n    species = \"Canis familiaris\"\n    _dog_count = 0  # Track how many dogs have been created\n\n    def __init__(self, name, breed, age):\n        self.name = name\n        self.breed = breed\n        self._age = age\n        Dog._dog_count += 1  # Increment the counter\n\n    @classmethod\n    def get_dog_count(cls):\n        \"\"\"Return the total number of Dog objects created.\"\"\"\n        return cls._dog_count\n\n    @classmethod\n    def from_string(cls, dog_string):\n        \"\"\"Create a Dog from a string like 'Buddy-Golden Retriever-3'.\"\"\"\n        name, breed, age = dog_string.split(\"-\")\n        return cls(name, breed, int(age))\n</code></pre> <p>Class methods are useful for two main things:</p> <ol> <li>Factory methods \u2014 Alternate ways to create objects (like <code>from_string</code> above)</li> <li>Class-level operations \u2014 Working with class attributes rather than instance attributes</li> </ol> <pre><code># Regular creation\nbuddy = Dog(\"Buddy\", \"Golden Retriever\", 3)\nluna = Dog(\"Luna\", \"Poodle\", 5)\n\n# Factory method \u2014 creates a Dog from a string\nmax_dog = Dog.from_string(\"Max-Beagle-1\")\nprint(max_dog.name)  # Output: Max\n\n# Class method \u2014 tracks all dogs\nprint(Dog.get_dog_count())  # Output: 3\n</code></pre> <p>Notice that you call class methods on the class itself (<code>Dog.get_dog_count()</code>) rather than on an object. They don't need a specific instance to do their work.</p> <p>Monty says: Let's debug this together!</p> <p> If all these decorators and special methods feel like a lot, take a breath. You don't need to memorize every detail right now. The most important things are: <code>__init__</code> sets up your object, <code>self</code> means \"me,\" and methods define what your object can do. Start with those three ideas, and everything else will click as you practice!</p>"},{"location":"chapters/12-classes-and-objects/#bringing-it-all-together-the-complete-dog-class","title":"Bringing It All Together: The Complete Dog Class","text":"<p>Here's our finished <code>Dog</code> class with everything from this chapter \u2014 class attributes, instance attributes, instance methods, special methods, encapsulation with the property decorator, and a class method:</p> <pre><code>class Dog:\n    \"\"\"A class representing a dog.\"\"\"\n\n    species = \"Canis familiaris\"  # Class attribute\n    _dog_count = 0               # Class attribute (private)\n\n    def __init__(self, name, breed, age):\n        \"\"\"Constructor: initialize a new Dog.\"\"\"\n        self.name = name\n        self.breed = breed\n        self._age = age          # Private instance attribute\n        Dog._dog_count += 1\n\n    @property\n    def age(self):\n        \"\"\"Getter: return the dog's age.\"\"\"\n        return self._age\n\n    @age.setter\n    def age(self, new_age):\n        \"\"\"Setter: update age with validation.\"\"\"\n        if not isinstance(new_age, int) or new_age &lt; 0:\n            raise ValueError(\"Age must be a non-negative integer.\")\n        if new_age &gt; 30:\n            raise ValueError(\"Age seems unrealistic for a dog.\")\n        self._age = new_age\n\n    def bark(self):\n        \"\"\"Instance method: make the dog bark.\"\"\"\n        return f\"{self.name} says: Woof!\"\n\n    def describe(self):\n        \"\"\"Instance method: describe the dog.\"\"\"\n        return f\"{self.name} is a {self._age}-year-old {self.breed}.\"\n\n    def birthday(self):\n        \"\"\"Instance method: celebrate a birthday.\"\"\"\n        self._age += 1\n        return f\"Happy birthday, {self.name}! You're now {self._age}.\"\n\n    def __str__(self):\n        \"\"\"User-friendly string representation.\"\"\"\n        return f\"{self.name} the {self.breed}, age {self._age}\"\n\n    def __repr__(self):\n        \"\"\"Developer-friendly string representation.\"\"\"\n        return f\"Dog('{self.name}', '{self.breed}', {self._age})\"\n\n    @classmethod\n    def get_dog_count(cls):\n        \"\"\"Class method: return total number of dogs created.\"\"\"\n        return cls._dog_count\n\n    @classmethod\n    def from_string(cls, dog_string):\n        \"\"\"Class method (factory): create a Dog from a formatted string.\"\"\"\n        name, breed, age = dog_string.split(\"-\")\n        return cls(name, breed, int(age))\n</code></pre> <p>Let's exercise every feature:</p> <pre><code># Create dogs using the constructor\nbuddy = Dog(\"Buddy\", \"Golden Retriever\", 3)\nluna = Dog(\"Luna\", \"Poodle\", 5)\n\n# Create a dog using the factory class method\nmax_dog = Dog.from_string(\"Max-Beagle-1\")\n\n# Instance methods\nprint(buddy.bark())          # Buddy says: Woof!\nprint(luna.describe())       # Luna is a 5-year-old Poodle.\nprint(max_dog.birthday())   # Happy birthday, Max! You're now 2.\n\n# Special methods\nprint(buddy)                 # Buddy the Golden Retriever, age 3\nprint(repr(luna))           # Dog('Luna', 'Poodle', 5)\n\n# Property with validation\nbuddy.age = 4               # Works fine\n# buddy.age = -1            # Raises ValueError!\n\n# Class attribute and class method\nprint(Dog.species)           # Canis familiaris\nprint(Dog.get_dog_count())  # 3\n</code></pre>"},{"location":"chapters/12-classes-and-objects/#diagram-object-interaction-playground","title":"Diagram: Object Interaction Playground","text":"Dog Class Interactive Playground MicroSim <p>Type: microsim sim-id: dog-class-playground Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: construct, demonstrate</p> <p>Learning Objective: Students will be able to create Dog objects, call methods, and observe results in an interactive playground that demonstrates class instantiation, method calls, and attribute access.</p> <p>Purpose: An interactive code playground where students can create Dog objects by filling in attribute fields, then click buttons to call various methods and see the output \u2014 without needing to switch to a separate Python environment.</p> <p>Layout:</p> <ul> <li>Top section: \"Create a Dog\" form with input fields for name, breed, and age, plus a \"Create\" button</li> <li>Middle section: A visual \"kennel\" area showing all created Dog objects as card-style boxes</li> <li>Each card shows the dog's name, breed, age, and buttons for bark(), describe(), birthday()</li> <li>Bottom section: Output console showing the results of method calls</li> <li>A \"Dog Count\" badge in the corner showing the class method result</li> </ul> <p>Interactive elements:</p> <ul> <li>Fill in name/breed/age and click \"Create\" to add a new Dog card to the kennel</li> <li>Click \"Bark\" on any dog card to see the bark() output</li> <li>Click \"Birthday\" to increment that dog's age (visually updates the card)</li> <li>Click \"Describe\" to see the describe() output</li> <li>Click \"Print\" to see the str output</li> <li>Click \"Repr\" to see the repr output</li> <li>\"Dog Count\" badge auto-updates when new dogs are created</li> </ul> <p>Visual style: Colorful dog cards with breed-themed icons, console area with monospace font Color scheme: Cards in warm tones, console in dark theme Responsive: Cards wrap to multiple rows on narrow screens</p> <p>Instructional Rationale: A no-code playground lets students experiment with OOP concepts interactively. Creating objects and calling methods provides immediate visual feedback, reinforcing the relationship between classes, objects, attributes, and methods without the overhead of setting up a development environment.</p>"},{"location":"chapters/12-classes-and-objects/#why-oop-matters","title":"Why OOP Matters","text":"<p>You might be thinking: \"This is cool, but why go through all this trouble? I could just use dictionaries and functions.\" That's fair! For small programs, you absolutely could. But OOP really shines as programs grow larger:</p> <ul> <li>Organization: All related data and behavior live in one place. A <code>Dog</code> class bundles everything about dogs together.</li> <li>Reusability: Once you've written a <code>Dog</code> class, you can create as many dogs as you want without rewriting anything.</li> <li>Encapsulation: You can protect your data from accidental corruption and provide clean interfaces for interacting with objects.</li> <li>Real-world modeling: OOP lets you represent real-world things (students, bank accounts, game characters) in a natural way.</li> <li>Teamwork: When building software with a team, OOP makes it easier to divide work. One person builds the <code>Dog</code> class, another builds the <code>Cat</code> class, and they connect through well-defined methods.</li> </ul> <p>In the next chapter, you'll learn about inheritance \u2014 creating new classes based on existing ones. That's where OOP gets really powerful.</p>"},{"location":"chapters/12-classes-and-objects/#diagram-oop-benefits-concept-map","title":"Diagram: OOP Benefits Concept Map","text":"OOP Benefits Concept Map <p>Type: infographic sim-id: oop-benefits-concept-map Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: summarize, explain</p> <p>Learning Objective: Students will be able to summarize the key benefits of OOP (organization, reusability, encapsulation, real-world modeling, teamwork) and explain why OOP is preferred for larger programs.</p> <p>Purpose: A concept map with \"OOP\" at the center and five benefit nodes radiating outward, each with a brief description and a concrete example from the Dog class.</p> <p>Layout:</p> <ul> <li>Central node: \"Object-Oriented Programming\" in a large circle</li> <li>Five satellite nodes arranged in a star pattern:</li> <li>Organization: \"All Dog data + behavior in one class\"</li> <li>Reusability: \"Create unlimited Dog objects from one class\"</li> <li>Encapsulation: \"Property decorators protect age from invalid values\"</li> <li>Real-world modeling: \"Dogs in code match dogs in real life\"</li> <li>Teamwork: \"Each teammate builds a different class\"</li> <li>Connecting lines from center to each node</li> </ul> <p>Interactive elements:</p> <ul> <li>Hover over any benefit node to see an expanded explanation and code snippet</li> <li>Click a benefit node to highlight the relevant parts of a miniature Dog class code block shown at the bottom</li> </ul> <p>Color scheme: Center in green, benefit nodes in five distinct colors Responsive: Star layout collapses to vertical list on narrow screens</p> <p>Instructional Rationale: Concept maps help students see the big picture and connect individual concepts to overarching themes. Linking each benefit to a concrete code example from the chapter grounds abstract principles in familiar code.</p> <p>Monty says: You've got this!</p> <p> Amazing work, coder! You just learned one of the most important concepts in all of programming. You can now define classes, create objects, write constructors and methods, control access to data, and use Python's property decorator like a pro. You're officially thinking in objects. Next stop: inheritance and polymorphism!</p>"},{"location":"chapters/12-classes-and-objects/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Object-Oriented Programming (OOP) bundles related data (attributes) and behavior (methods) into objects for cleaner, more organized code.</li> <li>A class is a blueprint or template. An object is a specific instance created from that class.</li> <li>The <code>__init__</code> method (constructor) runs automatically when you create an object, setting up its initial attributes.</li> <li><code>self</code> is how an object refers to itself inside its methods.</li> <li>Instance attributes belong to individual objects. Class attributes are shared across all objects of a class.</li> <li>Instance methods operate on a specific object's data. Class methods operate on the class itself.</li> <li><code>__str__</code> gives you a user-friendly string. <code>__repr__</code> gives you a developer-friendly, recreatable string.</li> <li>Encapsulation protects data by making attributes private and using getter/setter methods or the property decorator to control access.</li> <li>The property decorator (<code>@property</code>) gives you clean attribute-style syntax (<code>buddy.age</code>) with hidden validation logic.</li> <li>Class methods (<code>@classmethod</code>) belong to the class rather than any instance, useful for factory methods and class-level operations.</li> </ul> Check Your Understanding: What is the difference between a class and an object? <p>A class is a blueprint or template that defines the structure (attributes) and behavior (methods) for a type of thing. An object is a specific instance created from that class. For example, <code>Dog</code> is a class, and <code>buddy = Dog(\"Buddy\", \"Golden Retriever\", 3)</code> creates an object. You can think of a class as a cookie cutter and an object as a cookie \u2014 many objects can come from one class, each with its own data.</p> Check Your Understanding: Why do we use encapsulation and the property decorator? <p>Encapsulation protects an object's internal data from being changed to invalid values. Without it, anyone could set <code>buddy.age = -5</code>, which doesn't make sense. The property decorator lets you add validation (like checking that age is non-negative) while keeping the syntax clean \u2014 you still write <code>buddy.age = 4</code> instead of <code>buddy.set_age(4)</code>. It's the best of both worlds: safety and readability.</p> Check Your Understanding: What is the difference between <code>__str__</code> and <code>__repr__</code>? <p>Both return string representations of an object, but for different audiences. <code>__str__</code> is for end users \u2014 it returns a readable, friendly string and is called by <code>print()</code>. <code>__repr__</code> is for developers \u2014 it returns a precise string that ideally could recreate the object, and is called in the interactive shell. For example: <code>str(buddy)</code> might return <code>\"Buddy the Golden Retriever, age 3\"</code> while <code>repr(buddy)</code> returns <code>\"Dog('Buddy', 'Golden Retriever', 3)\"</code>.</p>"},{"location":"chapters/13-inheritance-and-polymorphism/","title":"Inheritance and Polymorphism","text":""},{"location":"chapters/13-inheritance-and-polymorphism/#inheritance-and-polymorphism","title":"Inheritance and Polymorphism","text":""},{"location":"chapters/13-inheritance-and-polymorphism/#summary","title":"Summary","text":"<p>This chapter extends object-oriented programming with inheritance and polymorphism. Students will learn to create class hierarchies with parent and child classes, use the super() function, override methods, and understand polymorphism and duck typing. The chapter also covers abstract classes, multiple inheritance, operator overloading through dunder methods, iterable and iterator protocols, and UML class diagrams for visualizing object-oriented designs.</p>"},{"location":"chapters/13-inheritance-and-polymorphism/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 25 concepts from the learning graph:</p> <ol> <li>Static Methods</li> <li>Composition</li> <li>Has-A Relationship</li> <li>Inheritance</li> <li>Is-A Relationship</li> <li>Parent Class</li> <li>Child Class</li> <li>Super Function</li> <li>Method Overriding</li> <li>Polymorphism</li> <li>Duck Typing</li> <li>Abstract Classes</li> <li>Multiple Inheritance</li> <li>Method Resolution Order</li> <li>Operator Overloading</li> <li>Eq and Lt Methods</li> <li>Add and Mul Methods</li> <li>Iterable Protocol</li> <li>Iterator Protocol</li> <li>Dunder Methods</li> <li>Object Identity</li> <li>Object Comparison</li> <li>Class Hierarchies</li> <li>UML Class Diagrams</li> <li>Design Patterns Intro</li> </ol>"},{"location":"chapters/13-inheritance-and-polymorphism/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 2: Python Fundamentals</li> <li>Chapter 9: Advanced List Operations</li> <li>Chapter 12: Classes and Objects</li> </ul> <p>Monty says: Let's code this!</p> <p> Welcome back, coders! In the last chapter you learned how to build classes and create objects. Now we're taking OOP to the next level. You'll learn how classes can inherit from other classes, how one method call can do different things depending on the object, and even how to make your classes work with <code>+</code>, <code>==</code>, and <code>for</code> loops. This chapter is packed -- let's jump in!</p>"},{"location":"chapters/13-inheritance-and-polymorphism/#building-on-what-you-know-static-methods-and-composition","title":"Building on What You Know: Static Methods and Composition","text":"<p>Before we dive into inheritance, let's tie up two important ideas from the world of classes: static methods and composition.</p>"},{"location":"chapters/13-inheritance-and-polymorphism/#static-methods","title":"Static Methods","text":"<p>A static method is a method that belongs to a class but doesn't need access to any instance (<code>self</code>) or class (<code>cls</code>) data. You mark it with the <code>@staticmethod</code> decorator. Think of it as a regular function that lives inside a class because it's logically related to that class.</p> <pre><code>class MathHelper:\n    @staticmethod\n    def is_even(number):\n        return number % 2 == 0\n\n# No need to create an instance\nprint(MathHelper.is_even(4))   # True\nprint(MathHelper.is_even(7))   # False\n</code></pre> <p>Why put <code>is_even</code> inside <code>MathHelper</code> instead of leaving it as a standalone function? Organization. When you have a bunch of related utility functions, grouping them in a class keeps your code tidy.</p>"},{"location":"chapters/13-inheritance-and-polymorphism/#composition-the-has-a-relationship","title":"Composition: The Has-A Relationship","text":"<p>Composition means building complex objects by combining simpler ones. When one object contains another object as an attribute, that's composition. We describe it as a has-a relationship.</p> <p>For example, a <code>Car</code> has an <code>Engine</code>. A <code>School</code> has a list of <code>Student</code> objects. The outer object doesn't become the inner one -- it just uses it.</p> <pre><code>class Engine:\n    def __init__(self, horsepower):\n        self.horsepower = horsepower\n\n    def start(self):\n        return \"Vroom! Engine running.\"\n\nclass Car:\n    def __init__(self, make, model, horsepower):\n        self.make = make\n        self.model = model\n        self.engine = Engine(horsepower)  # has-a relationship\n\n    def start(self):\n        return f\"{self.make} {self.model}: {self.engine.start()}\"\n\nmy_car = Car(\"Toyota\", \"Camry\", 203)\nprint(my_car.start())\n# Toyota Camry: Vroom! Engine running.\n</code></pre> <p>The <code>Car</code> class doesn't inherit from <code>Engine</code>. It contains an <code>Engine</code>. That's the key difference between \"has-a\" and \"is-a\" -- and \"is-a\" is where inheritance comes in.</p>"},{"location":"chapters/13-inheritance-and-polymorphism/#inheritance-the-is-a-relationship","title":"Inheritance: The Is-A Relationship","text":"<p>Inheritance is one of the most powerful ideas in object-oriented programming. It lets you create a new class that inherits attributes and methods from an existing class. The existing class is called the parent class (also known as the base class or superclass), and the new class is the child class (also known as the derived class or subclass).</p> <p>We describe inheritance as an is-a relationship. A <code>Dog</code> is an <code>Animal</code>. A <code>Circle</code> is a <code>Shape</code>. A <code>Student</code> is a <code>Person</code>.</p> <p>Here's the syntax:</p> <pre><code>class Animal:\n    def __init__(self, name, sound):\n        self.name = name\n        self.sound = sound\n\n    def speak(self):\n        return f\"{self.name} says {self.sound}!\"\n\n    def __str__(self):\n        return f\"Animal({self.name})\"\n\n# Dog inherits from Animal\nclass Dog(Animal):\n    def __init__(self, name):\n        super().__init__(name, \"Woof\")\n\n    def fetch(self):\n        return f\"{self.name} fetches the ball!\"\n\n# Cat inherits from Animal\nclass Cat(Animal):\n    def __init__(self, name):\n        super().__init__(name, \"Meow\")\n\n    def purr(self):\n        return f\"{self.name} purrs softly.\"\n</code></pre> <p>The <code>Dog</code> and <code>Cat</code> classes automatically get everything <code>Animal</code> has -- the <code>name</code> attribute, the <code>sound</code> attribute, the <code>speak()</code> method, and the <code>__str__()</code> method. But they can also add their own methods like <code>fetch()</code> and <code>purr()</code>.</p> <pre><code>rex = Dog(\"Rex\")\nwhiskers = Cat(\"Whiskers\")\n\nprint(rex.speak())       # Rex says Woof!\nprint(rex.fetch())       # Rex fetches the ball!\nprint(whiskers.speak())  # Whiskers says Meow!\nprint(whiskers.purr())   # Whiskers purrs softly.\n</code></pre>"},{"location":"chapters/13-inheritance-and-polymorphism/#the-super-function","title":"The Super Function","text":"<p>Notice the <code>super()</code> function in the child class constructors? That's how a child class calls a method from its parent class. When we write <code>super().__init__(name, \"Woof\")</code>, we're saying \"run the parent's <code>__init__</code> method and pass it these arguments.\"</p> <p>Without <code>super()</code>, you'd have to duplicate all the parent's initialization code in every child class. That would be tedious and error-prone. <code>super()</code> keeps things DRY (Don't Repeat Yourself).</p> <pre><code>class Puppy(Dog):\n    def __init__(self, name, toy):\n        super().__init__(name)  # Calls Dog.__init__, which calls Animal.__init__\n        self.favorite_toy = toy\n\nspot = Puppy(\"Spot\", \"rubber duck\")\nprint(spot.speak())          # Spot says Woof!\nprint(spot.favorite_toy)     # rubber duck\n</code></pre> <p>Monty says: You've got this!</p> <p> Think of inheritance like a family tree. A <code>Puppy</code> inherits traits from <code>Dog</code>, which inherits traits from <code>Animal</code>. Each generation can add new features while keeping everything from its ancestors. The <code>super()</code> function is like calling your parent and saying, \"Hey, do your setup thing first, then I'll add my own stuff.\"</p>"},{"location":"chapters/13-inheritance-and-polymorphism/#class-hierarchies","title":"Class Hierarchies","text":"<p>When you chain inheritance across multiple levels, you create a class hierarchy -- a tree-like structure showing how classes relate to each other. Our <code>Animal</code> example already has one:</p> <pre><code>        Animal\n       /      \\\n     Dog      Cat\n      |\n    Puppy\n</code></pre> <p>At the top is the most general class. As you move down, classes become more specific. Every class in Python ultimately inherits from a built-in class called <code>object</code>, even if you don't write it explicitly.</p>"},{"location":"chapters/13-inheritance-and-polymorphism/#diagram-animal-class-hierarchy","title":"Diagram: Animal Class Hierarchy","text":"Animal Class Hierarchy Interactive Diagram <p>Type: diagram sim-id: animal-class-hierarchy Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: classify, illustrate</p> <p>Learning Objective: Students will be able to trace inheritance relationships in a class hierarchy and identify which attributes and methods each class inherits versus defines on its own.</p> <p>Purpose: An interactive tree diagram showing the Animal class hierarchy. Students can click on any class node to see its attributes, methods, and which ones are inherited versus locally defined.</p> <p>Layout: - Tree structure with <code>Animal</code> at the top - <code>Dog</code> and <code>Cat</code> as children - <code>Puppy</code> as a child of <code>Dog</code> - Connecting lines with arrows pointing from child to parent</p> <p>Nodes: 1. <code>Animal</code> \u2014 attributes: name, sound; methods: <code>__init__</code>, <code>speak</code>, <code>__str__</code> 2. <code>Dog</code> \u2014 inherited: name, sound, speak, <code>__str__</code>; own: <code>__init__</code> (overridden), <code>fetch</code> 3. <code>Cat</code> \u2014 inherited: name, sound, speak, <code>__str__</code>; own: <code>__init__</code> (overridden), <code>purr</code> 4. <code>Puppy</code> \u2014 inherited: name, sound, speak, <code>__str__</code>, fetch; own: <code>__init__</code> (overridden), favorite_toy</p> <p>Interactive elements: - Click any class node to highlight it and display a panel showing its attributes/methods - Inherited items shown in blue; locally defined items shown in green; overridden items shown in orange - Hover over a method name to see its code snippet - \"Show All\" toggle to display all class details simultaneously</p> <p>Color scheme: Animal (gold), Dog (blue), Cat (green), Puppy (purple) Responsive: Tree repositions on window resize</p> <p>Instructional Rationale: Clicking to reveal inherited vs. local members supports the Understand level by helping students trace where each attribute and method originates in the hierarchy.</p>"},{"location":"chapters/13-inheritance-and-polymorphism/#method-overriding","title":"Method Overriding","text":"<p>Method overriding happens when a child class defines a method with the same name as one in its parent class. The child's version replaces the parent's version for objects of that child type.</p> <pre><code>class Animal:\n    def __init__(self, name):\n        self.name = name\n\n    def speak(self):\n        return f\"{self.name} makes a sound.\"\n\nclass Dog(Animal):\n    def speak(self):  # Overrides Animal.speak()\n        return f\"{self.name} says Woof!\"\n\nclass Cat(Animal):\n    def speak(self):  # Overrides Animal.speak()\n        return f\"{self.name} says Meow!\"\n\ngeneric = Animal(\"Critter\")\nrex = Dog(\"Rex\")\nwhiskers = Cat(\"Whiskers\")\n\nprint(generic.speak())    # Critter makes a sound.\nprint(rex.speak())        # Rex says Woof!\nprint(whiskers.speak())   # Whiskers says Meow!\n</code></pre> <p>Each class has its own version of <code>speak()</code>. When you call <code>rex.speak()</code>, Python uses the <code>Dog</code> version because <code>rex</code> is a <code>Dog</code>. This is the foundation of polymorphism.</p>"},{"location":"chapters/13-inheritance-and-polymorphism/#polymorphism-one-interface-many-forms","title":"Polymorphism: One Interface, Many Forms","text":"<p>Polymorphism is a fancy Greek word that means \"many forms.\" In programming, it means that different objects can respond to the same method call in different ways.</p> <p>Look at this:</p> <pre><code>animals = [Dog(\"Rex\"), Cat(\"Whiskers\"), Dog(\"Buddy\"), Cat(\"Luna\")]\n\nfor animal in animals:\n    print(animal.speak())\n</code></pre> <p>Output:</p> <pre><code>Rex says Woof!\nWhiskers says Meow!\nBuddy says Woof!\nLuna says Meow!\n</code></pre> <p>We called <code>speak()</code> on every animal in the list, but each one responded differently based on its type. That's polymorphism in action. The calling code doesn't need to know whether it's dealing with a <code>Dog</code> or a <code>Cat</code> -- it just calls <code>speak()</code> and the right thing happens.</p> <p>This is incredibly powerful for writing flexible, extensible code. You can add a new <code>Bird</code> class with its own <code>speak()</code> method, drop it into the list, and everything just works -- no changes needed to the loop.</p>"},{"location":"chapters/13-inheritance-and-polymorphism/#duck-typing","title":"Duck Typing","text":"<p>Python takes polymorphism even further with a concept called duck typing. The idea comes from a famous saying:</p> <p>\"If it walks like a duck and quacks like a duck, then it must be a duck.\"</p> <p>In Python, you don't need inheritance for polymorphism. If an object has the method you're trying to call, Python will happily call it -- regardless of the object's class. Python cares about what an object can do, not what an object is.</p> <pre><code>class Dog:\n    def speak(self):\n        return \"Woof!\"\n\nclass Cat:\n    def speak(self):\n        return \"Meow!\"\n\nclass RobotPet:\n    def speak(self):\n        return \"Beep boop! I am your pet.\"\n\n# These classes don't share a parent, but they all have speak()\npets = [Dog(), Cat(), RobotPet()]\n\nfor pet in pets:\n    print(pet.speak())\n</code></pre> <p><code>RobotPet</code> has no inheritance relationship with <code>Dog</code> or <code>Cat</code>. But because it has a <code>speak()</code> method, it works perfectly in the loop. That's duck typing.</p> <p>Monty says: Let's debug this together!</p> <p> Duck typing is one of Python's superpowers. It makes your code flexible because functions can work with any object that has the right methods -- not just objects of a specific type. But be careful: if you pass in an object that doesn't have the expected method, you'll get an <code>AttributeError</code> at runtime. Testing is your friend!</p>"},{"location":"chapters/13-inheritance-and-polymorphism/#abstract-classes","title":"Abstract Classes","text":"<p>Sometimes you want to define a parent class that requires child classes to implement certain methods but doesn't implement them itself. That's what abstract classes are for.</p> <p>An abstract class is like a contract: it says \"any class that inherits from me must provide these methods.\" You create abstract classes using Python's <code>abc</code> module:</p> <pre><code>from abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    @abstractmethod\n    def area(self):\n        pass\n\n    @abstractmethod\n    def perimeter(self):\n        pass\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n\n    def area(self):\n        return 3.14159 * self.radius ** 2\n\n    def perimeter(self):\n        return 2 * 3.14159 * self.radius\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n\n    def area(self):\n        return self.width * self.height\n\n    def perimeter(self):\n        return 2 * (self.width + self.height)\n</code></pre> <p>You can't create an instance of <code>Shape</code> directly -- it's abstract. But you can create <code>Circle</code> and <code>Rectangle</code> objects because they implement all the required methods.</p> <pre><code># This would raise TypeError:\n# s = Shape()\n\nc = Circle(5)\nr = Rectangle(3, 4)\nprint(c.area())        # 78.53975\nprint(r.perimeter())   # 14\n</code></pre> <p>Abstract classes are great for designing large systems where you want to guarantee that every subclass follows the same interface.</p>"},{"location":"chapters/13-inheritance-and-polymorphism/#diagram-shape-hierarchy-with-abstract-base-class","title":"Diagram: Shape Hierarchy with Abstract Base Class","text":"Shape Hierarchy with Abstract Base Class MicroSim <p>Type: microsim sim-id: shape-abstract-hierarchy Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: implement, demonstrate</p> <p>Learning Objective: Students will be able to identify abstract classes and understand why they cannot be instantiated directly, by interacting with a visual hierarchy that shows which methods are abstract vs. concrete.</p> <p>Purpose: An interactive class hierarchy diagram showing the abstract <code>Shape</code> class and its concrete subclasses <code>Circle</code>, <code>Rectangle</code>, and <code>Triangle</code>. Students can click each class to see its methods, try to \"instantiate\" the abstract class (which shows an error), and calculate areas/perimeters of concrete shapes.</p> <p>Layout: - <code>Shape</code> (ABC) at top, marked with a dashed border to indicate it's abstract - <code>Circle</code>, <code>Rectangle</code>, <code>Triangle</code> below as children with solid borders - Each node shows class name and methods list</p> <p>Interactive elements: - Click any class to see its details panel - \"Create Instance\" button on each class: shows error for Shape, creates object for concrete classes - Input fields to enter dimensions, with live area/perimeter calculations - Abstract methods shown in italic; concrete methods in regular font</p> <p>Color scheme: Shape (gray, dashed), Circle (blue), Rectangle (green), Triangle (orange) Responsive: Nodes reposition on resize</p> <p>Instructional Rationale: Attempting to instantiate the abstract class and seeing the error makes the concept concrete. Live calculations reinforce method overriding with real values.</p>"},{"location":"chapters/13-inheritance-and-polymorphism/#multiple-inheritance-and-method-resolution-order","title":"Multiple Inheritance and Method Resolution Order","text":"<p>Python supports multiple inheritance, which means a class can inherit from more than one parent class. This is powerful but can get complicated quickly.</p> <pre><code>class Flyer:\n    def move(self):\n        return \"I fly through the air!\"\n\nclass Swimmer:\n    def move(self):\n        return \"I swim through the water!\"\n\nclass Duck(Flyer, Swimmer):\n    pass\n\ndonald = Duck()\nprint(donald.move())  # I fly through the air!\n</code></pre> <p>Wait -- <code>Duck</code> inherits from both <code>Flyer</code> and <code>Swimmer</code>, and both have a <code>move()</code> method. Which one wins? Python uses something called the Method Resolution Order (MRO) to decide. The MRO follows the order you list the parent classes: <code>Flyer</code> comes first, so <code>Flyer.move()</code> wins.</p> <p>You can inspect the MRO with:</p> <pre><code>print(Duck.__mro__)\n# (&lt;class 'Duck'&gt;, &lt;class 'Flyer'&gt;, &lt;class 'Swimmer'&gt;, &lt;class 'object'&gt;)\n</code></pre> <p>Python searches for methods in this order: first <code>Duck</code>, then <code>Flyer</code>, then <code>Swimmer</code>, then <code>object</code>. The first match wins.</p> <p>Monty says: Watch out!</p> <p> Multiple inheritance can make your code confusing if overused. When two parent classes have methods with the same name, it's not always obvious which one your child class will use. Most Python developers prefer composition (has-a) over multiple inheritance when possible. Use it sparingly and always check the MRO if you're unsure!</p>"},{"location":"chapters/13-inheritance-and-polymorphism/#dunder-methods-and-operator-overloading","title":"Dunder Methods and Operator Overloading","text":"<p>Remember <code>__init__</code> and <code>__str__</code> from the last chapter? Those are dunder methods (short for \"double underscore\" methods, also called magic methods or special methods). Python has dozens of them, and they let you customize how your objects behave with built-in operations.</p> <p>Operator overloading means defining what happens when you use operators like <code>+</code>, <code>==</code>, or <code>&lt;</code> with your custom objects. You do this by implementing specific dunder methods.</p>"},{"location":"chapters/13-inheritance-and-polymorphism/#object-identity-vs-object-comparison","title":"Object Identity vs. Object Comparison","text":"<p>Before we overload operators, let's clarify two important concepts.</p> <p>Object identity asks: \"Are these the exact same object in memory?\" You test this with the <code>is</code> keyword.</p> <p>Object comparison asks: \"Do these objects have the same value?\" You test this with <code>==</code>.</p> <pre><code>a = [1, 2, 3]\nb = [1, 2, 3]\nc = a\n\nprint(a == b)   # True  -- same value\nprint(a is b)   # False -- different objects in memory\nprint(a is c)   # True  -- c points to the same object as a\n</code></pre> <p>By default, <code>==</code> checks identity (same as <code>is</code>) for custom classes. But you can override that behavior with <code>__eq__</code>.</p>"},{"location":"chapters/13-inheritance-and-polymorphism/#the-eq-and-lt-methods","title":"The eq and lt Methods","text":"<p>The <code>__eq__</code> method defines what <code>==</code> means for your objects. The <code>__lt__</code> method defines what <code>&lt;</code> means. Together, they let you compare objects in meaningful ways.</p> <pre><code>class Student:\n    def __init__(self, name, gpa):\n        self.name = name\n        self.gpa = gpa\n\n    def __eq__(self, other):\n        return self.name == other.name and self.gpa == other.gpa\n\n    def __lt__(self, other):\n        return self.gpa &lt; other.gpa\n\n    def __str__(self):\n        return f\"{self.name} (GPA: {self.gpa})\"\n\nalice = Student(\"Alice\", 3.8)\nbob = Student(\"Bob\", 3.5)\nalice2 = Student(\"Alice\", 3.8)\n\nprint(alice == alice2)  # True  -- same name and GPA\nprint(alice == bob)     # False\nprint(bob &lt; alice)      # True  -- Bob's GPA is lower\n</code></pre> <p>With <code>__lt__</code> defined, you can even sort a list of students:</p> <pre><code>students = [alice, bob, Student(\"Carol\", 3.9)]\nstudents.sort()\nfor s in students:\n    print(s)\n# Bob (GPA: 3.5)\n# Alice (GPA: 3.8)\n# Carol (GPA: 3.9)\n</code></pre>"},{"location":"chapters/13-inheritance-and-polymorphism/#the-add-and-mul-methods","title":"The add and mul Methods","text":"<p>The <code>__add__</code> method defines what <code>+</code> does with your objects. The <code>__mul__</code> method defines <code>*</code>. This is operator overloading at its finest.</p> <p>Let's create a <code>Vector</code> class that supports math operations:</p> <pre><code>class Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n\n    def __mul__(self, scalar):\n        return Vector(self.x * scalar, self.y * scalar)\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n    def __str__(self):\n        return f\"Vector({self.x}, {self.y})\"\n\nv1 = Vector(1, 2)\nv2 = Vector(3, 4)\n\nprint(v1 + v2)      # Vector(4, 6)\nprint(v1 * 3)       # Vector(3, 6)\nprint(v1 == v2)     # False\n</code></pre> <p>Now <code>Vector</code> objects work with <code>+</code>, <code>*</code>, and <code>==</code> just like built-in numbers do. That's the magic of dunder methods.</p>"},{"location":"chapters/13-inheritance-and-polymorphism/#diagram-dunder-methods-cheat-sheet","title":"Diagram: Dunder Methods Cheat Sheet","text":"Dunder Methods Cheat Sheet Interactive Reference <p>Type: infographic sim-id: dunder-methods-cheatsheet Library: p5.js Status: Specified</p> <p>Bloom Level: Remember (L1) Bloom Verb: identify, recall</p> <p>Learning Objective: Students will be able to identify common dunder methods, the operators they map to, and the purpose of each.</p> <p>Purpose: An interactive reference card that maps Python operators and built-in functions to their corresponding dunder methods. Students can hover over an operator to see the dunder method, a code example, and a plain-English explanation.</p> <p>Layout: - Grid of operator cards arranged in rows - Categories: Comparison (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>), Arithmetic (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>**</code>), String/Display (<code>str()</code>, <code>repr()</code>, <code>len()</code>), Iteration (<code>iter()</code>, <code>next()</code>)</p> <p>Interactive elements: - Hover over any operator card to see: dunder method name, example code, description - Click a card to \"pin\" it so students can compare multiple methods side by side - Search/filter bar at top to find a specific operator or method name</p> <p>Color scheme: Comparison (blue), Arithmetic (green), String/Display (orange), Iteration (purple) Responsive: Grid adjusts columns based on window width</p> <p>Instructional Rationale: A visual quick-reference supports the Remember level and gives students a resource to consult while writing their own dunder methods.</p>"},{"location":"chapters/13-inheritance-and-polymorphism/#the-iterable-and-iterator-protocols","title":"The Iterable and Iterator Protocols","text":"<p>Have you ever wondered how <code>for</code> loops work in Python? When you write <code>for item in something</code>, Python uses two special protocols behind the scenes.</p> <p>The iterable protocol requires an object to have an <code>__iter__()</code> method that returns an iterator. Any object you can loop over -- lists, strings, dictionaries, ranges -- is iterable.</p> <p>The iterator protocol requires an object to have a <code>__next__()</code> method that returns the next item, and raises <code>StopIteration</code> when there are no more items.</p> <p>Let's build a custom iterable -- a countdown:</p> <pre><code>class Countdown:\n    def __init__(self, start):\n        self.start = start\n\n    def __iter__(self):\n        self.current = self.start\n        return self\n\n    def __next__(self):\n        if self.current &lt;= 0:\n            raise StopIteration\n        value = self.current\n        self.current -= 1\n        return value\n\nfor number in Countdown(5):\n    print(number, end=\" \")\n# 5 4 3 2 1\n</code></pre> <p>Here's what happens step by step:</p> <ol> <li>The <code>for</code> loop calls <code>__iter__()</code> on the <code>Countdown</code> object to get an iterator</li> <li>Then it repeatedly calls <code>__next__()</code> on the iterator</li> <li>Each call to <code>__next__()</code> returns the next number</li> <li>When <code>__next__()</code> raises <code>StopIteration</code>, the loop ends</li> </ol> <p>This is powerful because it means you can make any object work with <code>for</code> loops. Your custom classes become first-class citizens of Python.</p>"},{"location":"chapters/13-inheritance-and-polymorphism/#uml-class-diagrams","title":"UML Class Diagrams","text":"<p>When your class hierarchies start to get complex, you need a way to visualize them. That's where UML class diagrams come in. UML stands for Unified Modeling Language, and class diagrams are one of the most common UML diagram types.</p> <p>A UML class diagram shows:</p> <ul> <li>Classes as rectangles divided into three sections: name, attributes, methods</li> <li>Inheritance as a solid line with a hollow triangle arrow pointing from child to parent</li> <li>Composition as a solid line with a filled diamond on the container's end</li> </ul> <p>Here's what our <code>Animal</code> hierarchy looks like in UML notation:</p> <pre><code>+------------------+\n|     Animal       |\n+------------------+\n| - name: str      |\n| - sound: str     |\n+------------------+\n| + speak(): str   |\n| + __str__(): str |\n+------------------+\n       /\\\n      /  \\\n     /    \\\n+--------+  +--------+\n|  Dog   |  |  Cat   |\n+--------+  +--------+\n|        |  |        |\n+--------+  +--------+\n| +fetch |  | +purr  |\n+--------+  +--------+\n</code></pre> <p>In UML notation, a <code>-</code> before an attribute means it's private, and a <code>+</code> means it's public. Arrows flow from child to parent.</p>"},{"location":"chapters/13-inheritance-and-polymorphism/#diagram-uml-class-diagram-builder","title":"Diagram: UML Class Diagram Builder","text":"UML Class Diagram Builder MicroSim <p>Type: microsim sim-id: uml-class-diagram-builder Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: construct, diagram</p> <p>Learning Objective: Students will be able to read and construct UML class diagrams that show inheritance and composition relationships between classes.</p> <p>Purpose: An interactive UML class diagram viewer and builder. Students can view pre-built diagrams for the chapter's examples (Animal hierarchy, Shape hierarchy, Vector class) and drag-and-drop to build their own simple diagrams.</p> <p>Layout: - Left panel: Toolbox with draggable class box templates, relationship arrows (inheritance, composition) - Center: Canvas area where the diagram is built - Right panel: Properties panel showing details of the selected class - Top: Dropdown to load pre-built example diagrams</p> <p>Pre-built examples: 1. Animal hierarchy (Animal -&gt; Dog, Cat -&gt; Puppy) 2. Shape hierarchy (Shape ABC -&gt; Circle, Rectangle, Triangle) 3. Car composition (Car has-a Engine) 4. Student comparison (Student with eq, lt)</p> <p>Interactive elements: - Drag class boxes from toolbox to canvas - Click a class box to edit its name, attributes, and methods - Draw inheritance arrows by clicking from child to parent - Draw composition arrows by clicking from container to part - \"Load Example\" dropdown to see pre-built diagrams - \"Clear Canvas\" button to start fresh</p> <p>Visual style: - UML standard notation: 3-section boxes, hollow triangle for inheritance, filled diamond for composition - Clean lines, modern font - Selected elements highlighted with blue border</p> <p>Color scheme: Class boxes (white with light gray header), inheritance arrows (blue), composition arrows (green) Responsive: Canvas and panels adjust to window width</p> <p>Instructional Rationale: Building diagrams by hand (drag-and-drop) supports the Apply level by requiring students to actively construct relationships rather than passively viewing them. Pre-built examples provide scaffolding for learners who need to see correct diagrams first.</p> <p>Monty says: Let's debug this together!</p> <p> UML diagrams are like blueprints for your code. Professional software developers sketch them out before they start coding to plan how classes will connect. Try drawing a UML diagram for a project of your own -- maybe a game with <code>Player</code>, <code>Enemy</code>, and <code>Item</code> classes. It's a great way to organize your thoughts!</p>"},{"location":"chapters/13-inheritance-and-polymorphism/#a-complete-example-putting-it-all-together","title":"A Complete Example: Putting It All Together","text":"<p>Let's build a mini project that uses almost everything from this chapter. We'll create a music library with songs, playlists, and the ability to sort and iterate.</p> <pre><code>from abc import ABC, abstractmethod\n\nclass MediaItem(ABC):\n    \"\"\"Abstract base class for all media items.\"\"\"\n    @abstractmethod\n    def play(self):\n        pass\n\n    @abstractmethod\n    def duration_str(self):\n        pass\n\nclass Song(MediaItem):\n    def __init__(self, title, artist, duration):\n        self.title = title\n        self.artist = artist\n        self.duration = duration  # in seconds\n\n    def play(self):\n        return f\"Now playing: {self.title} by {self.artist}\"\n\n    def duration_str(self):\n        mins = self.duration // 60\n        secs = self.duration % 60\n        return f\"{mins}:{secs:02d}\"\n\n    # Operator overloading\n    def __eq__(self, other):\n        return self.title == other.title and self.artist == other.artist\n\n    def __lt__(self, other):\n        return self.title &lt; other.title\n\n    def __add__(self, other):\n        \"\"\"Adding two songs creates a playlist.\"\"\"\n        return Playlist(\"New Playlist\", [self, other])\n\n    def __str__(self):\n        return f\"{self.title} - {self.artist} ({self.duration_str()})\"\n\nclass Playlist:\n    \"\"\"A playlist has-a list of songs (composition).\"\"\"\n    def __init__(self, name, songs=None):\n        self.name = name\n        self.songs = songs if songs else []\n\n    def add_song(self, song):\n        self.songs.append(song)\n\n    # Iterable protocol\n    def __iter__(self):\n        self._index = 0\n        return self\n\n    def __next__(self):\n        if self._index &gt;= len(self.songs):\n            raise StopIteration\n        song = self.songs[self._index]\n        self._index += 1\n        return song\n\n    def __len__(self):\n        return len(self.songs)\n\n    def __str__(self):\n        header = f\"Playlist: {self.name} ({len(self)} songs)\"\n        tracks = \"\\n\".join(f\"  {i+1}. {s}\" for i, s in enumerate(self.songs))\n        return f\"{header}\\n{tracks}\"\n\n    @staticmethod\n    def merge(playlist1, playlist2, name=\"Merged\"):\n        \"\"\"Static method to merge two playlists.\"\"\"\n        combined = playlist1.songs + playlist2.songs\n        return Playlist(name, combined)\n</code></pre> <p>Now let's use it:</p> <pre><code>s1 = Song(\"Bohemian Rhapsody\", \"Queen\", 355)\ns2 = Song(\"Imagine\", \"John Lennon\", 183)\ns3 = Song(\"Billie Jean\", \"Michael Jackson\", 294)\n\n# Operator overloading: + creates a playlist\nmy_playlist = s1 + s2\nmy_playlist.add_song(s3)\nmy_playlist.name = \"Classic Hits\"\n\n# Iteration protocol: use in a for loop\nfor song in my_playlist:\n    print(song.play())\n\n# Comparison: sort songs alphabetically\nmy_playlist.songs.sort()\nprint(my_playlist)\n</code></pre> <p>Output:</p> <pre><code>Now playing: Bohemian Rhapsody by Queen\nNow playing: Imagine by John Lennon\nNow playing: Billie Jean by Michael Jackson\nPlaylist: Classic Hits (3 songs)\n  1. Billie Jean - Michael Jackson (4:54)\n  2. Bohemian Rhapsody - Queen (5:55)\n  3. Imagine - John Lennon (3:03)\n</code></pre> <p>This example uses inheritance (<code>Song</code> extends <code>MediaItem</code>), composition (<code>Playlist</code> has-a list of <code>Song</code> objects), operator overloading (<code>__eq__</code>, <code>__lt__</code>, <code>__add__</code>), the iterator protocol (<code>__iter__</code>, <code>__next__</code>), a static method (<code>merge</code>), and abstract classes (<code>MediaItem</code>).</p>"},{"location":"chapters/13-inheritance-and-polymorphism/#diagram-music-library-class-diagram","title":"Diagram: Music Library Class Diagram","text":"Music Library UML Class Diagram MicroSim <p>Type: diagram sim-id: music-library-diagram Library: p5.js Status: Specified</p> <p>Bloom Level: Analyze (L4) Bloom Verb: differentiate, organize</p> <p>Learning Objective: Students will be able to analyze a multi-class system and identify inheritance, composition, abstract methods, operator overloading, and the iterator protocol in a UML diagram.</p> <p>Purpose: A UML class diagram showing the complete music library example. Students can click on relationships and methods to see explanations of each OOP concept being used.</p> <p>Layout: - <code>MediaItem</code> (ABC) at top with dashed border - <code>Song</code> below, connected with inheritance arrow - <code>Playlist</code> to the right of <code>Song</code>, connected with composition diamond (Playlist has Songs) - Each class box shows attributes and methods</p> <p>Interactive elements: - Click any class to highlight it and show a description - Click an inheritance arrow to see explanation: \"Song IS-A MediaItem\" - Click a composition arrow to see explanation: \"Playlist HAS-A list of Songs\" - Click any dunder method to see which operator it overloads - Legend showing arrow types and what they mean</p> <p>Color scheme: MediaItem (gray, dashed), Song (blue), Playlist (green) Responsive: Diagram repositions on window resize</p> <p>Instructional Rationale: Analyzing a realistic multi-class system supports the Analyze level. Clickable annotations help students connect UML notation to the Python concepts they've learned.</p>"},{"location":"chapters/13-inheritance-and-polymorphism/#design-patterns-a-preview","title":"Design Patterns: A Preview","text":"<p>Now that you understand inheritance, polymorphism, composition, and dunder methods, you're ready for a sneak peek at design patterns. A design pattern is a reusable solution to a common problem in software design. Think of them as \"recipes\" that experienced programmers have tested and perfected over decades.</p> <p>Here are three patterns you'll encounter as you grow as a programmer:</p> Pattern Idea Example Strategy Swap out algorithms at runtime A game character that can switch between walking, running, and flying movement strategies Observer When one object changes, notify all interested objects A weather station that updates all display screens when the temperature changes Factory Use a method to create objects instead of calling the constructor directly A <code>create_shape(\"circle\", 5)</code> function that returns the right <code>Shape</code> subclass <p>You don't need to memorize these now. Just know that the OOP concepts you've learned in this chapter -- inheritance, polymorphism, composition, and abstract classes -- are the building blocks that design patterns are made from.</p>"},{"location":"chapters/13-inheritance-and-polymorphism/#diagram-polymorphism-playground","title":"Diagram: Polymorphism Playground","text":"Polymorphism Playground MicroSim <p>Type: microsim sim-id: polymorphism-playground Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: demonstrate, experiment</p> <p>Learning Objective: Students will be able to demonstrate polymorphism by selecting different animal types, calling the same method on each, and observing different behaviors.</p> <p>Purpose: An interactive sandbox where students can create different animal objects (Dog, Cat, Bird, Fish), add them to a list, and call <code>speak()</code> and <code>move()</code> on all of them to see polymorphism in action. Includes a duck typing section where a <code>RobotPet</code> (no inheritance) also responds to the same methods.</p> <p>Layout: - Left panel: Animal selector with buttons for Dog, Cat, Bird, Fish, RobotPet - Center: Visual pen/aquarium showing animal icons - Right panel: Console output showing method call results - Bottom: \"Call speak() on all\" and \"Call move() on all\" buttons</p> <p>Interactive elements: - Click an animal button to add it to the scene with a name input - \"Call speak() on all\" iterates through all animals and displays output - \"Call move() on all\" shows each animal's movement style - \"Clear All\" button to reset - Toggle \"Show Class Type\" to display/hide each animal's class name - Highlight the RobotPet differently to emphasize duck typing</p> <p>Visual style: Cartoon animal icons that animate when their method is called Color scheme: Each animal type has a distinct color; RobotPet is metallic gray Responsive: Panels stack vertically on narrow screens</p> <p>Instructional Rationale: Creating objects and calling methods on them supports the Apply level. Mixing inheritance-based and duck-typed objects in the same collection makes polymorphism tangible and visual.</p> <p>Monty says: You've got this!</p> <p> Wow, you just powered through one of the biggest chapters in this course! You've learned inheritance, polymorphism, duck typing, abstract classes, operator overloading, iterators, and UML diagrams. These are skills that professional developers use every single day. Take a moment to celebrate -- you've earned it!</p>"},{"location":"chapters/13-inheritance-and-polymorphism/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Static methods belong to a class but don't access instance or class data. Use <code>@staticmethod</code>.</li> <li>Composition (has-a) means one object contains another. Inheritance (is-a) means one class extends another.</li> <li>A parent class provides shared attributes and methods. A child class inherits them and can add or change behavior.</li> <li>The <code>super()</code> function calls a method from the parent class, avoiding code duplication.</li> <li>Method overriding lets a child class replace a parent's method with its own version.</li> <li>Polymorphism means the same method call produces different behavior depending on the object's type.</li> <li>Duck typing means Python cares about what methods an object has, not what class it is.</li> <li>Abstract classes (using <code>ABC</code>) define a contract that child classes must follow.</li> <li>Multiple inheritance lets a class have multiple parents. The Method Resolution Order (MRO) determines which parent's method is used.</li> <li>Dunder methods like <code>__eq__</code>, <code>__lt__</code>, <code>__add__</code>, and <code>__mul__</code> enable operator overloading so your objects work with <code>==</code>, <code>&lt;</code>, <code>+</code>, and <code>*</code>.</li> <li>Object identity (<code>is</code>) checks if two variables point to the same object. Object comparison (<code>==</code>) checks if they have the same value.</li> <li>The iterable protocol (<code>__iter__</code>) and iterator protocol (<code>__next__</code>) let your objects work with <code>for</code> loops.</li> <li>UML class diagrams visualize class relationships: inheritance (hollow triangle), composition (filled diamond).</li> <li>Design patterns are reusable solutions built on the OOP concepts from this chapter.</li> <li>Class hierarchies organize classes from general (parent) to specific (child), forming tree-like structures.</li> </ul> Check Your Understanding: What's the difference between composition and inheritance? <p>Composition is a has-a relationship -- one object contains another (like a <code>Car</code> has an <code>Engine</code>). Inheritance is an is-a relationship -- one class extends another (like a <code>Dog</code> is an <code>Animal</code>). Use composition when the relationship is about ownership or containment. Use inheritance when the child truly is a type of the parent.</p> Check Your Understanding: What does duck typing mean in Python? <p>Duck typing means Python doesn't check an object's class to decide if a method call is valid -- it just checks whether the object has that method. \"If it walks like a duck and quacks like a duck, then it must be a duck.\" This means objects from completely unrelated classes can be used interchangeably, as long as they have the same methods.</p> Check Your Understanding: Why can't you create an instance of an abstract class? <p>An abstract class contains one or more abstract methods -- methods that are declared but not implemented. Since the abstract class doesn't provide working code for those methods, creating an instance of it wouldn't make sense (what would happen if you called an unimplemented method?). Python raises a <code>TypeError</code> if you try. You must create a child class that implements all the abstract methods first.</p>"},{"location":"chapters/14-errors-and-exceptions/","title":"Errors and Exceptions","text":""},{"location":"chapters/14-errors-and-exceptions/#errors-and-exceptions","title":"Errors and Exceptions","text":""},{"location":"chapters/14-errors-and-exceptions/#summary","title":"Summary","text":"<p>This chapter teaches students to handle errors gracefully in Python programs. Students will learn to distinguish between syntax, runtime, and logic errors, understand common exception types (TypeError, ValueError, IndexError, KeyError), and use try-except blocks to catch and handle exceptions. The chapter covers raising exceptions, creating custom exception classes, and using assertions for debugging. Proper error handling is essential for writing robust, production-quality software.</p>"},{"location":"chapters/14-errors-and-exceptions/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 15 concepts from the learning graph:</p> <ol> <li>Errors and Exceptions</li> <li>Syntax Errors</li> <li>Runtime Errors</li> <li>Logic Errors</li> <li>Exception Types</li> <li>TypeError</li> <li>ValueError</li> <li>IndexError</li> <li>KeyError</li> <li>Try-Except Block</li> <li>Multiple Except Blocks</li> <li>Finally Block</li> <li>Raising Exceptions</li> <li>Custom Exceptions</li> <li>Assertions</li> </ol>"},{"location":"chapters/14-errors-and-exceptions/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 2: Python Fundamentals</li> <li>Chapter 3: Boolean Logic and Comparisons</li> <li>Chapter 5: Working with Strings</li> <li>Chapter 8: Lists</li> <li>Chapter 11: Dictionaries</li> <li>Chapter 12: Classes and Objects</li> </ul> <p>Monty says: Let's debug this together!</p> <p> Hey coders! Let me let you in on a secret: every programmer makes mistakes. Even the pros who build apps used by millions of people. The difference between a beginner and an expert isn't that experts never get errors -- it's that experts know how to read them, understand them, and fix them. In this chapter, you'll learn to do exactly that. Let's turn those scary red error messages into helpful clues!</p>"},{"location":"chapters/14-errors-and-exceptions/#what-are-errors-and-exceptions","title":"What Are Errors and Exceptions?","text":"<p>When you write Python code, things don't always go as planned. Maybe you misspell a keyword, try to divide by zero, or look for an item that doesn't exist in a list. When something goes wrong, Python doesn't just silently give up -- it tells you about the problem by raising an error or exception.</p> <p>Errors and exceptions are Python's way of saying, \"Hey, something went wrong, and here's what happened.\" They're not punishments -- they're messages. Think of them like a dashboard warning light in a car. The light doesn't mean your car is ruined. It means your car is telling you something needs attention.</p> <p>Here's the good news: Python's error messages are actually quite helpful once you learn to read them. They tell you:</p> <ul> <li>What went wrong (the error type)</li> <li>Where it happened (the file and line number)</li> <li>Why it happened (a description of the problem)</li> </ul> <p>Let's look at a quick example. Say you write this code:</p> <pre><code>print(\"Hello World\"\n</code></pre> <p>Python responds with:</p> <pre><code>  File \"example.py\", line 1\n    print(\"Hello World\"\n                       ^\nSyntaxError: '(' was never closed\n</code></pre> <p>See that? Python is pointing right at the problem -- you forgot the closing parenthesis. That's not scary; that's helpful.</p>"},{"location":"chapters/14-errors-and-exceptions/#the-three-types-of-errors","title":"The Three Types of Errors","text":"<p>Not all errors are created equal. Python errors fall into three main categories, and understanding the difference between them is one of the most important skills you'll develop as a programmer.</p> Error Type When It Happens Can Python Catch It? Example Syntax Error Before the program runs Yes -- won't even start <code>print(\"hi\"</code> (missing <code>)</code>) Runtime Error While the program is running Yes -- raises an exception <code>10 / 0</code> (division by zero) Logic Error Program runs fine, but gives wrong results No -- Python can't detect it Using <code>+</code> when you meant <code>-</code> <p>Let's explore each one in detail.</p>"},{"location":"chapters/14-errors-and-exceptions/#syntax-errors","title":"Syntax Errors","text":"<p>A syntax error happens when you break Python's grammar rules. Just like English has rules about where to put commas and periods, Python has rules about parentheses, colons, indentation, and keywords. If you break one of those rules, Python can't even begin to run your code.</p> <p>Syntax errors are the easiest to find because Python catches them before your program starts running and points right at the problem.</p> <p>Here are some common syntax errors:</p> <pre><code># Missing colon after if statement\nif x &gt; 5\n    print(\"Big number\")\n</code></pre> <pre><code>  File \"example.py\", line 1\n    if x &gt; 5\n            ^\nSyntaxError: expected ':'\n</code></pre> <pre><code># Misspelled keyword\nfro i in range(10):\n    print(i)\n</code></pre> <pre><code>  File \"example.py\", line 1\n    fro i in range(10):\n        ^\nSyntaxError: invalid syntax\n</code></pre> <pre><code># Mismatched quotes\nmessage = \"Hello world'\n</code></pre> <pre><code>  File \"example.py\", line 1\n    message = \"Hello world'\n                           ^\nSyntaxError: EOL while scanning string literal\n</code></pre> <p>The fix for syntax errors is straightforward: read the error message, look at the line it points to, and fix the typo or missing character. Think of it like a spell-checker for code.</p> MicroSim: Error Type Identifier"},{"location":"chapters/14-errors-and-exceptions/#diagram-error-type-identifier","title":"Diagram: Error Type Identifier","text":"<p>Type: microsim sim-id: error-type-identifier Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: classify, distinguish</p> <p>Learning Objective: Students will be able to classify code snippets as containing syntax errors, runtime errors, or logic errors by analyzing the code and predicting the outcome.</p> <p>Purpose: An interactive quiz where students are shown code snippets one at a time and must classify each as a syntax error, runtime error, or logic error. Immediate feedback explains why each classification is correct.</p> <p>Layout: - Top section: Title \"Error Type Identifier\" - Middle: A code snippet displayed in a monospaced font box - Below the code: Three large clickable buttons labeled \"Syntax Error\", \"Runtime Error\", and \"Logic Error\" - Bottom: Feedback area showing whether the answer was correct, with an explanation - Score tracker in the top-right corner: \"Correct: X / Total: Y\"</p> <p>Code snippets bank (10+ examples): 1. <code>print(\"hello\"</code> -- Syntax Error (missing closing parenthesis) 2. <code>x = 10 / 0</code> -- Runtime Error (ZeroDivisionError) 3. <code>average = (a + b + c) / 2</code> -- Logic Error (should divide by 3, not 2) 4. <code>for i in range(10)</code> -- Syntax Error (missing colon) 5. <code>names = [\"Alice\"]; print(names[5])</code> -- Runtime Error (IndexError) 6. <code>area = length + width</code> -- Logic Error (should be multiplication) 7. <code>x = int(\"hello\")</code> -- Runtime Error (ValueError) 8. <code>if x = 5:</code> -- Syntax Error (should be ==) 9. <code>celsius = (fahrenheit - 32) * 9/5</code> -- Logic Error (should be * 5/9) 10. <code>scores = {}; print(scores[\"math\"])</code> -- Runtime Error (KeyError)</p> <p>Interactive elements: - Click a category button to submit answer - Correct answers flash green; incorrect flash red - After answering, a 2-3 sentence explanation appears - \"Next\" button loads the next code snippet - Snippets are shuffled randomly each session</p> <p>Visual style: Clean, dark code box with syntax highlighting, large accessible buttons Responsive: Canvas adjusts to window width; code font scales proportionally</p> <p>Instructional Rationale: Classification tasks at the Understand level help students build a mental model for distinguishing error types. Immediate feedback with explanations reinforces why each error belongs to its category, building diagnostic skills students need for debugging.</p>"},{"location":"chapters/14-errors-and-exceptions/#runtime-errors","title":"Runtime Errors","text":"<p>A runtime error happens while your program is running. The code is grammatically correct (Python can read it just fine), but something goes wrong during execution. These errors are called exceptions because they represent exceptional situations that Python doesn't know how to handle on its own.</p> <p>Runtime errors are trickier than syntax errors because they might not happen every time you run the program. A program might work perfectly with one set of inputs and crash with another.</p> <pre><code># This works fine\nnumerator = 10\ndenominator = 2\nresult = numerator / denominator  # 5.0, no problem\n\n# But what if the user enters 0?\ndenominator = 0\nresult = numerator / denominator  # BOOM!\n</code></pre> <pre><code>Traceback (most recent call last):\n  File \"example.py\", line 6, in &lt;module&gt;\n    result = numerator / denominator\n             ~~~~~~~~~~^~~~~~~~~~~~~\nZeroDivisionError: division by zero\n</code></pre> <p>Notice that Python gives you a traceback -- a trail of breadcrumbs that shows you exactly where the error occurred. Learning to read tracebacks is like learning to read a map. The last line tells you what went wrong (<code>ZeroDivisionError: division by zero</code>), and the lines above tell you where it happened.</p>"},{"location":"chapters/14-errors-and-exceptions/#logic-errors","title":"Logic Errors","text":"<p>Logic errors are the sneakiest of the three. Your code runs without crashing, Python doesn't complain at all, but the answer is wrong. The program does exactly what you told it to do -- it's just that what you told it isn't what you meant.</p> <pre><code># Calculate the average of three test scores\nscore1 = 85\nscore2 = 90\nscore3 = 78\n\n# Oops! Dividing by 2 instead of 3\naverage = (score1 + score2 + score3) / 2\nprint(f\"Your average is: {average}\")\n</code></pre> <pre><code>Your average is: 126.5\n</code></pre> <p>Python doesn't crash. There's no error message. But an average test score of 126.5? That's clearly wrong. The bug is dividing by 2 instead of 3, but Python has no way to know that -- it just does the math you asked for.</p> <p>Logic errors are the hardest to find because you don't get a helpful error message. You have to test your program carefully, check your results against what you expect, and trace through your code step by step to find where your logic went astray.</p> <p>Monty says: You've got this!</p> <p> Here's how I remember the three error types: Syntax errors = you spoke bad grammar and Python couldn't understand you. Runtime errors = Python understood you but ran into a problem while doing what you asked. Logic errors = Python did exactly what you asked, but what you asked was wrong. The first two give you error messages. The third one? You're on your own, detective!</p> Diagram: Three Types of Errors Comparison"},{"location":"chapters/14-errors-and-exceptions/#diagram-three-types-of-errors","title":"Diagram: Three Types of Errors","text":"<p>Type: infographic sim-id: error-types-comparison Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: compare, contrast</p> <p>Learning Objective: Students will be able to compare and contrast syntax errors, runtime errors, and logic errors by identifying when each occurs, how Python reports them, and strategies for fixing them.</p> <p>Purpose: A visual three-column comparison chart that students can hover over to see examples and explanations for each error type.</p> <p>Layout: - Three vertical columns, evenly spaced - Column headers: \"Syntax Error\", \"Runtime Error\", \"Logic Error\" - Each column contains four rows: When It Happens, Python's Response, Example, How to Fix - Color-coded: Syntax = red, Runtime = orange, Logic = yellow</p> <p>Column content:</p> <p>Syntax Error (Red): - When: Before the program runs - Python's Response: Points to the line with the problem, won't run at all - Example: <code>if x &gt; 5</code> (missing colon) - How to Fix: Read the error message, check the indicated line</p> <p>Runtime Error (Orange): - When: While the program is running - Python's Response: Crashes with a traceback and exception name - Example: <code>10 / 0</code> (ZeroDivisionError) - How to Fix: Read the traceback, use try-except to handle it</p> <p>Logic Error (Yellow): - When: Program runs successfully but gives wrong output - Python's Response: Nothing -- no error message at all - Example: Using <code>/ 2</code> instead of <code>/ 3</code> for an average - How to Fix: Test with known inputs, trace through code manually</p> <p>Interactive elements: - Hover over any cell to see a larger tooltip with additional details and a second example - Click a column header to highlight that entire column - A \"Quiz Me\" button at the bottom shows a random code snippet and asks which error type it represents</p> <p>Visual style: Clean grid with rounded borders, subtle gradients, clear typography Responsive: Columns stack vertically on narrow screens</p> <p>Instructional Rationale: Side-by-side comparison at the Understand level helps students distinguish between the three error types by directly contrasting their properties. The hover-to-reveal interaction supports deeper exploration without cluttering the initial view.</p>"},{"location":"chapters/14-errors-and-exceptions/#common-exception-types","title":"Common Exception Types","text":"<p>When a runtime error occurs, Python raises a specific type of exception that tells you exactly what kind of problem happened. Learning the common exception types is like learning to recognize different dashboard warning lights -- each one means something specific.</p> <p>Here are the most common exceptions you'll encounter:</p> Exception What It Means Common Cause <code>TypeError</code> Wrong data type for an operation Adding a string to a number <code>ValueError</code> Right type but wrong value Converting <code>\"hello\"</code> to an integer <code>IndexError</code> List index out of range Accessing element 10 in a 5-element list <code>KeyError</code> Dictionary key doesn't exist Looking up a key that was never added <code>ZeroDivisionError</code> Division by zero Dividing by a variable that happens to be 0 <code>NameError</code> Variable name not found Using a variable before defining it <code>FileNotFoundError</code> File doesn't exist Trying to open a file with a wrong path <code>AttributeError</code> Object doesn't have that attribute Calling <code>.append()</code> on a string <p>Let's look at the four most important ones in detail.</p>"},{"location":"chapters/14-errors-and-exceptions/#typeerror","title":"TypeError","text":"<p>A TypeError happens when you try to perform an operation on the wrong data type. It's like trying to use a key to unlock a combination lock -- the tool doesn't match the task.</p> <pre><code># Can't add a string and an integer\nage = \"25\"\nnew_age = age + 1\n</code></pre> <pre><code>Traceback (most recent call last):\n  File \"example.py\", line 2, in &lt;module&gt;\n    new_age = age + 1\n              ~~~~^~~\nTypeError: can only concatenate str (not \"int\") to str\n</code></pre> <p>Python is telling you: \"You tried to add an integer to a string, and I don't know what you mean by that.\" The fix? Convert the string to an integer first: <code>new_age = int(age) + 1</code>.</p> <pre><code># Can't multiply a string by a string\nresult = \"hello\" * \"world\"\n</code></pre> <pre><code>Traceback (most recent call last):\n  File \"example.py\", line 1, in &lt;module&gt;\n    result = \"hello\" * \"world\"\n             ~~~~~~~~^~~~~~~~~\nTypeError: can't multiply sequence by non-int of type 'str'\n</code></pre>"},{"location":"chapters/14-errors-and-exceptions/#valueerror","title":"ValueError","text":"<p>A ValueError happens when a function receives a value of the right type but the wrong content. The shape is correct, but the contents don't make sense.</p> <pre><code># \"hello\" is a string, but it can't be converted to an integer\nnumber = int(\"hello\")\n</code></pre> <pre><code>Traceback (most recent call last):\n  File \"example.py\", line 1, in &lt;module&gt;\n    number = int(\"hello\")\n             ^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: 'hello'\n</code></pre> <p>This happens a lot when you're getting input from users. A user might type \"abc\" when you're expecting a number. Later in this chapter, you'll learn exactly how to handle that gracefully.</p> <pre><code># The string \"3.14\" can't be directly converted to int\nnumber = int(\"3.14\")\n</code></pre> <pre><code>Traceback (most recent call last):\n  File \"example.py\", line 1, in &lt;module&gt;\n    number = int(\"3.14\")\n             ^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '3.14'\n</code></pre>"},{"location":"chapters/14-errors-and-exceptions/#indexerror","title":"IndexError","text":"<p>An IndexError happens when you try to access a list element using an index that doesn't exist. Remember, a list with 5 elements has indices 0 through 4. If you try to access index 5 (or higher), Python raises an IndexError.</p> <pre><code>fruits = [\"apple\", \"banana\", \"cherry\"]\nprint(fruits[5])\n</code></pre> <pre><code>Traceback (most recent call last):\n  File \"example.py\", line 2, in &lt;module&gt;\n    print(fruits[5])\n          ~~~~~~^^^\nIndexError: list index out of range\n</code></pre> <p>This is one of the most common errors in programming. It often shows up in loops where the loop counter goes one step too far. The classic mistake is called an off-by-one error.</p> <pre><code>colors = [\"red\", \"green\", \"blue\"]\n\n# Bug: range(3) gives 0, 1, 2 -- but range(4) would give 0, 1, 2, 3\n# Index 3 doesn't exist in a 3-element list!\nfor i in range(4):\n    print(colors[i])\n</code></pre> <pre><code>red\ngreen\nblue\nTraceback (most recent call last):\n  File \"example.py\", line 4, in &lt;module&gt;\n    print(colors[i])\n          ~~~~~~^^^\nIndexError: list index out of range\n</code></pre>"},{"location":"chapters/14-errors-and-exceptions/#keyerror","title":"KeyError","text":"<p>A KeyError happens when you try to look up a key in a dictionary that doesn't exist. It's like looking in the phone book for someone who isn't listed.</p> <pre><code>student = {\"name\": \"Alice\", \"grade\": 10}\nprint(student[\"email\"])\n</code></pre> <pre><code>Traceback (most recent call last):\n  File \"example.py\", line 2, in &lt;module&gt;\n    print(student[\"email\"])\n          ~~~~~~~^^^^^^^^^\nKeyError: 'email'\n</code></pre> <p>The dictionary has \"name\" and \"grade\" but no \"email\". To avoid this, you can use the <code>.get()</code> method, which returns <code>None</code> (or a default value you specify) instead of crashing:</p> <pre><code>student = {\"name\": \"Alice\", \"grade\": 10}\n\n# Using .get() to safely access a key\nemail = student.get(\"email\", \"No email on file\")\nprint(email)  # \"No email on file\"\n</code></pre> Diagram: Python Exception Hierarchy"},{"location":"chapters/14-errors-and-exceptions/#diagram-python-exception-hierarchy","title":"Diagram: Python Exception Hierarchy","text":"<p>Type: infographic sim-id: exception-hierarchy Library: p5.js Status: Specified</p> <p>Bloom Level: Remember (L1) Bloom Verb: identify, list</p> <p>Learning Objective: Students will be able to identify the hierarchy of Python's built-in exceptions and understand that all exceptions inherit from the BaseException class.</p> <p>Purpose: An interactive tree diagram showing Python's exception class hierarchy, letting students explore how specific exceptions relate to more general exception categories.</p> <p>Layout: - Tree structure flowing top to bottom - Root node: <code>BaseException</code> - Second level: <code>Exception</code>, <code>KeyboardInterrupt</code>, <code>SystemExit</code> - Third level (under <code>Exception</code>): <code>ArithmeticError</code>, <code>LookupError</code>, <code>TypeError</code>, <code>ValueError</code>, <code>OSError</code> - Fourth level: <code>ZeroDivisionError</code> (under <code>ArithmeticError</code>), <code>IndexError</code> and <code>KeyError</code> (under <code>LookupError</code>), <code>FileNotFoundError</code> (under <code>OSError</code>)</p> <p>Tree nodes:</p> <pre><code>BaseException\n\u251c\u2500\u2500 Exception\n\u2502   \u251c\u2500\u2500 ArithmeticError\n\u2502   \u2502   \u251c\u2500\u2500 ZeroDivisionError\n\u2502   \u2502   \u2514\u2500\u2500 OverflowError\n\u2502   \u251c\u2500\u2500 LookupError\n\u2502   \u2502   \u251c\u2500\u2500 IndexError\n\u2502   \u2502   \u2514\u2500\u2500 KeyError\n\u2502   \u251c\u2500\u2500 TypeError\n\u2502   \u251c\u2500\u2500 ValueError\n\u2502   \u251c\u2500\u2500 OSError\n\u2502   \u2502   \u2514\u2500\u2500 FileNotFoundError\n\u2502   \u251c\u2500\u2500 NameError\n\u2502   \u2514\u2500\u2500 AttributeError\n\u251c\u2500\u2500 KeyboardInterrupt\n\u2514\u2500\u2500 SystemExit\n</code></pre> <p>Interactive elements: - Hover over any node to see a brief description and an example that triggers that exception - Click a node to highlight it and all its parent nodes up to <code>BaseException</code>, showing the inheritance chain - A \"Why does this matter?\" tooltip explains that catching a parent exception also catches all its children</p> <p>Color scheme: - <code>BaseException</code>: gray - <code>Exception</code>: blue - <code>ArithmeticError</code> branch: red - <code>LookupError</code> branch: orange - <code>TypeError</code>, <code>ValueError</code>: purple - <code>OSError</code> branch: green</p> <p>Visual style: Rounded rectangle nodes with connecting lines, subtle animations on hover Responsive: Tree adjusts layout for narrow screens; nodes may reflow vertically</p> <p>Instructional Rationale: A tree visualization makes the inheritance relationship between exceptions concrete and visible. Understanding that <code>IndexError</code> is a type of <code>LookupError</code> which is a type of <code>Exception</code> helps students write more targeted except blocks and understand why catching <code>Exception</code> catches almost everything.</p>"},{"location":"chapters/14-errors-and-exceptions/#handling-exceptions-with-try-except","title":"Handling Exceptions with Try-Except","text":"<p>So far, when an error happens, your program crashes. That's fine when you're learning, but in real software, you don't want your app to crash every time something unexpected happens. Imagine if your music player crashed every time it couldn't find a song file!</p> <p>The try-except block is Python's way of saying: \"Try to run this code. If something goes wrong, don't crash -- run this other code instead.\" It's like having a backup plan.</p> <p>Here's the basic structure:</p> <pre><code>try:\n    # Code that might cause an error\n    risky_code_here()\nexcept SomeException:\n    # Code that runs if the error happens\n    handle_the_problem()\n</code></pre> <p>Let's see it in action with a real example -- getting a number from the user:</p> <pre><code>try:\n    user_input = input(\"Enter a number: \")\n    number = int(user_input)\n    print(f\"You entered: {number}\")\nexcept ValueError:\n    print(\"That's not a valid number! Please try again.\")\n</code></pre> <p>If the user types <code>42</code>, the program works normally. But if the user types <code>\"pizza\"</code>, instead of crashing with a ValueError, the program prints a friendly message: \"That's not a valid number! Please try again.\"</p> <p>Here's another example -- safe division:</p> <pre><code>def safe_divide(a, b):\n    try:\n        result = a / b\n        return result\n    except ZeroDivisionError:\n        print(\"Oops! You can't divide by zero.\")\n        return None\n\nprint(safe_divide(10, 3))   # 3.333...\nprint(safe_divide(10, 0))   # Prints message, returns None\n</code></pre> <p>The <code>try</code> block contains the code that might fail. The <code>except</code> block catches the specific exception and handles it. Your program keeps running instead of crashing.</p> <p>Monty says: Let's code this!</p> <p> Always catch specific exceptions, not just any exception. Writing <code>except:</code> with no exception type is like telling a doctor \"something hurts\" without saying where. Specific except blocks help you handle each problem in the right way. For example, <code>except ValueError</code> handles bad input differently from <code>except FileNotFoundError</code> which handles a missing file.</p>"},{"location":"chapters/14-errors-and-exceptions/#multiple-except-blocks","title":"Multiple Except Blocks","text":"<p>What if your code could raise different types of exceptions? You can use multiple except blocks to handle each one differently. It's like having multiple backup plans -- one for each type of problem.</p> <pre><code>def process_student_data(data, index):\n    try:\n        student = data[index]\n        name = student[\"name\"]\n        grade = int(student[\"grade\"])\n        print(f\"{name} is in grade {grade}\")\n    except IndexError:\n        print(f\"Error: No student at position {index}.\")\n    except KeyError as e:\n        print(f\"Error: Missing field {e} in student record.\")\n    except ValueError:\n        print(\"Error: Grade must be a number.\")\n</code></pre> <pre><code>students = [\n    {\"name\": \"Alice\", \"grade\": \"10\"},\n    {\"name\": \"Bob\"},  # missing \"grade\"\n]\n\nprocess_student_data(students, 0)  # Works: Alice is in grade 10\nprocess_student_data(students, 1)  # KeyError: Missing field 'grade'\nprocess_student_data(students, 5)  # IndexError: No student at position 5\n</code></pre> <p>Notice the <code>as e</code> in <code>except KeyError as e</code>. This captures the exception object in the variable <code>e</code> so you can include details about what went wrong in your error message. Very handy!</p> <p>You can also catch multiple exception types in a single except block using a tuple:</p> <pre><code>try:\n    # some code\n    value = int(input(\"Enter a number: \"))\n    result = 100 / value\nexcept (ValueError, ZeroDivisionError):\n    print(\"Please enter a valid non-zero number.\")\n</code></pre> MicroSim: Try-Except Block Builder"},{"location":"chapters/14-errors-and-exceptions/#diagram-try-except-block-builder","title":"Diagram: Try-Except Block Builder","text":"<p>Type: microsim sim-id: try-except-builder Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: construct, implement</p> <p>Learning Objective: Students will be able to construct try-except blocks by dragging code statements into the correct positions within a try-except structure.</p> <p>Purpose: A drag-and-drop interactive where students build try-except blocks by placing code statements into the correct sections (try block, except block, or outside the block).</p> <p>Layout: - Left side: A \"Code Bank\" panel containing draggable code statement cards - Right side: A try-except template with labeled drop zones: \"try:\", \"except [Type]:\", and \"after try-except\" - Bottom: A \"Run\" button that simulates execution and shows output - Top-right: Score display</p> <p>Scenarios (3-5 rounds):</p> <p>Round 1 - Safe Input: - Code bank: <code>user_input = input(\"Enter age: \")</code>, <code>age = int(user_input)</code>, <code>print(\"Invalid input\")</code>, <code>print(f\"Age: {age}\")</code> - Expected: <code>user_input</code> and <code>int()</code> in try, <code>print(\"Invalid\")</code> in except ValueError, <code>print(f\"Age\")</code> in try after conversion</p> <p>Round 2 - Safe List Access: - Code bank: <code>items = [1, 2, 3]</code>, <code>print(items[index])</code>, <code>print(\"Index out of range\")</code>, <code>index = int(input(\"Index: \"))</code> - Expected: list access in try, error message in except IndexError</p> <p>Round 3 - Safe File Read: - Code bank: <code>file = open(\"data.txt\")</code>, <code>content = file.read()</code>, <code>print(\"File not found\")</code>, <code>print(content)</code> - Expected: open and read in try, error message in except FileNotFoundError</p> <p>Interactive elements: - Drag code cards from the bank into drop zones - Drop zones highlight when a card is dragged over them - \"Run\" button simulates execution with sample inputs (both valid and invalid) - Shows simulated output for both success and error cases - \"Check\" button validates the arrangement and provides feedback - \"Next Round\" advances to the next scenario</p> <p>Visual style: Card-based UI with color-coded sections (try=blue tint, except=red tint) Responsive: Stacks vertically on narrow screens</p> <p>Instructional Rationale: Construction tasks at the Apply level require students to actively decide which code goes where in a try-except structure. The drag-and-drop interface makes the spatial structure of exception handling visible. Running the simulation with both valid and invalid inputs shows students how try-except alters program flow.</p>"},{"location":"chapters/14-errors-and-exceptions/#the-finally-block","title":"The Finally Block","text":"<p>Sometimes you have code that needs to run no matter what -- whether the try block succeeds or an exception is raised. That's what the finally block is for.</p> <pre><code>def read_file_safely(filename):\n    file = None\n    try:\n        file = open(filename, \"r\")\n        content = file.read()\n        print(content)\n    except FileNotFoundError:\n        print(f\"Sorry, '{filename}' doesn't exist.\")\n    finally:\n        if file:\n            file.close()\n            print(\"File closed.\")\n        print(\"Done!\")\n</code></pre> <p>The <code>finally</code> block runs whether the file was opened successfully or not. This is especially important for cleanup tasks like closing files, shutting down network connections, or releasing resources. You don't want to leave files open just because an error happened somewhere.</p> <p>Here's the execution flow:</p> <ol> <li>Python runs the <code>try</code> block</li> <li>If an exception occurs, Python jumps to the matching <code>except</code> block</li> <li>Whether or not an exception occurred, Python always runs the <code>finally</code> block</li> </ol> <pre><code># Example showing finally always runs\ndef demonstrate_finally():\n    try:\n        print(\"Step 1: Trying something risky...\")\n        result = 10 / 0  # This will crash\n        print(\"Step 2: This never runs\")\n    except ZeroDivisionError:\n        print(\"Step 3: Caught the error!\")\n    finally:\n        print(\"Step 4: Finally block ALWAYS runs!\")\n\ndemonstrate_finally()\n</code></pre> <pre><code>Step 1: Trying something risky...\nStep 3: Caught the error!\nStep 4: Finally block ALWAYS runs!\n</code></pre> <p>Notice that \"Step 2\" never printed because the exception happened before it. But \"Step 4\" printed because <code>finally</code> always runs.</p> <p>You can also combine <code>try</code>, <code>except</code>, <code>else</code>, and <code>finally</code> together:</p> <pre><code>try:\n    number = int(input(\"Enter a number: \"))\nexcept ValueError:\n    print(\"That's not a number!\")\nelse:\n    # This only runs if NO exception occurred\n    print(f\"Great! You entered {number}\")\nfinally:\n    # This ALWAYS runs\n    print(\"Thanks for playing!\")\n</code></pre> Diagram: Try-Except-Finally Flow Chart"},{"location":"chapters/14-errors-and-exceptions/#diagram-try-except-finally-flow-chart","title":"Diagram: Try-Except-Finally Flow Chart","text":"<p>Type: infographic sim-id: try-except-flow Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: trace, explain</p> <p>Learning Objective: Students will be able to trace the execution flow through try-except-else-finally blocks, predicting which blocks execute under different conditions.</p> <p>Purpose: An animated flowchart that shows how Python decides which blocks to execute in a try-except-else-finally structure, with the ability to simulate both success and failure paths.</p> <p>Layout: - Flowchart from top to bottom - Nodes: \"Start\" -&gt; \"try block\" -&gt; Diamond decision \"Exception?\" -&gt; Yes branch to \"except block\" / No branch to \"else block\" -&gt; Both converge at \"finally block\" -&gt; \"End\" - Each node is a rounded rectangle; the decision is a diamond</p> <p>Flowchart paths:</p> <p>Path A (No exception): Start -&gt; try block (completes) -&gt; Exception? NO -&gt; else block -&gt; finally block -&gt; End</p> <p>Path B (Exception caught): Start -&gt; try block (exception!) -&gt; Exception? YES -&gt; Matching except? YES -&gt; except block -&gt; finally block -&gt; End</p> <p>Path C (Exception not caught): Start -&gt; try block (exception!) -&gt; Exception? YES -&gt; Matching except? NO -&gt; finally block -&gt; Error propagates up</p> <p>Interactive elements: - Two buttons: \"Simulate Success\" and \"Simulate Error\" - Clicking either button animates a colored dot traveling through the flowchart along the appropriate path - Each node highlights as the dot reaches it, with a brief pause and a text bubble showing what happens at that step - \"Step Through\" mode lets students advance one node at a time - A code panel on the side shows corresponding Python code with the current line highlighted</p> <p>Color scheme: - try block: blue - except block: red - else block: green - finally block: purple - Connecting arrows: gray - Animated dot: gold</p> <p>Visual style: Clean flowchart with rounded nodes, animated connecting arrows Responsive: Flowchart scales to fit window; nodes reposition proportionally</p> <p>Instructional Rationale: Flowcharts make abstract control flow visible and concrete. Animating the execution path helps students build a mental model of how Python navigates through try-except-else-finally structures. The ability to compare success and failure paths side-by-side reinforces the understanding that <code>finally</code> always executes.</p>"},{"location":"chapters/14-errors-and-exceptions/#raising-exceptions","title":"Raising Exceptions","text":"<p>So far, you've been catching exceptions that Python raises. But you can also raise your own exceptions on purpose. Why would you do that? Because sometimes you know something is wrong even though Python doesn't.</p> <p>Raising exceptions lets you enforce rules in your code. It's like a bouncer at a club -- even if someone has a valid ID (correct data type), the bouncer can still turn them away if they're not on the guest list (invalid value for your specific purpose).</p> <p>You raise an exception using the <code>raise</code> keyword:</p> <pre><code>def set_age(age):\n    if age &lt; 0:\n        raise ValueError(\"Age cannot be negative!\")\n    if age &gt; 150:\n        raise ValueError(\"Age seems unrealistic!\")\n    return age\n\n# This works fine\nmy_age = set_age(16)  # 16\n\n# This raises an exception\nmy_age = set_age(-5)\n</code></pre> <pre><code>Traceback (most recent call last):\n  File \"example.py\", line 8, in &lt;module&gt;\n    my_age = set_age(-5)\n  File \"example.py\", line 3, in set_age\n    raise ValueError(\"Age cannot be negative!\")\nValueError: Age cannot be negative!\n</code></pre> <p>Here's a more practical example -- a function that validates a student's grade:</p> <pre><code>def record_grade(student_name, grade):\n    if not isinstance(grade, (int, float)):\n        raise TypeError(f\"Grade must be a number, got {type(grade).__name__}\")\n    if grade &lt; 0 or grade &gt; 100:\n        raise ValueError(f\"Grade must be between 0 and 100, got {grade}\")\n\n    print(f\"Recorded grade {grade} for {student_name}\")\n\n# These work\nrecord_grade(\"Alice\", 95)    # Recorded grade 95 for Alice\nrecord_grade(\"Bob\", 87.5)    # Recorded grade 87.5 for Bob\n\n# These raise exceptions\nrecord_grade(\"Charlie\", \"A+\")   # TypeError\nrecord_grade(\"Diana\", 150)      # ValueError\n</code></pre> <p>Monty says: Watch out!</p> <p> A common mistake is catching an exception and then silently ignoring it. Don't do this: <code>except: pass</code>. It's like putting tape over the engine warning light in your car instead of fixing the engine. At minimum, log the error or print a message so you know something went wrong. Silent failures are much harder to debug than loud ones!</p>"},{"location":"chapters/14-errors-and-exceptions/#custom-exceptions","title":"Custom Exceptions","text":"<p>Python's built-in exceptions cover most common cases, but sometimes you need an exception that's specific to your program. Custom exceptions let you create your own exception types that describe problems unique to your application.</p> <p>Creating a custom exception is surprisingly simple. You just create a new class that inherits from <code>Exception</code>:</p> <pre><code>class InvalidGradeError(Exception):\n    \"\"\"Raised when a grade is outside the valid range.\"\"\"\n    pass\n\nclass StudentNotFoundError(Exception):\n    \"\"\"Raised when a student doesn't exist in the system.\"\"\"\n    pass\n</code></pre> <p>Now you can raise and catch your custom exceptions just like built-in ones:</p> <pre><code>class InvalidGradeError(Exception):\n    \"\"\"Raised when a grade is outside the valid range.\"\"\"\n    pass\n\nclass StudentNotFoundError(Exception):\n    \"\"\"Raised when a student doesn't exist in the system.\"\"\"\n    pass\n\n# A simple gradebook\ngradebook = {\"Alice\": 92, \"Bob\": 85}\n\ndef update_grade(name, grade):\n    if name not in gradebook:\n        raise StudentNotFoundError(f\"No student named '{name}' in the gradebook\")\n    if grade &lt; 0 or grade &gt; 100:\n        raise InvalidGradeError(f\"Grade {grade} is not between 0 and 100\")\n    gradebook[name] = grade\n    print(f\"Updated {name}'s grade to {grade}\")\n\n# Using it with try-except\ntry:\n    update_grade(\"Alice\", 95)     # Works fine\n    update_grade(\"Charlie\", 88)   # StudentNotFoundError!\nexcept StudentNotFoundError as e:\n    print(f\"Student error: {e}\")\nexcept InvalidGradeError as e:\n    print(f\"Grade error: {e}\")\n</code></pre> <pre><code>Updated Alice's grade to 95\nStudent error: No student named 'Charlie' in the gradebook\n</code></pre> <p>Custom exceptions make your code more readable and more precise. Instead of raising a generic <code>ValueError</code> for every kind of problem, you can create specific exception types that tell other developers (and your future self) exactly what went wrong.</p> <p>Here's a good naming convention: always end your custom exception names with <code>Error</code> (e.g., <code>InvalidGradeError</code>, <code>InsufficientFundsError</code>, <code>PasswordTooWeakError</code>). This makes it clear that the class is an exception.</p> <p>You can also add custom attributes to your exceptions:</p> <pre><code>class InsufficientFundsError(Exception):\n    def __init__(self, balance, amount):\n        self.balance = balance\n        self.amount = amount\n        self.deficit = amount - balance\n        super().__init__(\n            f\"Cannot withdraw ${amount}. \"\n            f\"Balance: ${balance}. \"\n            f\"Short by: ${self.deficit}\"\n        )\n\n# Using the custom exception\ndef withdraw(balance, amount):\n    if amount &gt; balance:\n        raise InsufficientFundsError(balance, amount)\n    return balance - amount\n\ntry:\n    new_balance = withdraw(50, 75)\nexcept InsufficientFundsError as e:\n    print(e)\n    print(f\"You need ${e.deficit} more\")\n</code></pre> <pre><code>Cannot withdraw $75. Balance: $50. Short by: $25\nYou need $25 more\n</code></pre> MicroSim: Exception Handling Simulator"},{"location":"chapters/14-errors-and-exceptions/#diagram-exception-handling-simulator","title":"Diagram: Exception Handling Simulator","text":"<p>Type: microsim sim-id: exception-handling-sim Library: p5.js Status: Specified</p> <p>Bloom Level: Analyze (L4) Bloom Verb: predict, trace</p> <p>Learning Objective: Students will be able to predict the output of Python code containing try-except-else-finally blocks with various exception scenarios by tracing through the code execution flow.</p> <p>Purpose: An interactive code execution simulator where students trace through exception handling code step-by-step, predicting what each line will do and whether exceptions will be raised.</p> <p>Layout: - Left panel: Python code with line numbers, current line highlighted - Right panel: Output console showing printed output - Bottom panel: \"What happens next?\" question with multiple choice options - Top bar: Scenario selector dropdown and progress indicator</p> <p>Scenarios (5+):</p> <p>Scenario 1 - Basic try-except: </p><pre><code>try:\n    x = int(\"hello\")\n    print(\"Success\")\nexcept ValueError:\n    print(\"Bad value\")\nfinally:\n    print(\"Done\")\n</code></pre> Expected output: \"Bad value\" then \"Done\"<p></p> <p>Scenario 2 - No exception: </p><pre><code>try:\n    x = int(\"42\")\n    print(f\"Got {x}\")\nexcept ValueError:\n    print(\"Bad value\")\nelse:\n    print(\"No errors!\")\nfinally:\n    print(\"Done\")\n</code></pre> Expected output: \"Got 42\" then \"No errors!\" then \"Done\"<p></p> <p>Scenario 3 - Multiple except blocks: </p><pre><code>data = {\"name\": \"Alice\"}\ntry:\n    age = data[\"age\"]\n    result = 100 / age\nexcept KeyError:\n    print(\"Key missing\")\nexcept ZeroDivisionError:\n    print(\"Can't divide by zero\")\n</code></pre> Expected output: \"Key missing\"<p></p> <p>Scenario 4 - Raising exceptions: </p><pre><code>def check_age(age):\n    if age &lt; 0:\n        raise ValueError(\"Negative age\")\n    return age\n\ntry:\n    check_age(-5)\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n</code></pre> Expected output: \"Error: Negative age\"<p></p> <p>Interactive elements: - \"Step\" button advances execution one line at a time - Current line highlighted in yellow; executed lines in green; skipped lines in gray - Before each step, a \"What happens next?\" popup asks the student to predict - Options: \"This line executes normally\", \"This line raises an exception\", \"This line is skipped\" - Immediate feedback on predictions - Output console updates in real-time as lines execute - \"Reset\" button restarts the current scenario</p> <p>Visual style: IDE-like appearance with dark code panel and light output panel Responsive: Panels stack vertically on narrow screens</p> <p>Instructional Rationale: Step-by-step execution tracing at the Analyze level requires students to predict program behavior rather than just observe it. The prediction-before-reveal pattern activates metacognition and helps students build accurate mental models of exception handling flow. Multiple scenarios cover the major patterns (exception raised, no exception, multiple except blocks, raise keyword).</p>"},{"location":"chapters/14-errors-and-exceptions/#assertions","title":"Assertions","text":"<p>The last tool in your error-handling toolkit is the assertion. An assertion is a sanity check -- a statement that should be true at a specific point in your code. If the assertion is true, nothing happens and your program continues. If it's false, Python raises an <code>AssertionError</code>.</p> <p>Think of assertions as little notes you leave for yourself: \"At this point, I'm certain this should be true. If it's not, something has gone terribly wrong.\"</p> <pre><code>def calculate_average(scores):\n    assert len(scores) &gt; 0, \"Cannot average an empty list!\"\n    return sum(scores) / len(scores)\n\n# This works\nprint(calculate_average([85, 90, 78]))  # 84.33...\n\n# This triggers the assertion\nprint(calculate_average([]))\n</code></pre> <pre><code>Traceback (most recent call last):\n  File \"example.py\", line 6, in &lt;module&gt;\n    print(calculate_average([]))\n  File \"example.py\", line 2, in calculate_average\n    assert len(scores) &gt; 0, \"Cannot average an empty list!\"\nAssertionError: Cannot average an empty list!\n</code></pre> <p>The syntax for <code>assert</code> is:</p> <pre><code>assert condition, \"Optional error message\"\n</code></pre> <p>Here's when to use assertions vs. exceptions:</p> Use Case Use Assert Use Try-Except Checking your own code's logic Yes No Handling user input No Yes Catching unexpected states during development Yes No Handling network or file errors No Yes Validating function arguments in your own code Yes Sometimes <p>Assertions are primarily a debugging tool. They help you catch bugs during development by verifying assumptions. They're not meant to handle user input or expected runtime problems -- that's what try-except is for.</p> <p>Here's a practical example:</p> <pre><code>def apply_discount(price, discount_percent):\n    # These should ALWAYS be true if our code is correct\n    assert price &gt;= 0, f\"Price can't be negative: {price}\"\n    assert 0 &lt;= discount_percent &lt;= 100, f\"Discount must be 0-100: {discount_percent}\"\n\n    discounted_price = price * (1 - discount_percent / 100)\n\n    # The result should never be negative\n    assert discounted_price &gt;= 0, \"Bug: discounted price is negative!\"\n\n    return discounted_price\n\nprint(apply_discount(100, 20))  # 80.0\nprint(apply_discount(50, 10))   # 45.0\n</code></pre> <p>Monty says: You've got this!</p> <p> Congrats, coder! You now know how to handle every kind of error Python can throw at you. Syntax errors? Read the message and fix the typo. Runtime errors? Catch them with try-except. Logic errors? Test carefully and trace your code. You've leveled up your debugging skills big time. Go forth and write fearless code!</p>"},{"location":"chapters/14-errors-and-exceptions/#real-world-example-building-a-robust-input-system","title":"Real-World Example: Building a Robust Input System","text":"<p>Let's put everything together by building a function that safely gets a number from the user. This is something you'll use in nearly every interactive program:</p> <pre><code>class InputRangeError(Exception):\n    \"\"\"Raised when input is outside the acceptable range.\"\"\"\n    def __init__(self, value, min_val, max_val):\n        self.value = value\n        self.min_val = min_val\n        self.max_val = max_val\n        super().__init__(\n            f\"{value} is not between {min_val} and {max_val}\"\n        )\n\ndef get_number(prompt, min_val=None, max_val=None, max_attempts=3):\n    \"\"\"Safely get a number from the user with validation.\"\"\"\n    attempts = 0\n\n    while attempts &lt; max_attempts:\n        try:\n            user_input = input(prompt)\n            number = float(user_input)\n\n            # Check range if specified\n            if min_val is not None and max_val is not None:\n                if number &lt; min_val or number &gt; max_val:\n                    raise InputRangeError(number, min_val, max_val)\n\n            return number\n\n        except ValueError:\n            print(f\"'{user_input}' is not a valid number. Try again.\")\n        except InputRangeError as e:\n            print(f\"Out of range: {e}. Try again.\")\n        finally:\n            attempts += 1\n\n    print(f\"Too many failed attempts ({max_attempts}).\")\n    return None\n\n# Using the function\nscore = get_number(\"Enter your test score (0-100): \", 0, 100)\nif score is not None:\n    print(f\"Score recorded: {score}\")\nelse:\n    print(\"No score recorded.\")\n</code></pre> <p>This example uses:</p> <ul> <li>A custom exception (<code>InputRangeError</code>) for out-of-range values</li> <li>A try-except block to catch invalid input</li> <li>Multiple except blocks for different error types</li> <li>A finally block to count attempts no matter what happens</li> <li>The raise keyword to enforce business rules</li> </ul>"},{"location":"chapters/14-errors-and-exceptions/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Errors and exceptions are Python's way of telling you something went wrong -- they're helpful messages, not punishments.</li> <li>Syntax errors happen before your program runs (bad grammar), runtime errors happen during execution (unexpected situations), and logic errors produce wrong results without any error message.</li> <li>Common exception types include TypeError (wrong data type), ValueError (wrong value), IndexError (list index out of range), and KeyError (dictionary key not found).</li> <li>The try-except block catches exceptions and lets your program handle them gracefully instead of crashing.</li> <li>Use multiple except blocks to handle different exception types differently.</li> <li>The finally block always runs, making it perfect for cleanup tasks like closing files.</li> <li>Raising exceptions with <code>raise</code> lets you enforce rules and signal problems in your own code.</li> <li>Custom exceptions are classes that inherit from <code>Exception</code> and describe problems specific to your program.</li> <li>Assertions are debugging sanity checks that verify your assumptions about your code's state.</li> <li>Even the best programmers make errors -- the skill is knowing how to read the error messages and handle them.</li> </ul> Check Your Understanding: What's the difference between a syntax error and a runtime error? <p>A syntax error happens before your program runs. Python can't even start executing the code because the grammar is wrong (like a missing colon or unmatched parenthesis). A runtime error happens while the program is running. The code is grammatically correct, but something goes wrong during execution (like dividing by zero or accessing an index that doesn't exist). Syntax errors are caught immediately; runtime errors only show up when the problematic line actually executes.</p> Check Your Understanding: What does the <code>finally</code> block do, and when does it run? <p>The <code>finally</code> block contains code that runs no matter what -- whether the <code>try</code> block succeeds, whether an exception is raised and caught, or even whether an exception is raised and not caught. It's used for cleanup tasks like closing files, releasing resources, or printing a final message. In a <code>try-except-finally</code> structure, <code>finally</code> always runs last.</p> Check Your Understanding: Write a custom exception called <code>NegativeNumberError</code> and a function that raises it. <p>Here's one way to do it:</p> <pre><code>class NegativeNumberError(Exception):\n    \"\"\"Raised when a negative number is provided.\"\"\"\n    pass\n\ndef square_root(number):\n    if number &lt; 0:\n        raise NegativeNumberError(\n            f\"Cannot take square root of {number}\"\n        )\n    return number ** 0.5\n\n# Test it:\ntry:\n    result = square_root(-9)\nexcept NegativeNumberError as e:\n    print(f\"Error: {e}\")\n# Output: Error: Cannot take square root of -9\n</code></pre> <p>The custom exception class inherits from <code>Exception</code> and ends with <code>Error</code> by convention. The function checks for invalid input and raises the custom exception with a descriptive message.</p>"},{"location":"chapters/15-file-input-and-output/","title":"File Input and Output","text":""},{"location":"chapters/15-file-input-and-output/#file-input-and-output","title":"File Input and Output","text":""},{"location":"chapters/15-file-input-and-output/#summary","title":"Summary","text":"<p>This chapter covers reading from and writing to files in Python. Students will learn to open files in different modes, use read and write methods, and work with the with statement and context managers for safe file handling. The chapter includes working with file paths, processing CSV files, reading and writing JSON data, and handling file-related exceptions. File I/O skills enable students to build programs that persist and exchange data.</p>"},{"location":"chapters/15-file-input-and-output/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 16 concepts from the learning graph:</p> <ol> <li>File Input Output</li> <li>Opening Files</li> <li>File Modes</li> <li>Read Method</li> <li>Readline Method</li> <li>Readlines Method</li> <li>Write Method</li> <li>Writelines Method</li> <li>With Statement</li> <li>Context Managers</li> <li>File Paths</li> <li>CSV Files</li> <li>JSON Files</li> <li>File Exceptions</li> <li>Text vs Binary Files</li> <li>JSON and Dictionaries</li> </ol>"},{"location":"chapters/15-file-input-and-output/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 1: Introduction to Computer Science</li> <li>Chapter 5: Working with Strings</li> <li>Chapter 8: Lists</li> <li>Chapter 11: Dictionaries</li> <li>Chapter 14: Errors and Exceptions</li> </ul> <p>Monty says: Let's code this!</p> <p> Welcome back, coders! Up until now, every program you've written has had a short memory. The moment your program ends, all your data vanishes -- poof! -- like a Snapchat message. In this chapter, you'll learn to read and write files, which means your programs can finally remember things between runs. This is where your code starts feeling real. Let's do this!</p>"},{"location":"chapters/15-file-input-and-output/#why-files-matter","title":"Why Files Matter","text":"<p>Think about the apps you use every day. Your music player remembers your playlists. Your notes app keeps your homework lists. Video games save your progress so you don't have to start over. All of these depend on file input output -- the ability for a program to read data from a file and write data to a file.</p> <p>Without file I/O, your programs would be like a whiteboard that gets erased every time the lights turn off. With file I/O, your programs get a notebook they can keep forever.</p> <p>Here's what file I/O unlocks for you:</p> <ul> <li>Save user data between program runs (high scores, preferences, to-do lists)</li> <li>Load configuration files that control how your program behaves</li> <li>Process large datasets that are too big to type in by hand</li> <li>Exchange data with other programs and services (CSV spreadsheets, JSON APIs)</li> <li>Create logs that record what your program did and when</li> </ul> <p>By the end of this chapter, you'll be able to build programs that remember, share, and process real-world data. That's a huge level-up.</p>"},{"location":"chapters/15-file-input-and-output/#opening-files","title":"Opening Files","text":"<p>The very first step in any file operation is opening files. In Python, you use the built-in <code>open()</code> function. It takes a filename (and optionally a mode) and returns a file object that you can use to read or write data.</p> <p>Here's the simplest example:</p> <pre><code>file = open(\"greeting.txt\")\ncontent = file.read()\nprint(content)\nfile.close()\n</code></pre> <p>This program opens a file called <code>greeting.txt</code>, reads its entire contents into a string, prints that string, and then closes the file. Simple, right?</p> <p>But there's an important rule: always close files when you're done with them. If you forget to call <code>close()</code>, your program might lock the file, lose data, or run into memory problems. We'll learn a much better way to handle this soon (spoiler: it's the <code>with</code> statement), but for now, just remember: open it, use it, close it.</p>"},{"location":"chapters/15-file-input-and-output/#diagram-file-io-flow","title":"Diagram: File I/O Flow","text":"File I/O Flow Interactive Diagram <p>Type: diagram sim-id: file-io-flow Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: describe, explain</p> <p>Learning Objective: Students will be able to describe the sequence of operations in a file I/O workflow: open, read/write, and close.</p> <p>Purpose: An animated flowchart that shows how data moves between a Python program and a file on disk during read and write operations.</p> <p>Layout: - Left side: A box representing the Python program (with a code snippet inside) - Center: Animated arrows showing data flow - Right side: A box representing a file on disk (styled like a document icon) - Below: A three-step progress indicator: Open -&gt; Read/Write -&gt; Close</p> <p>Interactive elements: - \"Read Mode\" button: Animates data flowing from the file into the program, with the code snippet updating to show read operations - \"Write Mode\" button: Animates data flowing from the program into the file, with the code snippet updating to show write operations - \"Step\" button: Advance through open, read/write, close stages one at a time - \"Auto Play\" button: Animate all three stages automatically</p> <p>Visual elements: - Data particles flow along arrows between program and file - The file icon \"opens\" (lid lifts) when the open stage is active - Code in the program box highlights the currently executing line - The progress indicator highlights the current stage - The file icon \"closes\" (lid drops) when the close stage completes</p> <p>Color scheme: - Program box: blue - File icon: green - Read arrows: blue particles flowing left to right (file to program) - Write arrows: orange particles flowing right to left (program to file)</p> <p>Responsive: Canvas resizes with window; elements reposition proportionally</p> <p>Instructional Rationale: Animating the data flow between program and file makes the abstract concept of I/O concrete. The step-through controls let students observe each phase (open, read/write, close) individually, reinforcing the correct sequence of file operations.</p>"},{"location":"chapters/15-file-input-and-output/#file-modes","title":"File Modes","text":"<p>When you open a file, you can tell Python how you want to use it by specifying a file mode. The mode is the second argument to <code>open()</code>:</p> <pre><code>file = open(\"data.txt\", \"r\")   # Open for reading\nfile = open(\"data.txt\", \"w\")   # Open for writing (creates or overwrites!)\nfile = open(\"data.txt\", \"a\")   # Open for appending (adds to the end)\n</code></pre> <p>Here's a complete reference table of the most common file modes:</p> Mode Name What It Does Creates File? Overwrites? <code>\"r\"</code> Read Opens for reading only (default) No -- error if file doesn't exist No <code>\"w\"</code> Write Opens for writing Yes Yes -- erases existing content! <code>\"a\"</code> Append Opens for writing at the end Yes No -- adds to existing content <code>\"r+\"</code> Read/Write Opens for both reading and writing No -- error if file doesn't exist Can overwrite existing content <code>\"w+\"</code> Write/Read Opens for writing and reading Yes Yes -- erases existing content! <code>\"rb\"</code> Read Binary Opens for reading binary data No No <code>\"wb\"</code> Write Binary Opens for writing binary data Yes Yes <p>Monty says: Watch out!</p> <p> Be very careful with <code>\"w\"</code> mode! It erases everything in the file the moment you open it. If you accidentally open your important data file with <code>\"w\"</code> instead of <code>\"a\"</code>, all that data is gone. Double-check your mode before running your code!</p> <p>The default mode is <code>\"r\"</code> (read), so <code>open(\"data.txt\")</code> and <code>open(\"data.txt\", \"r\")</code> do exactly the same thing.</p>"},{"location":"chapters/15-file-input-and-output/#reading-files","title":"Reading Files","text":"<p>Python gives you three different methods for reading data from a file. Each one is useful in different situations.</p>"},{"location":"chapters/15-file-input-and-output/#the-read-method","title":"The Read Method","text":"<p>The read method reads the entire contents of a file into a single string:</p> <pre><code>file = open(\"poem.txt\", \"r\")\ncontent = file.read()\nprint(content)\nfile.close()\n</code></pre> <p>If <code>poem.txt</code> contains:</p> <pre><code>Roses are red,\nViolets are blue,\nPython is awesome,\nAnd so are you!\n</code></pre> <p>Then <code>content</code> would be one big string with newline characters (<code>\\n</code>) between each line. The <code>read()</code> method is great when you want the whole file at once and the file isn't too large.</p> <p>You can also pass a number to <code>read()</code> to read only that many characters:</p> <pre><code>file = open(\"poem.txt\", \"r\")\nfirst_ten = file.read(10)  # Reads the first 10 characters\nprint(first_ten)            # Output: \"Roses are \"\nfile.close()\n</code></pre>"},{"location":"chapters/15-file-input-and-output/#the-readline-method","title":"The Readline Method","text":"<p>The readline method reads one line at a time. Each call to <code>readline()</code> returns the next line (including the newline character at the end):</p> <pre><code>file = open(\"poem.txt\", \"r\")\nline1 = file.readline()   # \"Roses are red,\\n\"\nline2 = file.readline()   # \"Violets are blue,\\n\"\nprint(line1.strip())       # \"Roses are red,\"\nprint(line2.strip())       # \"Violets are blue,\"\nfile.close()\n</code></pre> <p>The <code>strip()</code> method removes the trailing <code>\\n</code> so your output looks clean. <code>readline()</code> is handy when you want to process a file one line at a time, especially if the file is very large and you don't want to load the whole thing into memory.</p>"},{"location":"chapters/15-file-input-and-output/#the-readlines-method","title":"The Readlines Method","text":"<p>The readlines method reads all lines at once and returns them as a list of strings:</p> <pre><code>file = open(\"poem.txt\", \"r\")\nlines = file.readlines()\nprint(lines)\n# ['Roses are red,\\n', 'Violets are blue,\\n', 'Python is awesome,\\n', 'And so are you!\\n']\nfile.close()\n</code></pre> <p>Each element in the list is one line from the file (newline characters included). This is perfect when you want to loop through lines:</p> <pre><code>file = open(\"poem.txt\", \"r\")\nlines = file.readlines()\nfor i, line in enumerate(lines, 1):\n    print(f\"Line {i}: {line.strip()}\")\nfile.close()\n</code></pre> <p>Output:</p> <pre><code>Line 1: Roses are red,\nLine 2: Violets are blue,\nLine 3: Python is awesome,\nLine 4: And so are you!\n</code></pre> <p>Here's a quick comparison of all three reading methods:</p> Method Returns Best For <code>read()</code> One big string Small files you want as a single chunk <code>readline()</code> One line (string) Processing line-by-line, especially large files <code>readlines()</code> List of strings When you need all lines as a list"},{"location":"chapters/15-file-input-and-output/#diagram-read-methods-comparison","title":"Diagram: Read Methods Comparison","text":"Read Methods Comparison MicroSim <p>Type: microsim sim-id: read-methods-comparison Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: compare, demonstrate</p> <p>Learning Objective: Students will be able to compare the behavior of <code>read()</code>, <code>readline()</code>, and <code>readlines()</code> and predict the output of each method for a given file.</p> <p>Purpose: An interactive side-by-side demonstration showing how the same file content is processed differently by each of Python's three read methods.</p> <p>Layout: - Top: A \"file\" display showing a sample text file with 4 lines of text - Below: Three columns, one for each method: read(), readline(), readlines() - Each column shows: the method call, the return type, and the resulting output</p> <p>Interactive elements: - \"Run All\" button: Animates all three methods processing the file simultaneously - \"Step\" buttons in each column: Step through the method's behavior one operation at a time - For readline(): Each click of \"Step\" reads the next line, showing how the file cursor advances - For readlines(): Shows lines being collected into a list one by one - \"Reset\" button: Return to initial state</p> <p>Visual elements: - The file display highlights which portion of text is being read at each step - read() column: Shows the entire file content appearing as one string, with \\n characters visible - readline() column: Shows one line appearing at a time, cursor position indicator advancing - readlines() column: Shows a list growing as each line is appended - Return type labels: \"str\", \"str\", \"list[str]\" displayed prominently</p> <p>Color scheme: - File display: light gray background, dark text - read(): blue highlights - readline(): green highlights - readlines(): orange highlights</p> <p>Responsive: Canvas adjusts; columns stack vertically on narrow screens</p> <p>Instructional Rationale: Side-by-side comparison with step-through controls makes the differences between the three methods immediately visible. Highlighting the file content as it is consumed builds a mental model of the file cursor. Showing return types prominently helps students predict how to work with the output.</p>"},{"location":"chapters/15-file-input-and-output/#writing-files","title":"Writing Files","text":"<p>Reading is only half the story. Let's talk about saving data.</p>"},{"location":"chapters/15-file-input-and-output/#the-write-method","title":"The Write Method","text":"<p>The write method takes a string and writes it to a file:</p> <pre><code>file = open(\"journal.txt\", \"w\")\nfile.write(\"Day 1: Started learning file I/O.\\n\")\nfile.write(\"Day 2: This is actually pretty cool!\\n\")\nfile.close()\n</code></pre> <p>After running this, <code>journal.txt</code> will contain:</p> <pre><code>Day 1: Started learning file I/O.\nDay 2: This is actually pretty cool!\n</code></pre> <p>Notice that <code>write()</code> does not automatically add a newline at the end. You need to include <code>\\n</code> yourself. This is different from <code>print()</code>, which adds a newline by default.</p> <p>If you open with <code>\"w\"</code> mode, the file gets completely erased before writing. If you want to add to an existing file instead of replacing it, use <code>\"a\"</code> (append) mode:</p> <pre><code>file = open(\"journal.txt\", \"a\")\nfile.write(\"Day 3: I can append to files now!\\n\")\nfile.close()\n</code></pre> <p>Now <code>journal.txt</code> has three lines instead of being overwritten.</p>"},{"location":"chapters/15-file-input-and-output/#the-writelines-method","title":"The Writelines Method","text":"<p>The writelines method writes a list of strings to a file -- all at once, no newlines added automatically:</p> <pre><code>lines = [\"Line 1\\n\", \"Line 2\\n\", \"Line 3\\n\"]\nfile = open(\"output.txt\", \"w\")\nfile.writelines(lines)\nfile.close()\n</code></pre> <p>Think of <code>writelines()</code> as the mirror image of <code>readlines()</code>. One reads a list of lines from a file; the other writes a list of lines to a file. Just remember: you need to include the <code>\\n</code> characters yourself.</p> <p>Monty says: Let's debug this together!</p> <p> Here's a common gotcha: forgetting the <code>\\n</code> in your <code>write()</code> and <code>writelines()</code> calls. Without it, all your text runs together on one giant line. Always add <code>\\n</code> at the end of each line when writing to text files!</p>"},{"location":"chapters/15-file-input-and-output/#the-with-statement-and-context-managers","title":"The With Statement and Context Managers","text":"<p>Remember how we said you should always close files when you're done? Here's the problem: what if your code crashes before it reaches the <code>close()</code> call? The file stays open, which can cause all sorts of trouble.</p> <p>Enter the with statement -- Python's elegant solution to this problem:</p> <pre><code>with open(\"greeting.txt\", \"r\") as file:\n    content = file.read()\n    print(content)\n# No need to call file.close() -- it happens automatically!\n</code></pre> <p>The <code>with</code> statement creates a block of code where the file is open. The moment the block ends -- whether your code finished normally or crashed with an error -- Python automatically closes the file for you. It's like a safety net that never fails.</p> <p>The <code>with</code> statement works because <code>open()</code> returns a context manager. A context manager is any Python object that knows how to set something up at the start of a <code>with</code> block and clean it up at the end. For files, \"set up\" means opening the file and \"clean up\" means closing it.</p> <p>Here's why the <code>with</code> statement is always better than manual open/close:</p> Approach What Happens on Error Extra Code Needed Manual <code>open()</code> / <code>close()</code> File stays open if error occurs before <code>close()</code> You must remember to call <code>close()</code> <code>with</code> statement File is automatically closed, even on errors None -- Python handles it <p>From this point forward, always use the <code>with</code> statement for file operations. It's shorter, safer, and considered best practice by every Python developer on the planet. Here's the pattern you should memorize:</p> <pre><code># Reading a file\nwith open(\"input.txt\", \"r\") as file:\n    data = file.read()\n\n# Writing a file\nwith open(\"output.txt\", \"w\") as file:\n    file.write(\"Hello, files!\\n\")\n\n# Appending to a file\nwith open(\"log.txt\", \"a\") as file:\n    file.write(\"New entry added.\\n\")\n</code></pre>"},{"location":"chapters/15-file-input-and-output/#diagram-with-statement-vs-manual-close","title":"Diagram: With Statement vs Manual Close","text":"With Statement vs Manual Close MicroSim <p>Type: microsim sim-id: with-vs-manual Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: compare, explain</p> <p>Learning Objective: Students will be able to explain why the <code>with</code> statement is safer than manual <code>open()</code>/<code>close()</code> by observing what happens when an error occurs during file operations.</p> <p>Purpose: A side-by-side simulation showing two approaches to file handling: manual open/close vs the <code>with</code> statement. Students trigger an error scenario and see how each approach responds.</p> <p>Layout: - Split screen: left side \"Manual Open/Close\", right side \"With Statement\" - Each side shows: Python code (3-5 lines), a file status indicator (open/closed), and an execution log - Bottom: Control buttons</p> <p>Interactive elements: - \"Run Normal\" button: Both sides execute without error, both files close successfully - \"Run With Error\" button: An error occurs mid-execution. Left side: file stays open (red warning). Right side: file still closes (green success). - \"Reset\" button: Clear the log and reset state - Hover over code lines to see tooltips explaining what each line does</p> <p>Visual elements: - File status: A lock/unlock icon that shows whether the file is open (unlocked, yellow) or closed (locked, green) or stuck open (unlocked, red pulsing) - Code lines highlight as they \"execute\" - Error shown as a red flash on the line where it occurs - Execution log shows timestamped entries: \"Opened file\", \"Reading data...\", \"ERROR!\", \"File closed\" or \"File still open!\"</p> <p>Color scheme: - Normal execution: green highlights - Error: red highlights - File open: yellow - File closed: green - File stuck open: red pulsing</p> <p>Responsive: Canvas resizes; panels stack vertically on narrow screens</p> <p>Instructional Rationale: Showing the error scenario side-by-side makes the safety advantage of <code>with</code> immediately visible. Students can see concretely that manual close fails on errors while the context manager always succeeds. This builds a strong case for always using <code>with</code> statements.</p>"},{"location":"chapters/15-file-input-and-output/#file-paths","title":"File Paths","text":"<p>So far, we've been using simple filenames like <code>\"greeting.txt\"</code>. But where does Python actually look for that file? Understanding file paths is essential for working with files in real projects.</p> <p>There are two types of paths:</p> <p>Relative paths are relative to your program's current working directory (usually the folder where your script lives):</p> <pre><code># These look in the same folder as your script\nwith open(\"data.txt\", \"r\") as file:\n    content = file.read()\n\n# This looks in a subfolder called \"data\"\nwith open(\"data/scores.txt\", \"r\") as file:\n    content = file.read()\n</code></pre> <p>Absolute paths specify the exact location from the root of your file system:</p> <pre><code># Windows absolute path\nwith open(\"C:/Users/student/Documents/data.txt\", \"r\") as file:\n    content = file.read()\n\n# Mac/Linux absolute path\nwith open(\"/home/student/Documents/data.txt\", \"r\") as file:\n    content = file.read()\n</code></pre> <p>Here's a practical tip: use Python's <code>os.path</code> module to build paths that work on any operating system:</p> <pre><code>import os\n\n# Build a path that works on Windows, Mac, and Linux\nfolder = \"data\"\nfilename = \"scores.txt\"\nfull_path = os.path.join(folder, filename)\n# On Windows: \"data\\\\scores.txt\"\n# On Mac/Linux: \"data/scores.txt\"\n\nwith open(full_path, \"r\") as file:\n    content = file.read()\n</code></pre> <p>You can also check if a file exists before trying to open it:</p> <pre><code>import os\n\nif os.path.exists(\"data.txt\"):\n    with open(\"data.txt\", \"r\") as file:\n        content = file.read()\nelse:\n    print(\"File not found!\")\n</code></pre>"},{"location":"chapters/15-file-input-and-output/#text-vs-binary-files","title":"Text vs Binary Files","text":"<p>Every file on your computer is either a text file or a binary file. Understanding the difference is important for choosing the right mode when opening files.</p> <p>Text files contain human-readable characters -- letters, numbers, punctuation, and whitespace. When you open a text file in a text editor, you can read it. Examples include <code>.txt</code>, <code>.py</code>, <code>.csv</code>, <code>.json</code>, and <code>.html</code> files.</p> <p>Binary files contain raw bytes that don't necessarily represent readable text. They use special formats that only specific programs know how to interpret. Examples include images (<code>.png</code>, <code>.jpg</code>), audio (<code>.mp3</code>), video (<code>.mp4</code>), and compiled programs (<code>.exe</code>).</p> Feature Text Files Binary Files Content Human-readable characters Raw bytes Open mode <code>\"r\"</code>, <code>\"w\"</code>, <code>\"a\"</code> <code>\"rb\"</code>, <code>\"wb\"</code>, <code>\"ab\"</code> Line endings Handled automatically Not processed Examples <code>.txt</code>, <code>.csv</code>, <code>.json</code>, <code>.py</code> <code>.png</code>, <code>.mp3</code>, <code>.pdf</code>, <code>.exe</code> <p>When you open a file in text mode (the default), Python automatically handles line ending differences between operating systems. Windows uses <code>\\r\\n</code> for new lines, while Mac and Linux use <code>\\n</code>. Python smooths this over for you in text mode.</p> <p>When working with binary files, you add <code>\"b\"</code> to the mode string:</p> <pre><code># Reading a binary file (like an image)\nwith open(\"photo.png\", \"rb\") as file:\n    image_data = file.read()\n    print(f\"File size: {len(image_data)} bytes\")\n\n# Copying a binary file\nwith open(\"photo.png\", \"rb\") as source:\n    data = source.read()\n\nwith open(\"photo_copy.png\", \"wb\") as destination:\n    destination.write(data)\n</code></pre> <p>For this course, you'll mostly work with text files. But it's good to know that binary mode exists for when you need it.</p>"},{"location":"chapters/15-file-input-and-output/#working-with-csv-files","title":"Working with CSV Files","text":"<p>A CSV file (Comma-Separated Values) is one of the most common file formats for storing tabular data -- think spreadsheets, but as plain text. Each line is a row, and values within each row are separated by commas:</p> <pre><code>name,grade,score\nAlice,10,92\nBob,11,87\nCharlie,10,95\nDiana,12,88\n</code></pre> <p>You could read a CSV file with basic string methods, but Python has a built-in <code>csv</code> module that handles tricky edge cases (like commas inside quoted fields) for you:</p> <pre><code>import csv\n\nwith open(\"students.csv\", \"r\") as file:\n    reader = csv.reader(file)\n    header = next(reader)  # Read the header row\n    print(f\"Columns: {header}\")\n\n    for row in reader:\n        name = row[0]\n        grade = row[1]\n        score = row[2]\n        print(f\"{name} (Grade {grade}): {score}\")\n</code></pre> <p>Output:</p> <pre><code>Columns: ['name', 'grade', 'score']\nAlice (Grade 10): 92\nBob (Grade 11): 87\nCharlie (Grade 10): 95\nDiana (Grade 12): 88\n</code></pre> <p>Writing CSV files is just as easy:</p> <pre><code>import csv\n\nstudents = [\n    [\"name\", \"grade\", \"score\"],\n    [\"Alice\", \"10\", \"92\"],\n    [\"Bob\", \"11\", \"87\"],\n    [\"Charlie\", \"10\", \"95\"],\n]\n\nwith open(\"students.csv\", \"w\", newline=\"\") as file:\n    writer = csv.writer(file)\n    writer.writerows(students)\n</code></pre> <p>Notice the <code>newline=\"\"</code> argument when writing CSV files. This prevents Python from adding extra blank lines between rows on some operating systems. It's a small detail, but it saves you from a confusing bug.</p> <p>Monty says: You've got this!</p> <p> CSV files are everywhere in the real world -- from school grade exports to scientific datasets to stock market data. If you can read and write CSV files, you can work with data from almost any source. That's a seriously useful skill!</p>"},{"location":"chapters/15-file-input-and-output/#diagram-csv-file-structure","title":"Diagram: CSV File Structure","text":"CSV File Structure Interactive Explorer <p>Type: infographic sim-id: csv-file-structure Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: interpret, explain</p> <p>Learning Objective: Students will be able to interpret the structure of a CSV file by mapping raw comma-separated text to a table representation and back.</p> <p>Purpose: An interactive dual-view display that shows a CSV file's raw text alongside its table representation, with highlighting to show how rows and columns map between the two views.</p> <p>Layout: - Left panel: Raw CSV text display (monospace font, showing commas and newlines) - Right panel: Table view (grid with rows and columns, styled like a spreadsheet) - A sample dataset with 5-6 rows and 3-4 columns</p> <p>Interactive elements: - Hover over any cell in the table: Highlights the corresponding text in the raw CSV view - Hover over text in the raw CSV view: Highlights the corresponding cell in the table - \"Add Row\" button: Adds a new row to both views simultaneously - \"Toggle Quotes\" button: Shows what happens when a field contains a comma (wrapping it in quotes in the raw view) - \"Edit\" mode: Click a cell in the table to change its value and see the raw CSV update</p> <p>Visual elements: - Matching colors: When a cell is highlighted, the same color appears in both the raw and table views - Header row styled distinctly (bold, different background) - Commas in the raw view are colored differently (gray) to distinguish them from data - Newlines shown as visible line breaks with a faint return arrow symbol</p> <p>Color scheme: - Header: blue background - Data rows: alternating white and light gray - Highlighted mapping: yellow background - Commas: gray text</p> <p>Responsive: Panels stack vertically on narrow screens</p> <p>Instructional Rationale: The dual-view design supports the Understand level by making the mapping between raw text and tabular structure explicit. Hover-to-highlight interaction lets students trace exactly how commas create columns and newlines create rows.</p>"},{"location":"chapters/15-file-input-and-output/#working-with-json-files","title":"Working with JSON Files","text":"<p>If CSV is great for tables, JSON files are great for structured, nested data. JSON stands for JavaScript Object Notation, but don't let the name fool you -- Python loves JSON too.</p> <p>Here's what JSON looks like:</p> <pre><code>{\n    \"name\": \"Alice\",\n    \"grade\": 10,\n    \"courses\": [\"Math\", \"English\", \"Computer Science\"],\n    \"gpa\": 3.8\n}\n</code></pre> <p>Look familiar? It should! JSON looks almost exactly like Python dictionaries and lists. That's not a coincidence -- JSON and Python data structures map to each other naturally.</p>"},{"location":"chapters/15-file-input-and-output/#json-and-dictionaries","title":"JSON and Dictionaries","text":"<p>The connection between JSON and dictionaries is one of the most useful things you'll learn in this chapter. Here's how JSON types map to Python types:</p> JSON Type Python Type Example Object <code>{}</code> Dictionary <code>dict</code> <code>{\"name\": \"Alice\"}</code> Array <code>[]</code> List <code>list</code> <code>[1, 2, 3]</code> String <code>\"\"</code> String <code>str</code> <code>\"hello\"</code> Number (int) Integer <code>int</code> <code>42</code> Number (float) Float <code>float</code> <code>3.14</code> <code>true</code> / <code>false</code> <code>True</code> / <code>False</code> <code>true</code> -&gt; <code>True</code> <code>null</code> <code>None</code> <code>null</code> -&gt; <code>None</code> <p>Python's built-in <code>json</code> module makes converting between JSON files and Python objects effortless:</p> <pre><code>import json\n\n# Reading JSON from a file\nwith open(\"student.json\", \"r\") as file:\n    student = json.load(file)\n\n# Now 'student' is a regular Python dictionary!\nprint(student[\"name\"])      # \"Alice\"\nprint(student[\"grade\"])     # 10\nprint(student[\"courses\"])   # [\"Math\", \"English\", \"Computer Science\"]\n</code></pre> <p>Writing Python data to a JSON file is just as smooth:</p> <pre><code>import json\n\nstudent = {\n    \"name\": \"Bob\",\n    \"grade\": 11,\n    \"courses\": [\"History\", \"Physics\", \"Art\"],\n    \"gpa\": 3.5\n}\n\nwith open(\"student.json\", \"w\") as file:\n    json.dump(student, file, indent=4)\n</code></pre> <p>The <code>indent=4</code> argument makes the JSON file nicely formatted with 4 spaces of indentation. Without it, everything gets crammed onto one line -- technically valid, but hard to read.</p> <p>Here's a more complete example -- a program that loads a list of students, adds a new one, and saves it back:</p> <pre><code>import json\n\n# Load existing data\nwith open(\"class_roster.json\", \"r\") as file:\n    roster = json.load(file)\n\n# Add a new student\nnew_student = {\n    \"name\": \"Eve\",\n    \"grade\": 10,\n    \"gpa\": 3.9\n}\nroster.append(new_student)\n\n# Save updated data\nwith open(\"class_roster.json\", \"w\") as file:\n    json.dump(roster, file, indent=4)\n\nprint(f\"Roster now has {len(roster)} students.\")\n</code></pre> <p>You can also convert between JSON strings and Python objects without involving files:</p> <pre><code>import json\n\n# Python dict -&gt; JSON string\ndata = {\"score\": 100, \"level\": 5}\njson_string = json.dumps(data)\nprint(json_string)  # '{\"score\": 100, \"level\": 5}'\n\n# JSON string -&gt; Python dict\ntext = '{\"name\": \"Charlie\", \"age\": 16}'\nparsed = json.loads(text)\nprint(parsed[\"name\"])  # \"Charlie\"\n</code></pre> <p>Notice the difference: <code>json.load()</code> / <code>json.dump()</code> work with files, while <code>json.loads()</code> / <code>json.dumps()</code> work with strings. The <code>s</code> stands for \"string.\"</p>"},{"location":"chapters/15-file-input-and-output/#diagram-json-to-dictionary-mapping","title":"Diagram: JSON to Dictionary Mapping","text":"JSON to Dictionary Mapping MicroSim <p>Type: microsim sim-id: json-dict-mapping Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: convert, demonstrate</p> <p>Learning Objective: Students will be able to convert between JSON text and Python dictionary representations by editing one view and seeing the other update automatically.</p> <p>Purpose: A live dual-editor that shows JSON text on one side and the equivalent Python dictionary on the other, with changes in either view instantly reflected in the other.</p> <p>Layout: - Left panel: JSON text editor (syntax-highlighted, editable) - Center: Bidirectional arrow with \"json.load()\" and \"json.dump()\" labels - Right panel: Python dictionary display (syntax-highlighted) - Bottom: A set of example presets to load</p> <p>Interactive elements: - Edit JSON text on the left: Python dictionary on the right updates in real-time - Click any key or value in the Python view: Corresponding element highlights in the JSON view - \"Load Example\" dropdown: Presets for student data, game save, settings config, and nested data - \"Validate\" button: Checks if the JSON is valid and shows error messages for common mistakes (missing quotes, trailing commas) - Type mapping legend: Shows JSON type -&gt; Python type mapping</p> <p>Visual elements: - JSON keys highlighted in blue, strings in green, numbers in orange, booleans in purple - Python dict uses the same color scheme for easy visual matching - Invalid JSON: Red underline with error tooltip - Conversion arrows animate briefly when a change is made</p> <p>Color scheme: Standard code editor colors (dark background, colored syntax)</p> <p>Responsive: Panels stack vertically on narrow screens</p> <p>Instructional Rationale: The dual-editor with live synchronization supports the Apply level by letting students experiment with JSON/dictionary conversions interactively. The validation feature helps students debug common JSON syntax mistakes. Presets provide graduated examples from simple to nested structures.</p>"},{"location":"chapters/15-file-input-and-output/#handling-file-exceptions","title":"Handling File Exceptions","text":"<p>Files live outside your program -- on a hard drive, a USB stick, maybe even a network server. Lots of things can go wrong: the file might not exist, you might not have permission to open it, or the disk might be full. That's why file exceptions are so important.</p> <p>The most common file-related exception is <code>FileNotFoundError</code>:</p> <pre><code>try:\n    with open(\"missing_file.txt\", \"r\") as file:\n        content = file.read()\nexcept FileNotFoundError:\n    print(\"Oops! That file doesn't exist.\")\n</code></pre> <p>Here's a table of common file exceptions and when they occur:</p> Exception When It Happens <code>FileNotFoundError</code> Trying to read a file that doesn't exist <code>PermissionError</code> No permission to read or write the file <code>IsADirectoryError</code> Trying to open a directory as a file <code>IOError</code> General input/output problem (disk full, etc.) <code>UnicodeDecodeError</code> File contains characters that can't be decoded as text <p>A robust file-reading function handles multiple error types:</p> <pre><code>def safe_read(filename):\n    \"\"\"Read a file safely, handling common errors.\"\"\"\n    try:\n        with open(filename, \"r\") as file:\n            return file.read()\n    except FileNotFoundError:\n        print(f\"Error: '{filename}' not found.\")\n    except PermissionError:\n        print(f\"Error: No permission to read '{filename}'.\")\n    except UnicodeDecodeError:\n        print(f\"Error: '{filename}' contains unreadable characters.\")\n    return None\n\ncontent = safe_read(\"mydata.txt\")\nif content is not None:\n    print(f\"Read {len(content)} characters.\")\n</code></pre> <p>Here's a practical example -- a program that keeps a simple log file, creating it if it doesn't exist:</p> <pre><code>import datetime\n\ndef write_log(message):\n    \"\"\"Append a timestamped message to the log file.\"\"\"\n    timestamp = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    try:\n        with open(\"app_log.txt\", \"a\") as log_file:\n            log_file.write(f\"[{timestamp}] {message}\\n\")\n    except PermissionError:\n        print(\"Warning: Could not write to log file.\")\n\n# Using the logger\nwrite_log(\"Program started\")\nwrite_log(\"Loaded 42 records from database\")\nwrite_log(\"User logged in: Alice\")\n</code></pre> <p>The log file would look like:</p> <pre><code>[2026-02-11 14:30:15] Program started\n[2026-02-11 14:30:15] Loaded 42 records from database\n[2026-02-11 14:30:15] User logged in: Alice\n</code></pre> <p>Monty says: You've got this!</p> <p> Error handling might feel like extra work, but it's what separates a hobby script from a real program. Professional developers always wrap file operations in try-except blocks. You're learning the habits of a pro!</p>"},{"location":"chapters/15-file-input-and-output/#putting-it-all-together-a-complete-example","title":"Putting It All Together: A Complete Example","text":"<p>Let's build something real -- a simple grade tracker that loads student data from a JSON file, lets you add new grades, and saves everything back. This example uses almost everything we've covered in this chapter:</p> <pre><code>import json\nimport os\nimport csv\n\nGRADES_FILE = \"grades.json\"\n\ndef load_grades():\n    \"\"\"Load grades from JSON file, or create empty data if file doesn't exist.\"\"\"\n    if os.path.exists(GRADES_FILE):\n        try:\n            with open(GRADES_FILE, \"r\") as file:\n                return json.load(file)\n        except json.JSONDecodeError:\n            print(\"Warning: Grades file is corrupted. Starting fresh.\")\n    return {}\n\ndef save_grades(grades):\n    \"\"\"Save grades to JSON file.\"\"\"\n    with open(GRADES_FILE, \"w\") as file:\n        json.dump(grades, file, indent=4)\n    print(\"Grades saved!\")\n\ndef add_grade(grades, student, assignment, score):\n    \"\"\"Add a grade for a student.\"\"\"\n    if student not in grades:\n        grades[student] = {}\n    grades[student][assignment] = score\n\ndef export_to_csv(grades, csv_filename):\n    \"\"\"Export grades to a CSV file.\"\"\"\n    with open(csv_filename, \"w\", newline=\"\") as file:\n        writer = csv.writer(file)\n        writer.writerow([\"Student\", \"Assignment\", \"Score\"])\n        for student, assignments in grades.items():\n            for assignment, score in assignments.items():\n                writer.writerow([student, assignment, score])\n    print(f\"Exported to {csv_filename}\")\n\n# Main program\ngrades = load_grades()\n\nadd_grade(grades, \"Alice\", \"Homework 1\", 95)\nadd_grade(grades, \"Alice\", \"Quiz 1\", 88)\nadd_grade(grades, \"Bob\", \"Homework 1\", 92)\nadd_grade(grades, \"Bob\", \"Quiz 1\", 79)\n\nsave_grades(grades)\nexport_to_csv(grades, \"grades_report.csv\")\n</code></pre> <p>This little program demonstrates:</p> <ul> <li>JSON loading and saving for persistent data storage</li> <li>CSV export for sharing data with spreadsheet programs</li> <li>File paths with <code>os.path.exists()</code></li> <li>Error handling for corrupted files</li> <li>The <code>with</code> statement for safe file management</li> <li>Dictionaries mapped to JSON structure</li> </ul>"},{"location":"chapters/15-file-input-and-output/#diagram-file-format-decision-tree","title":"Diagram: File Format Decision Tree","text":"File Format Decision Tree MicroSim <p>Type: microsim sim-id: file-format-decision Library: p5.js Status: Specified</p> <p>Bloom Level: Evaluate (L5) Bloom Verb: choose, justify</p> <p>Learning Objective: Students will be able to choose the appropriate file format (plain text, CSV, or JSON) for a given data storage scenario and justify their choice.</p> <p>Purpose: An interactive decision tree that guides students through questions about their data to recommend the best file format, with explanations for why each format fits certain use cases.</p> <p>Layout: - Top: A question node with two or three branching answers - Each answer leads to another question or a recommendation - Final nodes show the recommended file format with a brief explanation</p> <p>Decision tree questions: 1. \"Is your data structured in rows and columns?\" -&gt; Yes: go to Q2 / No: go to Q3 2. \"Does your data have nested or hierarchical structure?\" -&gt; Yes: JSON / No: CSV 3. \"Is your data just plain text (like a log or notes)?\" -&gt; Yes: Plain text (.txt) / No: go to Q4 4. \"Is your data key-value pairs or nested objects?\" -&gt; Yes: JSON / No: Plain text</p> <p>Interactive elements: - Click answers to navigate through the tree - \"Try a Scenario\" button: Presents a real-world scenario (game save data, student roster, error log, configuration settings) and lets the student work through the tree - \"Start Over\" button: Reset to the first question - At each final recommendation: A code example showing how to read/write that format</p> <p>Visual elements: - Tree nodes connected by curved lines - Current node highlighted with a glow effect - Previously visited path shown in a lighter color - Recommendation nodes styled as large cards with the file format name, icon, and explanation</p> <p>Color scheme: - Question nodes: blue - Answer branches: gray lines - CSV recommendation: green - JSON recommendation: orange - Plain text recommendation: purple</p> <p>Responsive: Tree reflows for different screen sizes</p> <p>Instructional Rationale: The decision tree approach supports the Evaluate level by requiring students to assess their data characteristics and make a justified choice. Real-world scenarios make the decision process practical rather than theoretical. Showing code examples at the recommendation nodes connects the decision to implementation.</p>"},{"location":"chapters/15-file-input-and-output/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>File input output lets your programs save data that persists between runs -- this is where programs start feeling \"real.\"</li> <li>Opening files with <code>open()</code> gives you a file object for reading or writing. Always close files when done.</li> <li>File modes control whether you read (<code>\"r\"</code>), write (<code>\"w\"</code>), or append (<code>\"a\"</code>). Be careful with <code>\"w\"</code> -- it erases the file!</li> <li><code>read()</code> returns the whole file as a string, <code>readline()</code> returns one line at a time, and <code>readlines()</code> returns all lines as a list.</li> <li><code>write()</code> sends a string to the file (no automatic newline), and <code>writelines()</code> writes a list of strings.</li> <li>The <code>with</code> statement and context managers automatically close files for you, even if an error occurs. Always use <code>with</code> for file operations.</li> <li>File paths can be relative (from your script's folder) or absolute (from the root). Use <code>os.path.join()</code> for cross-platform compatibility.</li> <li>CSV files store tabular data with commas between values. Use Python's <code>csv</code> module to read and write them.</li> <li>JSON files store structured, nested data that maps directly to Python dictionaries and lists. Use the <code>json</code> module.</li> <li>JSON and dictionaries are natural partners: <code>json.load()</code> reads a file into a dict, and <code>json.dump()</code> writes a dict to a file.</li> <li>Text files contain readable characters; binary files contain raw bytes. Add <code>\"b\"</code> to the mode for binary files.</li> <li>Always handle file exceptions (<code>FileNotFoundError</code>, <code>PermissionError</code>) with try-except blocks for robust programs.</li> </ul> <p>Monty says: You've got this!</p> <p> You just unlocked a superpower, coder! Your programs can now remember things, share data with other programs, and process real-world files. That's a massive milestone. From simple text files to CSV spreadsheets to JSON data -- you've got the tools to build programs that interact with the real world. Awesome work!</p> Check Your Understanding: What's the difference between <code>'w'</code> and <code>'a'</code> file modes? <p>Opening a file with <code>\"w\"</code> (write) mode erases all existing content and starts fresh. Opening with <code>\"a\"</code> (append) mode keeps the existing content and adds new data to the end. If you want to add to a log file without destroying previous entries, use <code>\"a\"</code>. If you want to completely replace the file's contents, use <code>\"w\"</code>.</p> Check Your Understanding: Why should you use the <code>with</code> statement instead of calling <code>open()</code> and <code>close()</code> manually? <p>The <code>with</code> statement automatically closes the file when the block ends -- even if an error occurs during your code. With manual <code>open()</code>/<code>close()</code>, if an error happens before you reach <code>close()</code>, the file stays open, which can lead to data loss or locked files. The <code>with</code> statement is shorter, safer, and the recommended practice.</p> Check Your Understanding: How would you read a JSON file into a Python dictionary? <p>Use the <code>json</code> module's <code>load()</code> function with a <code>with</code> statement: </p><pre><code>import json\n\nwith open(\"data.json\", \"r\") as file:\n    my_dict = json.load(file)\n</code></pre> The <code>json.load()</code> function reads the JSON text from the file and converts it into a Python dictionary (or list, depending on the JSON structure). You can then work with <code>my_dict</code> just like any other Python dictionary.<p></p>"},{"location":"chapters/16-software-engineering/","title":"Software Engineering Practices","text":""},{"location":"chapters/16-software-engineering/#software-engineering-practices","title":"Software Engineering Practices","text":""},{"location":"chapters/16-software-engineering/#summary","title":"Summary","text":"<p>This chapter introduces the practices and tools used in professional software development. Students will learn about the software development lifecycle, modular design principles (DRY, KISS), code organization with Python modules and packages, the pip package manager, and virtual environments. The chapter covers version control with Git, code style with PEP 8, linting tools, refactoring techniques, and writing documentation. Students will also learn the <code>if __name__ == \"__main__\"</code> pattern for writing reusable modules.</p>"},{"location":"chapters/16-software-engineering/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 21 concepts from the learning graph:</p> <ol> <li>Software Development</li> <li>Program Planning</li> <li>Requirements Analysis</li> <li>Modular Design</li> <li>Code Organization</li> <li>Import Statements</li> <li>Python Modules</li> <li>Python Packages</li> <li>Pip Package Manager</li> <li>Virtual Environments</li> <li>Version Control Intro</li> <li>Git Basics</li> <li>Code Style</li> <li>PEP 8 Guidelines</li> <li>Linting Tools</li> <li>Refactoring</li> <li>DRY Principle</li> <li>KISS Principle</li> <li>Code Comments</li> <li>Documentation</li> <li>Name Equals Main</li> </ol>"},{"location":"chapters/16-software-engineering/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 1: Introduction to Computer Science</li> <li>Chapter 2: Python Fundamentals</li> <li>Chapter 6: Functions and Modular Design</li> <li>Chapter 14: Errors and Exceptions</li> <li>Chapter 15: File Input and Output</li> </ul> <p>Monty says: Let's code this!</p> <p> Welcome back, coders! Up until now, you've been learning how to program. In this chapter, you'll learn how to program like a professional. We're talking about the habits, tools, and practices that real software engineers use every single day. These skills will take your code from \"it works on my machine\" to \"it works everywhere, and anyone can read it.\" Let's level up!</p>"},{"location":"chapters/16-software-engineering/#what-is-software-development","title":"What Is Software Development?","text":"<p>Writing a program isn't just about typing code until it works. Software development is the entire process of creating software \u2014 from figuring out what problem you're solving, to planning your approach, writing the code, testing it, and maintaining it over time.</p> <p>Think of it like building a house. You wouldn't start hammering nails without a blueprint, right? You'd figure out what kind of house you need, draw up plans, gather materials, build it step by step, and then inspect the result. Software development works the same way.</p> <p>Professional developers follow a structured process called the software development lifecycle (SDLC). Here are the key stages:</p> Stage What Happens House Analogy Planning Define what the software should do Decide you need a 3-bedroom house Analysis Gather detailed requirements Figure out room sizes, budget, materials Design Plan the architecture and structure Draw blueprints and floor plans Implementation Write the actual code Build the house Testing Check that everything works Home inspection Maintenance Fix bugs and add features over time Repairs, renovations <p>You don't need to memorize every formal methodology (there are many!), but understanding that coding is just one part of a bigger process will make you a much stronger developer.</p>"},{"location":"chapters/16-software-engineering/#program-planning-and-requirements","title":"Program Planning and Requirements","text":""},{"location":"chapters/16-software-engineering/#program-planning","title":"Program Planning","text":"<p>Before you write a single line of code, you should have a plan. Program planning means deciding what your program needs to do, how you'll structure it, and what tools or techniques you'll use.</p> <p>Here's a simple planning checklist you can use for any project:</p> <ol> <li>What problem am I solving? (Write it in one sentence.)</li> <li>What inputs will my program need?</li> <li>What outputs should it produce?</li> <li>What are the main steps? (Think algorithms and decomposition.)</li> <li>What data structures will I use? (Lists? Dictionaries? Classes?)</li> <li>How will I organize my code? (Functions? Modules? Multiple files?)</li> </ol> <p>Even for small assignments, taking five minutes to plan can save you hours of confused debugging later.</p>"},{"location":"chapters/16-software-engineering/#requirements-analysis","title":"Requirements Analysis","text":"<p>Requirements analysis is the process of figuring out exactly what the software needs to do \u2014 before you start building it. In a professional setting, this often means talking to the people who will actually use the software (called stakeholders) and writing down what they need.</p> <p>For a school project, requirements analysis might look like this:</p> <p>Project: Grade calculator</p> <p>Requirements:</p> <ul> <li>Accept a list of assignment scores from the user</li> <li>Calculate the average score</li> <li>Assign a letter grade (A, B, C, D, F) based on the average</li> <li>Display the result in a friendly format</li> <li>Handle invalid inputs without crashing</li> </ul> <p>Notice how each requirement is specific and testable. \"Make a cool grade thing\" is not a good requirement. \"Calculate the average of a list of scores and assign a letter grade\" \u2014 that's a requirement you can actually build and verify.</p> MicroSim: Software Development Lifecycle"},{"location":"chapters/16-software-engineering/#diagram-software-development-lifecycle","title":"Diagram: Software Development Lifecycle","text":"<p>Type: infographic sim-id: sdlc-stages Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: describe, sequence</p> <p>Learning Objective: Students will be able to identify and describe the six stages of the software development lifecycle and explain how they relate to each other.</p> <p>Purpose: An interactive circular diagram showing the six SDLC stages arranged in a cycle. Students can click each stage to reveal its description, key activities, and a real-world analogy.</p> <p>Layout: - Six nodes arranged in a circle: Planning, Analysis, Design, Implementation, Testing, Maintenance - Arrows connecting each node to the next in clockwise order - A center area that displays details when a node is clicked</p> <p>Interactive elements: - Click any stage node to highlight it and display its description in the center - Hover to see a brief tooltip with the stage name and one-sentence summary - An \"Auto Tour\" button cycles through all stages with a 2-second delay</p> <p>Color scheme: Each stage gets a distinct color \u2014 blue, purple, green, orange, red, teal Responsive: Circle resizes proportionally with window</p> <p>Instructional Rationale: The circular layout reinforces that software development is an ongoing cycle, not a one-time linear process. Click-to-reveal supports the Understand level by letting students explore each stage at their own pace.</p>"},{"location":"chapters/16-software-engineering/#organizing-your-code-like-a-pro","title":"Organizing Your Code Like a Pro","text":"<p>As your programs get bigger, keeping everything in one giant file becomes a nightmare. Imagine writing a 1,000-line program where all the functions, variables, and logic are jumbled together. Finding anything would be like searching for a specific grain of sand on a beach.</p>"},{"location":"chapters/16-software-engineering/#code-organization","title":"Code Organization","text":"<p>Code organization is the practice of structuring your code so it's easy to read, navigate, and maintain. Good organization means:</p> <ul> <li>Related code lives together \u2014 All the functions for handling user input go in one place; all the functions for calculations go in another.</li> <li>Each piece has one job \u2014 A function should do one thing and do it well.</li> <li>Names are descriptive \u2014 Variable names like <code>student_grade</code> beat <code>x</code> every time.</li> </ul> <p>Here's an example of poorly organized code versus well-organized code:</p> <pre><code># BAD: Everything mashed together, unclear names\ndef f(a):\n    t = 0\n    for i in a:\n        t += i\n    return t / len(a)\n\nx = [85, 92, 78, 95, 88]\nr = f(x)\nif r &gt;= 90: g = \"A\"\nelif r &gt;= 80: g = \"B\"\nelif r &gt;= 70: g = \"C\"\nelif r &gt;= 60: g = \"D\"\nelse: g = \"F\"\nprint(g)\n</code></pre> <pre><code># GOOD: Clear names, separated concerns, readable\ndef calculate_average(scores):\n    \"\"\"Return the average of a list of numeric scores.\"\"\"\n    total = sum(scores)\n    return total / len(scores)\n\ndef assign_letter_grade(average):\n    \"\"\"Return a letter grade based on the numeric average.\"\"\"\n    if average &gt;= 90:\n        return \"A\"\n    elif average &gt;= 80:\n        return \"B\"\n    elif average &gt;= 70:\n        return \"C\"\n    elif average &gt;= 60:\n        return \"D\"\n    else:\n        return \"F\"\n\n# Main program\nscores = [85, 92, 78, 95, 88]\naverage = calculate_average(scores)\ngrade = assign_letter_grade(average)\nprint(f\"Average: {average:.1f} \u2014 Grade: {grade}\")\n</code></pre> <p>Both programs produce the same result, but the second one is dramatically easier to read, understand, and modify.</p>"},{"location":"chapters/16-software-engineering/#modular-design","title":"Modular Design","text":"<p>Modular design means breaking your program into separate, self-contained pieces (called modules) that each handle one part of the problem. It's like building with LEGO bricks \u2014 each brick is a complete, independent unit, and you can snap them together in different combinations.</p> <p>Modular design has huge benefits:</p> <ul> <li>Easier to understand \u2014 You can focus on one module at a time instead of the whole program.</li> <li>Easier to test \u2014 You can test each module independently.</li> <li>Easier to reuse \u2014 A well-designed module can be used in multiple projects.</li> <li>Easier to maintain \u2014 Fixing a bug in one module doesn't break the others.</li> </ul> <p>Monty says: You've got this!</p> <p> Think of modular design like organizing a kitchen. You've got a drawer for utensils, a cabinet for plates, a pantry for food. Everything has its place. When you need a fork, you go straight to the utensil drawer \u2014 you don't rummage through a giant pile of everything. Your code should work the same way!</p>"},{"location":"chapters/16-software-engineering/#python-modules-and-packages","title":"Python Modules and Packages","text":""},{"location":"chapters/16-software-engineering/#import-statements","title":"Import Statements","text":"<p>You've actually been using modules since early in this course. Every time you write <code>import random</code> or <code>from math import sqrt</code>, you're pulling in code from an external module. An import statement tells Python, \"Hey, I need to use some code from another file. Please load it up for me.\"</p> <p>There are several ways to import:</p> <pre><code># Import the entire module\nimport math\nprint(math.pi)         # 3.141592653589793\nprint(math.sqrt(16))   # 4.0\n\n# Import specific items from a module\nfrom math import pi, sqrt\nprint(pi)              # 3.141592653589793\nprint(sqrt(16))        # 4.0\n\n# Import with a shorter alias\nimport matplotlib.pyplot as plt\nplt.plot([1, 2, 3], [4, 5, 6])\n</code></pre>"},{"location":"chapters/16-software-engineering/#python-modules","title":"Python Modules","text":"<p>A Python module is simply a <code>.py</code> file that contains Python code \u2014 functions, classes, variables, or anything else. When you write a Python file, you've already created a module! You can import it from other files and reuse its code.</p> <p>Let's create a simple module. Save this as <code>geometry.py</code>:</p> <pre><code># geometry.py \u2014 A module for geometry calculations\n\ndef area_of_circle(radius):\n    \"\"\"Calculate the area of a circle.\"\"\"\n    import math\n    return math.pi * radius ** 2\n\ndef area_of_rectangle(width, height):\n    \"\"\"Calculate the area of a rectangle.\"\"\"\n    return width * height\n\ndef perimeter_of_rectangle(width, height):\n    \"\"\"Calculate the perimeter of a rectangle.\"\"\"\n    return 2 * (width + height)\n</code></pre> <p>Now, in another file, you can import and use it:</p> <pre><code># main.py \u2014 Uses the geometry module\nimport geometry\n\ncircle_area = geometry.area_of_circle(5)\nprint(f\"Circle area: {circle_area:.2f}\")\n\nrect_area = geometry.area_of_rectangle(4, 7)\nprint(f\"Rectangle area: {rect_area}\")\n</code></pre> <p>Just like that, you've separated your concerns. The geometry calculations live in one file, and the main program logic lives in another.</p>"},{"location":"chapters/16-software-engineering/#python-packages","title":"Python Packages","text":"<p>A Python package is a collection of related modules organized in a folder. The folder must contain a special file called <code>__init__.py</code> (which can be empty) to tell Python \"this folder is a package.\"</p> <p>Here's what a package structure looks like:</p> <pre><code>my_project/\n\u251c\u2500\u2500 main.py\n\u2514\u2500\u2500 shapes/\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 circles.py\n    \u251c\u2500\u2500 rectangles.py\n    \u2514\u2500\u2500 triangles.py\n</code></pre> <p>You can then import from the package like this:</p> <pre><code>from shapes.circles import area_of_circle\nfrom shapes.rectangles import area_of_rectangle\n</code></pre> <p>Packages help you organize larger projects into logical groups. As your programs grow, you'll appreciate having this structure.</p> MicroSim: Module and Package Structure Explorer"},{"location":"chapters/16-software-engineering/#diagram-module-and-package-structure","title":"Diagram: Module and Package Structure","text":"<p>Type: diagram sim-id: module-package-explorer Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: explain, organize</p> <p>Learning Objective: Students will be able to distinguish between Python modules and packages, and explain how import statements connect them.</p> <p>Purpose: An interactive file-tree diagram showing the relationship between modules, packages, and import statements. Students click on import statements to see which files are loaded and how Python resolves them.</p> <p>Layout: - Left panel: A file tree showing a project with a main.py file and a shapes/ package containing multiple modules - Right panel: Code editor showing the import statements and their resolved targets - Animated arrows show the connection between an import statement and the file it loads</p> <p>Interactive elements: - Click any import statement to highlight the target file in the tree - Click any file in the tree to see its contents in the code panel - Toggle between \"flat module\" and \"package\" views to compare the two structures</p> <p>Instructional Rationale: Visual file-tree navigation makes the abstract concept of imports concrete by showing students exactly which files Python loads when they write an import statement.</p>"},{"location":"chapters/16-software-engineering/#the-pip-package-manager","title":"The Pip Package Manager","text":"<p>Python comes with a lot of built-in modules (called the standard library), but thousands more are available from the Python community. The pip package manager is the tool you use to install these third-party packages.</p> <p>Think of pip as an app store for Python. Need to make charts? Install <code>matplotlib</code>. Need to build a website? Install <code>flask</code>. Need to work with data? Install <code>pandas</code>.</p> <p>Here are the most common pip commands:</p> <pre><code># Install a package\npip install requests\n\n# Install a specific version\npip install requests==2.31.0\n\n# Upgrade a package to the latest version\npip install --upgrade requests\n\n# See what's installed\npip list\n\n# Uninstall a package\npip uninstall requests\n\n# Save all installed packages to a file\npip freeze &gt; requirements.txt\n\n# Install all packages from a requirements file\npip install -r requirements.txt\n</code></pre> <p>That last pair of commands (<code>freeze</code> and <code>-r</code>) is especially useful. A <code>requirements.txt</code> file lists every package your project needs. When someone else wants to run your code, they just run <code>pip install -r requirements.txt</code> and everything gets installed automatically. No guessing required.</p>"},{"location":"chapters/16-software-engineering/#virtual-environments","title":"Virtual Environments","text":"<p>Here's a problem: what if Project A needs version 1.0 of a library, but Project B needs version 2.0? If you install everything globally, one project will break.</p> <p>The solution is virtual environments. A virtual environment is an isolated Python setup for a specific project. Each virtual environment has its own copy of Python and its own installed packages, completely separate from everything else on your computer.</p> <pre><code># Create a virtual environment called \"venv\"\npython -m venv venv\n\n# Activate it (macOS/Linux)\nsource venv/bin/activate\n\n# Activate it (Windows)\nvenv\\Scripts\\activate\n\n# Now pip installs go into THIS environment only\npip install requests\n\n# When you're done, deactivate\ndeactivate\n</code></pre> <p>When a virtual environment is active, you'll usually see its name in parentheses at the beginning of your terminal prompt: <code>(venv) $</code>. That's your reminder that you're working in an isolated environment.</p> <p>Monty says: Let's debug this together!</p> <p> Always create a virtual environment for each project. It keeps your projects from stepping on each other's toes. Think of it like having a separate backpack for each class \u2014 your math notes don't get mixed up with your history papers!</p>"},{"location":"chapters/16-software-engineering/#version-control-with-git","title":"Version Control with Git","text":""},{"location":"chapters/16-software-engineering/#why-version-control","title":"Why Version Control?","text":"<p>Have you ever worked on an essay and saved files like <code>essay_v1.docx</code>, <code>essay_v2.docx</code>, <code>essay_FINAL.docx</code>, <code>essay_FINAL_REALLY_FINAL.docx</code>? Yeah, that gets messy fast.</p> <p>Version control is a system that tracks every change you make to your code over time. Instead of saving multiple copies, you save snapshots (called commits) that record exactly what changed, when, and why. If something breaks, you can go back to any previous snapshot.</p> <p>Version control also makes teamwork possible. Multiple people can work on the same codebase without overwriting each other's work. It's an absolutely essential tool in professional software development.</p>"},{"location":"chapters/16-software-engineering/#git-basics","title":"Git Basics","text":"<p>Git is the most popular version control system in the world. It was created in 2005 by Linus Torvalds (the same person who created Linux) because he needed a fast, reliable way to track changes to the Linux kernel \u2014 a massive codebase with thousands of contributors.</p> <p>Let's walk through the essential Git commands. You'll run these in your terminal (also called the command line).</p> <p>Setting up a new Git repository:</p> <pre><code># Navigate to your project folder\ncd my_project\n\n# Initialize a new Git repository\ngit init\n</code></pre> <p>That <code>git init</code> command creates a hidden <code>.git</code> folder that stores all the version history. Your project folder is now a repository (or \"repo\" for short).</p> <p>The Git workflow:</p> <p>Git has a three-stage workflow:</p> <ol> <li>Working directory \u2014 Where you edit files normally</li> <li>Staging area \u2014 Where you prepare changes for a commit</li> <li>Repository \u2014 Where committed snapshots are stored permanently</li> </ol> <p>Here's how you move changes through these stages:</p> <pre><code># Check the status of your files\ngit status\n\n# Add a specific file to the staging area\ngit add geometry.py\n\n# Add all changed files to the staging area\ngit add .\n\n# Commit the staged changes with a message\ngit commit -m \"Add geometry module with circle and rectangle functions\"\n\n# View the history of commits\ngit log\n</code></pre> <p>Let's break down what each command does:</p> Command What It Does Analogy <code>git init</code> Creates a new repository Opening a new photo album <code>git status</code> Shows which files have changed Checking which photos are on the table <code>git add</code> Stages files for the next commit Picking which photos to put in the album <code>git commit -m \"...\"</code> Saves a snapshot with a message Gluing the photos in and writing a caption <code>git log</code> Shows the history of all commits Flipping through the album pages <p>Writing good commit messages:</p> <p>Your commit messages should explain what changed and why. Compare:</p> <pre><code># BAD commit messages\ngit commit -m \"stuff\"\ngit commit -m \"fixed it\"\ngit commit -m \"changes\"\n\n# GOOD commit messages\ngit commit -m \"Add input validation to grade calculator\"\ngit commit -m \"Fix crash when user enters empty string\"\ngit commit -m \"Refactor area functions into geometry module\"\n</code></pre> <p>Good commit messages are a gift to your future self. When you look back at your project six months from now, you'll be glad you wrote \"Fix crash when user enters empty string\" instead of \"stuff.\"</p> MicroSim: Git Workflow Visualizer"},{"location":"chapters/16-software-engineering/#diagram-git-workflow-visualizer","title":"Diagram: Git Workflow Visualizer","text":"<p>Type: microsim sim-id: git-workflow-visualizer Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: describe, trace</p> <p>Learning Objective: Students will be able to trace the movement of files through Git's three-stage workflow (working directory, staging area, repository) and explain the purpose of each Git command.</p> <p>Purpose: An interactive animation showing how files move through Git's three stages as students type simulated Git commands.</p> <p>Layout: - Three horizontal zones representing: Working Directory, Staging Area, Repository - File icons that move between zones when commands are executed - A simulated terminal at the bottom where students click pre-built Git commands</p> <p>Interactive elements: - Click buttons for: <code>git add</code>, <code>git commit</code>, <code>git status</code>, <code>git log</code> - File icons animate from one zone to the next when the corresponding command runs - <code>git status</code> highlights which files are in which zone - <code>git log</code> shows a scrollable list of previous commits</p> <p>Color scheme: Working directory (blue), Staging area (yellow), Repository (green)</p> <p>Instructional Rationale: The three-zone layout directly maps to Git's conceptual model. Animating file movement makes the abstract staging process visible and concrete, helping students build an accurate mental model before using Git on the command line.</p>"},{"location":"chapters/16-software-engineering/#writing-clean-code","title":"Writing Clean Code","text":""},{"location":"chapters/16-software-engineering/#code-style","title":"Code Style","text":"<p>Have you ever tried to read someone else's handwriting and given up because it was too messy? Code can be the same way. Code style refers to the conventions you follow when formatting your code \u2014 things like indentation, spacing, naming, and line length.</p> <p>Consistent code style matters because code is read far more often than it's written. If everyone on a team uses different styles, the codebase becomes a patchwork that's hard to read. That's why most programming languages have style guides.</p>"},{"location":"chapters/16-software-engineering/#pep-8-guidelines","title":"PEP 8 Guidelines","text":"<p>Python's official style guide is called PEP 8 (Python Enhancement Proposal 8). It was written by Guido van Rossum himself, and it's the standard that almost all Python developers follow.</p> <p>Here are the most important PEP 8 rules:</p> Rule Example Use 4 spaces for indentation (not tabs) <code>if x &gt; 0:</code> Limit lines to 79 characters Keep it readable without scrolling Use <code>snake_case</code> for function and variable names <code>calculate_average</code>, <code>student_name</code> Use <code>PascalCase</code> for class names <code>GradeCalculator</code>, <code>Student</code> Use <code>ALL_CAPS</code> for constants <code>MAX_SCORE = 100</code>, <code>PI = 3.14159</code> Put spaces around operators <code>x = 5 + 3</code> not <code>x=5+3</code> Put two blank lines before function/class definitions Gives visual breathing room Use docstrings for functions and classes <code>\"\"\"Calculate the average score.\"\"\"</code> <p>Here's a quick before-and-after showing PEP 8 in action:</p> <pre><code># BEFORE: Violates PEP 8\ndef CalcGrade(s):\n    t=0\n    for i in s:t+=i\n    avg=t/len(s)\n    if avg&gt;=90:return \"A\"\n    elif avg&gt;=80:return \"B\"\n    elif avg&gt;=70:return \"C\"\n    elif avg&gt;=60:return \"D\"\n    else:return \"F\"\n</code></pre> <pre><code># AFTER: Follows PEP 8\ndef calculate_grade(scores):\n    \"\"\"Calculate a letter grade from a list of scores.\"\"\"\n    total = 0\n    for score in scores:\n        total += score\n    average = total / len(scores)\n\n    if average &gt;= 90:\n        return \"A\"\n    elif average &gt;= 80:\n        return \"B\"\n    elif average &gt;= 70:\n        return \"C\"\n    elif average &gt;= 60:\n        return \"D\"\n    else:\n        return \"F\"\n</code></pre> <p>The second version is longer but dramatically easier to read. In professional development, readability always wins.</p>"},{"location":"chapters/16-software-engineering/#linting-tools","title":"Linting Tools","text":"<p>Checking your code style by hand is tedious. That's where linting tools come in. A linter is a program that automatically analyzes your code and flags style violations, potential errors, and other issues.</p> <p>Popular Python linters include:</p> <ul> <li>flake8 \u2014 Checks PEP 8 compliance and catches common errors</li> <li>pylint \u2014 A more thorough (and sometimes opinionated) linter</li> <li>black \u2014 An auto-formatter that fixes your style automatically</li> <li>ruff \u2014 A blazing-fast modern linter written in Rust</li> </ul> <p>Here's how to use flake8:</p> <pre><code># Install flake8\npip install flake8\n\n# Run it on your file\nflake8 my_program.py\n\n# Sample output:\n# my_program.py:3:1: E302 expected 2 blank lines, found 1\n# my_program.py:7:12: E225 missing whitespace around operator\n# my_program.py:15:80: E501 line too long (95 &gt; 79 characters)\n</code></pre> <p>Each message tells you the file, line number, column, error code, and a description. Most code editors (like VS Code) can run a linter automatically as you type, highlighting problems with a colored squiggly line \u2014 just like spell check for your code.</p>"},{"location":"chapters/16-software-engineering/#design-principles-dry-and-kiss","title":"Design Principles: DRY and KISS","text":"<p>Two of the most important principles in software engineering fit neatly into acronyms that are easy to remember.</p>"},{"location":"chapters/16-software-engineering/#the-dry-principle","title":"The DRY Principle","text":"<p>DRY stands for Don't Repeat Yourself. The DRY principle says that every piece of knowledge in your code should exist in exactly one place. If you find yourself copying and pasting the same block of code, that's a sign you should extract it into a function.</p> <p>Here's an example:</p> <pre><code># VIOLATES DRY \u2014 the same calculation appears three times\nmath_total = 0\nfor score in math_scores:\n    math_total += score\nmath_average = math_total / len(math_scores)\n\nscience_total = 0\nfor score in science_scores:\n    science_total += score\nscience_average = science_total / len(science_scores)\n\nenglish_total = 0\nfor score in english_scores:\n    english_total += score\nenglish_average = english_total / len(english_scores)\n</code></pre> <pre><code># FOLLOWS DRY \u2014 write the logic once, use it three times\ndef calculate_average(scores):\n    \"\"\"Return the average of a list of scores.\"\"\"\n    total = sum(scores)\n    return total / len(scores)\n\nmath_average = calculate_average(math_scores)\nscience_average = calculate_average(science_scores)\nenglish_average = calculate_average(english_scores)\n</code></pre> <p>The DRY version is shorter, easier to read, and \u2014 here's the big one \u2014 if you ever need to change how averages are calculated, you only change it in one place. With the non-DRY version, you'd have to find and update three separate blocks, and you'd probably miss one.</p>"},{"location":"chapters/16-software-engineering/#the-kiss-principle","title":"The KISS Principle","text":"<p>KISS stands for Keep It Simple, Silly (or sometimes \"Keep It Simple, Stupid,\" but we'll keep it friendly). The KISS principle says you should always choose the simplest solution that works.</p> <p>New programmers sometimes overcomplicate things because they want to seem \"advanced.\" But experienced developers know that simple code is better code. Simple code has fewer bugs, is easier to understand, and is easier to change.</p> <pre><code># OVERCOMPLICATED \u2014 trying too hard\ndef is_even(number):\n    \"\"\"Check if a number is even.\"\"\"\n    binary_representation = bin(number)\n    last_bit = binary_representation[-1]\n    if last_bit == '0':\n        return True\n    else:\n        return False\n</code></pre> <pre><code># KISS \u2014 simple and clear\ndef is_even(number):\n    \"\"\"Check if a number is even.\"\"\"\n    return number % 2 == 0\n</code></pre> <p>Both functions work, but the KISS version is one line instead of six. It's immediately obvious what it does. When you're tempted to write something clever, ask yourself: \"Is there a simpler way?\"</p> <p>Monty says: Watch out!</p> <p> Beware of \"clever\" code! If you have to read a line three times to understand it, it's too clever. Future-you (and your teammates) will thank you for keeping things simple. Remember: code is read ten times more than it's written.</p> MicroSim: DRY vs. WET Code Comparison"},{"location":"chapters/16-software-engineering/#diagram-dry-vs-wet-code-comparison","title":"Diagram: DRY vs. WET Code Comparison","text":"<p>Type: microsim sim-id: dry-vs-wet-code Library: p5.js Status: Specified</p> <p>Bloom Level: Analyze (L4) Bloom Verb: compare, distinguish</p> <p>Learning Objective: Students will be able to identify code that violates the DRY principle and explain how to refactor it using functions.</p> <p>Purpose: A side-by-side code comparison tool that shows \"WET\" (Write Everything Twice) code on one side and the refactored DRY version on the other. Identical repeated blocks are highlighted to make the duplication visually obvious.</p> <p>Layout: - Left panel labeled \"WET Code (repetitive)\" showing code with duplicated blocks - Right panel labeled \"DRY Code (refactored)\" showing the same logic extracted into a reusable function - Duplicated blocks on the left are highlighted in red - The single function definition on the right is highlighted in green - A metrics bar at the bottom showing lines of code and number of duplicate blocks for each version</p> <p>Interactive elements: - Click \"Next Example\" to cycle through 3 different WET-to-DRY transformations - Hover over duplicated blocks to see them pulse simultaneously, showing they are copies of each other - A \"Lines of Code\" counter animates to show the reduction</p> <p>Instructional Rationale: Visual highlighting of duplicated blocks makes the DRY violation immediately obvious. The side-by-side layout lets students directly compare approaches. Multiple examples reinforce that DRY applies across many situations.</p>"},{"location":"chapters/16-software-engineering/#refactoring-your-code","title":"Refactoring Your Code","text":"<p>Refactoring is the process of improving your code's structure without changing what it does. It's like remodeling a house \u2014 you might move walls and redesign the kitchen, but it's still the same house at the same address.</p> <p>Why refactor? Because your first working version is rarely your best version. Code evolves. What seemed fine when you wrote 50 lines might become confusing at 500 lines. Refactoring keeps your codebase healthy as it grows.</p> <p>Here are common refactoring techniques:</p> <p>1. Extract a function \u2014 Pull repeated or complex code into its own function.</p> <pre><code># BEFORE: Logic mixed into main code\nname = input(\"Enter name: \").strip()\nif len(name) == 0:\n    print(\"Error: Name cannot be empty.\")\n    name = input(\"Enter name: \").strip()\n\nage = input(\"Enter age: \").strip()\nif len(age) == 0:\n    print(\"Error: Age cannot be empty.\")\n    age = input(\"Enter age: \").strip()\n</code></pre> <pre><code># AFTER: Extracted into a reusable function\ndef get_required_input(prompt):\n    \"\"\"Keep asking until the user provides a non-empty value.\"\"\"\n    value = input(prompt).strip()\n    while len(value) == 0:\n        print(\"Error: This field cannot be empty.\")\n        value = input(prompt).strip()\n    return value\n\nname = get_required_input(\"Enter name: \")\nage = get_required_input(\"Enter age: \")\n</code></pre> <p>2. Rename for clarity \u2014 Replace vague names with descriptive ones.</p> <pre><code># BEFORE\ndef proc(d):\n    r = {}\n    for k, v in d.items():\n        if v &gt; 50:\n            r[k] = v\n    return r\n\n# AFTER\ndef filter_high_scores(scores_dict):\n    \"\"\"Return only scores above 50.\"\"\"\n    high_scores = {}\n    for student, score in scores_dict.items():\n        if score &gt; 50:\n            high_scores[student] = score\n    return high_scores\n</code></pre> <p>3. Simplify conditionals \u2014 Flatten nested if/else blocks.</p> <pre><code># BEFORE: Deeply nested\ndef get_ticket_price(age, is_student):\n    if age &lt; 12:\n        return 5.00\n    else:\n        if age &gt;= 65:\n            return 7.00\n        else:\n            if is_student:\n                return 8.00\n            else:\n                return 12.00\n\n# AFTER: Flat and clear using early returns\ndef get_ticket_price(age, is_student):\n    \"\"\"Return the ticket price based on age and student status.\"\"\"\n    if age &lt; 12:\n        return 5.00\n    if age &gt;= 65:\n        return 7.00\n    if is_student:\n        return 8.00\n    return 12.00\n</code></pre> <p>The refactored version reads like a checklist \u2014 easy to follow, easy to modify.</p>"},{"location":"chapters/16-software-engineering/#comments-and-documentation","title":"Comments and Documentation","text":""},{"location":"chapters/16-software-engineering/#code-comments","title":"Code Comments","text":"<p>Code comments are notes you write in your code to explain why something is done a certain way. In Python, comments start with a <code>#</code> symbol.</p> <pre><code># Calculate the average (excluding the lowest score)\nscores.sort()\nadjusted_scores = scores[1:]  # Drop the first (lowest) score\naverage = sum(adjusted_scores) / len(adjusted_scores)\n</code></pre> <p>Rules for good comments:</p> <ul> <li>Comment the \"why,\" not the \"what.\" Your code already shows what it does. Comments should explain why you made a particular choice.</li> <li>Don't state the obvious. <code>x = 5  # Set x to 5</code> \u2014 that comment adds nothing.</li> <li>Keep comments up to date. A comment that contradicts the code is worse than no comment at all.</li> <li>Use comments to explain tricky logic. If a section of code requires a moment of thought to understand, add a comment.</li> </ul> <pre><code># BAD comments (state the obvious)\nx = x + 1  # Increment x by 1\nnames = []  # Create an empty list\n\n# GOOD comments (explain the why)\nx = x + 1  # Account for zero-based indexing in the display\nnames = []  # Will be populated from the CSV file in the next section\n</code></pre>"},{"location":"chapters/16-software-engineering/#documentation","title":"Documentation","text":"<p>Documentation goes beyond individual comments. It's the big-picture explanation of what your code does, how to use it, and how it's organized. In Python, the main tool for documentation is the docstring \u2014 a string at the beginning of a module, class, or function that describes its purpose.</p> <pre><code>def celsius_to_fahrenheit(celsius):\n    \"\"\"Convert a temperature from Celsius to Fahrenheit.\n\n    Args:\n        celsius: A numeric temperature in degrees Celsius.\n\n    Returns:\n        The equivalent temperature in degrees Fahrenheit.\n\n    Example:\n        &gt;&gt;&gt; celsius_to_fahrenheit(100)\n        212.0\n        &gt;&gt;&gt; celsius_to_fahrenheit(0)\n        32.0\n    \"\"\"\n    return celsius * 9 / 5 + 32\n</code></pre> <p>Docstrings are special because Python can actually read them at runtime. If someone types <code>help(celsius_to_fahrenheit)</code> in the interpreter, Python displays your docstring. It's like a built-in manual for every function you write.</p> <p>For larger projects, documentation might also include:</p> <ul> <li>A README file explaining what the project does and how to install it</li> <li>A requirements.txt listing all dependencies</li> <li>Inline comments for tricky sections</li> <li>Docstrings for every public function and class</li> </ul> MicroSim: Comment Quality Checker"},{"location":"chapters/16-software-engineering/#diagram-comment-quality-checker","title":"Diagram: Comment Quality Checker","text":"<p>Type: microsim sim-id: comment-quality-checker Library: p5.js Status: Specified</p> <p>Bloom Level: Evaluate (L5) Bloom Verb: assess, judge</p> <p>Learning Objective: Students will be able to evaluate the quality of code comments and distinguish between helpful comments (explaining \"why\") and unhelpful comments (stating \"what\").</p> <p>Purpose: An interactive quiz where students are shown code snippets with comments and must rate each comment as \"Helpful,\" \"Unhelpful,\" or \"Missing.\"</p> <p>Layout: - Top area: A code snippet with a highlighted comment - Middle area: Three clickable buttons \u2014 \"Helpful (explains why)\", \"Unhelpful (states the obvious)\", \"Missing (needs a comment)\" - Bottom area: Score tracker and feedback message</p> <p>Interactive elements: - Click a rating button to submit your answer - Immediate feedback explains why the comment is good, bad, or missing - Score tracker shows correct answers out of total questions - 8 questions covering common comment patterns</p> <p>Instructional Rationale: Evaluating existing comments is a higher-order skill that prepares students to write better comments themselves. Immediate feedback reinforces the \"comment the why, not the what\" principle.</p>"},{"location":"chapters/16-software-engineering/#the-if-__name__-__main__-pattern","title":"The <code>if __name__ == \"__main__\"</code> Pattern","text":"<p>This is one of those Python patterns that looks confusing the first time you see it, but once you understand it, you'll use it all the time.</p>"},{"location":"chapters/16-software-engineering/#name-equals-main","title":"Name Equals Main","text":"<p>When Python runs a file, it sets a special variable called <code>__name__</code>. If the file is being run directly (like <code>python my_file.py</code>), then <code>__name__</code> is set to <code>\"__main__\"</code>. But if the file is being imported by another file, <code>__name__</code> is set to the module's name instead.</p> <p>The <code>if __name__ == \"__main__\"</code> pattern (often called name equals main) lets you write code that only runs when the file is executed directly \u2014 not when it's imported.</p> <p>Here's why that matters. Let's say you have a module called <code>geometry.py</code>:</p> <pre><code># geometry.py\n\ndef area_of_circle(radius):\n    \"\"\"Calculate the area of a circle.\"\"\"\n    import math\n    return math.pi * radius ** 2\n\n# Test code\nprint(\"Testing area_of_circle...\")\nprint(f\"Area with radius 5: {area_of_circle(5):.2f}\")\n</code></pre> <p>If you run <code>python geometry.py</code>, you'll see the test output \u2014 great! But if another file does <code>import geometry</code>, those print statements will run too, cluttering the output. Not great.</p> <p>Here's the fix:</p> <pre><code># geometry.py\n\ndef area_of_circle(radius):\n    \"\"\"Calculate the area of a circle.\"\"\"\n    import math\n    return math.pi * radius ** 2\n\nif __name__ == \"__main__\":\n    # This code ONLY runs when you execute geometry.py directly\n    print(\"Testing area_of_circle...\")\n    print(f\"Area with radius 5: {area_of_circle(5):.2f}\")\n</code></pre> <p>Now the test code only runs when you execute <code>python geometry.py</code> directly. When another file does <code>import geometry</code>, the test code is skipped.</p> <p>Think of it like a sign on a door: \"Test area \u2014 employees only.\" The code inside the <code>if __name__ == \"__main__\"</code> block is only for direct execution, not for imports.</p> <p>Monty says: You've got this!</p> <p> The <code>if __name__ == \"__main__\"</code> pattern might look weird at first, but every Python developer uses it. Once you get the hang of it, you'll put it at the bottom of every module you write. It's a mark of a thoughtful programmer!</p> MicroSim: Name Equals Main Simulator"},{"location":"chapters/16-software-engineering/#diagram-name-equals-main-simulator","title":"Diagram: Name Equals Main Simulator","text":"<p>Type: microsim sim-id: name-equals-main Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: demonstrate, predict</p> <p>Learning Objective: Students will be able to predict which code blocks execute when a Python file is run directly versus when it is imported as a module.</p> <p>Purpose: An interactive simulation where students see two Python files and can toggle between \"Run Directly\" and \"Import\" modes to observe which lines of code execute in each scenario.</p> <p>Layout: - Left panel: The module file (e.g., <code>geometry.py</code>) with line numbers and a <code>if __name__ == \"__main__\"</code> block - Right panel: An importing file (e.g., <code>main.py</code>) that does <code>import geometry</code> - Bottom panel: Console output showing which lines ran - Toggle switch: \"Run geometry.py directly\" vs. \"Import from main.py\"</p> <p>Interactive elements: - Toggle between direct execution and import mode - Lines that execute are highlighted in green; lines that are skipped are grayed out - Console output updates in real-time - A \"Step Through\" button advances one line at a time with explanation</p> <p>Color scheme: Executed lines in green, skipped lines in gray, <code>__name__</code> variable value shown in gold</p> <p>Instructional Rationale: Directly comparing the two execution modes side-by-side makes the purpose of the <code>if __name__ == \"__main__\"</code> guard immediately clear. Stepping through one line at a time helps students build a correct mental model of Python's import and execution behavior.</p>"},{"location":"chapters/16-software-engineering/#putting-it-all-together-a-professional-project-structure","title":"Putting It All Together: A Professional Project Structure","text":"<p>Let's see what a well-organized Python project looks like when you combine everything from this chapter:</p> <pre><code>grade_calculator/\n\u251c\u2500\u2500 README.md                 # Project documentation\n\u251c\u2500\u2500 requirements.txt          # Package dependencies\n\u251c\u2500\u2500 .gitignore                # Files Git should ignore\n\u251c\u2500\u2500 venv/                     # Virtual environment (not committed to Git)\n\u251c\u2500\u2500 calculator/\n\u2502   \u251c\u2500\u2500 __init__.py           # Makes this a package\n\u2502   \u251c\u2500\u2500 grades.py             # Grade calculation module\n\u2502   \u2514\u2500\u2500 validation.py         # Input validation module\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 test_grades.py        # Tests for the grades module\n\u2514\u2500\u2500 main.py                   # Entry point for the program\n</code></pre> <p>This project uses:</p> <ul> <li>Modular design \u2014 Code is split into separate modules for grades and validation</li> <li>Packages \u2014 The <code>calculator/</code> folder is a Python package</li> <li>Virtual environments \u2014 Dependencies are isolated in <code>venv/</code></li> <li>Pip \u2014 Dependencies are tracked in <code>requirements.txt</code></li> <li>Git \u2014 Version control with <code>.gitignore</code> to exclude <code>venv/</code></li> <li>Documentation \u2014 A <code>README.md</code> explains the project</li> <li>Good style \u2014 All files follow PEP 8 conventions</li> </ul> <p>That structure might seem like overkill for a school project, but building these habits now means you'll be ready for the real-world projects ahead.</p> <p>Monty says: You've got this!</p> <p> Look at you \u2014 you've just learned the tools and practices that professional software engineers use every day! Version control, modular design, clean code style, documentation... you're not just writing code anymore, you're engineering software. That's a huge step forward, coder!</p>"},{"location":"chapters/16-software-engineering/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Software development is a structured process (planning, analysis, design, implementation, testing, maintenance) \u2014 not just coding.</li> <li>Program planning and requirements analysis help you figure out what to build before you start building.</li> <li>Modular design means breaking your program into independent, reusable pieces.</li> <li>Code organization keeps related code together and uses descriptive names.</li> <li>Import statements let you use code from Python modules (<code>.py</code> files) and Python packages (folders with <code>__init__.py</code>).</li> <li>The pip package manager installs third-party packages, and virtual environments isolate project dependencies.</li> <li>Version control tracks changes over time. Git uses <code>init</code>, <code>add</code>, <code>commit</code>, <code>status</code>, and <code>log</code> to manage your code history.</li> <li>Code style matters. PEP 8 is Python's official style guide, and linting tools like flake8 check your code automatically.</li> <li>Refactoring improves code structure without changing behavior.</li> <li>The DRY principle (Don't Repeat Yourself) says to avoid duplicated code. The KISS principle (Keep It Simple, Silly) says to choose the simplest solution.</li> <li>Code comments explain why (not what). Documentation (including docstrings) provides big-picture explanations.</li> <li>The <code>if __name__ == \"__main__\"</code> pattern lets your modules work both as standalone scripts and as importable libraries.</li> </ul> Check Your Understanding: What does the DRY principle stand for, and how would you fix a program that has the same ten lines of code copied in three different places? <p>DRY stands for Don't Repeat Yourself. To fix the program, you would extract those ten repeated lines into a single function, then call that function from all three places. This way, the logic lives in one place, and if you ever need to change it, you only update it once.</p> Check Your Understanding: You have a file called <code>helpers.py</code> with useful functions. When you run <code>python helpers.py</code>, it prints test output. When another file does <code>import helpers</code>, it also prints that test output. How do you fix this? <p>Wrap the test code inside an <code>if __name__ == \"__main__\":</code> block. Code inside this block only runs when <code>helpers.py</code> is executed directly (<code>python helpers.py</code>). When another file imports it, the block is skipped.</p> <pre><code># helpers.py\ndef greet(name):\n    return f\"Hello, {name}!\"\n\nif __name__ == \"__main__\":\n    # Only runs when executed directly\n    print(greet(\"Test\"))\n</code></pre> Check Your Understanding: What is the difference between <code>git add</code> and <code>git commit</code>? <p><code>git add</code> moves your changes to the staging area \u2014 it's like picking which photos to put in a photo album. <code>git commit</code> takes everything in the staging area and saves it as a permanent snapshot (a commit) in the repository \u2014 it's like gluing the photos in and writing a caption. You can <code>git add</code> multiple times before running a single <code>git commit</code>.</p>"},{"location":"chapters/17-testing-and-debugging/","title":"Testing and Debugging","text":""},{"location":"chapters/17-testing-and-debugging/#testing-and-debugging","title":"Testing and Debugging","text":""},{"location":"chapters/17-testing-and-debugging/#summary","title":"Summary","text":"<p>This chapter covers the essential practices of testing and debugging software. Students will learn manual and unit testing, how to write effective test cases and assertions, identify edge cases and boundary conditions, and practice test-driven development. The chapter also teaches debugging strategies including print debugging, using debugger tools with breakpoints, code tracing, and rubber duck debugging. Defensive programming and input validation techniques round out the quality assurance toolkit.</p>"},{"location":"chapters/17-testing-and-debugging/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 20 concepts from the learning graph:</p> <ol> <li>Testing</li> <li>Manual Testing</li> <li>Unit Testing</li> <li>Test Cases</li> <li>Assert Statements</li> <li>Unittest Module</li> <li>Test Functions</li> <li>Edge Cases</li> <li>Boundary Testing</li> <li>Test-Driven Development</li> <li>Debugging</li> <li>Print Debugging</li> <li>Debugger Tools</li> <li>Breakpoints</li> <li>Step Through Code</li> <li>Code Tracing</li> <li>Rubber Duck Debugging</li> <li>Defensive Programming</li> <li>Input Validation</li> <li>Code Review</li> </ol>"},{"location":"chapters/17-testing-and-debugging/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 1: Introduction to Computer Science</li> <li>Chapter 2: Python Fundamentals</li> <li>Chapter 4: Control Flow</li> <li>Chapter 6: Functions and Modular Design</li> <li>Chapter 14: Errors and Exceptions</li> <li>Chapter 16: Software Engineering Practices</li> </ul> <p>Monty says: Let's debug this together!</p> <p> Welcome back, coders! Every programmer \u2014 from beginners to experts at Google \u2014 writes code that has bugs. The difference between a novice and a pro isn't that pros write perfect code. It's that pros know how to find and fix problems systematically. In this chapter, you'll learn exactly how to do that. Bugs are not failures \u2014 they're puzzles to solve! Let's dive in.</p>"},{"location":"chapters/17-testing-and-debugging/#why-testing-matters","title":"Why Testing Matters","text":"<p>Imagine building a bridge and never checking whether it can hold any weight. That would be terrifying, right? Software works the same way. Testing is the process of running your code to check whether it actually does what you intended. Without testing, you're just hoping your program works \u2014 and hope is not a strategy.</p> <p>Testing helps you in three big ways:</p> <ul> <li>Catch bugs early. The sooner you find a mistake, the easier (and cheaper) it is to fix.</li> <li>Build confidence. When your tests pass, you know your code works \u2014 not just for one case, but for many.</li> <li>Enable change. Want to refactor your code or add a new feature? If you have good tests, you can make changes without worrying about accidentally breaking something.</li> </ul> <p>Professional software teams spend just as much time writing tests as they do writing the actual program. Let's learn why \u2014 and how.</p>"},{"location":"chapters/17-testing-and-debugging/#manual-testing","title":"Manual Testing","text":"<p>The simplest kind of testing is something you've been doing since your first Python program: running your code and checking the output with your own eyes. This is called manual testing.</p> <p>Manual testing means you run the program, feed it some inputs, and visually verify that the outputs are correct. For example, if you write a function that adds two numbers, you might call it with <code>add(2, 3)</code> and check that it returns <code>5</code>.</p> <pre><code>def add(a, b):\n    return a + b\n\n# Manual testing\nprint(add(2, 3))    # Should print 5\nprint(add(-1, 1))   # Should print 0\nprint(add(0, 0))    # Should print 0\n</code></pre> <p>Manual testing is a fine starting point, but it has some problems:</p> Limitation Why It's a Problem Slow You have to run the program and check results yourself every time Error-prone You might miss a wrong answer, especially if there's lots of output Not repeatable You can't easily re-run the exact same checks after changing code Not scalable Works for 3 tests, but what about 300? <p>For small scripts, manual testing can work. But as your programs grow, you need something better \u2014 something automated.</p>"},{"location":"chapters/17-testing-and-debugging/#unit-testing","title":"Unit Testing","text":"<p>Unit testing is the practice of writing small, automated tests that check whether individual pieces (or \"units\") of your code work correctly. A \"unit\" is usually a single function or method. Instead of you checking the output with your eyes, the computer checks it for you \u2014 automatically, instantly, and as many times as you want.</p> <p>Think of unit testing like a robot quality inspector on a factory assembly line. Every widget that comes off the line gets checked against a specification. If it passes, great \u2014 move on. If it fails, the inspector flags it immediately. Unit tests are your robot inspectors.</p> <p>Here's the basic idea: for each function you write, you also write one or more test functions that call your code with specific inputs and verify the outputs match your expectations.</p> <pre><code>def celsius_to_fahrenheit(celsius):\n    return celsius * 9/5 + 32\n\n# Unit tests (simple version)\ndef test_boiling_point():\n    result = celsius_to_fahrenheit(100)\n    assert result == 212, f\"Expected 212, got {result}\"\n\ndef test_freezing_point():\n    result = celsius_to_fahrenheit(0)\n    assert result == 32, f\"Expected 32, got {result}\"\n\ndef test_body_temperature():\n    result = celsius_to_fahrenheit(37)\n    assert result == 98.6, f\"Expected 98.6, got {result}\"\n\n# Run the tests\ntest_boiling_point()\ntest_freezing_point()\ntest_body_temperature()\nprint(\"All tests passed!\")\n</code></pre> <p>If all three tests run without raising an error, you see \"All tests passed!\" If any assertion fails, Python raises an <code>AssertionError</code> and tells you exactly what went wrong. That's the power of automated testing \u2014 instant, honest feedback.</p>"},{"location":"chapters/17-testing-and-debugging/#test-cases","title":"Test Cases","text":"<p>A test case is a specific scenario you design to verify one particular behavior of your code. Each test case has three parts:</p> <ol> <li>Setup \u2014 Prepare the inputs and any data your function needs</li> <li>Action \u2014 Call the function you're testing</li> <li>Assertion \u2014 Check that the result matches what you expected</li> </ol> <p>Good test cases cover different scenarios \u2014 not just the \"happy path\" where everything goes right, but also unusual or tricky inputs. Here's an example with a function that finds the largest number in a list:</p> <pre><code>def find_max(numbers):\n    if not numbers:\n        return None\n    biggest = numbers[0]\n    for num in numbers:\n        if num &gt; biggest:\n            biggest = num\n    return biggest\n\n# Test case 1: Normal list\nassert find_max([3, 1, 4, 1, 5]) == 5\n\n# Test case 2: Single element\nassert find_max([42]) == 42\n\n# Test case 3: All same values\nassert find_max([7, 7, 7]) == 7\n\n# Test case 4: Negative numbers\nassert find_max([-5, -2, -8]) == -2\n\n# Test case 5: Empty list\nassert find_max([]) is None\n</code></pre> <p>Notice how each test case targets a different situation. That's how you build confidence that your function works \u2014 not by checking one example, but by checking many.</p>"},{"location":"chapters/17-testing-and-debugging/#assert-statements","title":"Assert Statements","text":"<p>You've already seen them in action, but let's formally introduce assert statements. An assert statement is Python's built-in way of saying \"I expect this to be true \u2014 and if it's not, stop everything and tell me.\"</p> <p>The syntax is simple:</p> <pre><code>assert condition, \"Optional error message\"\n</code></pre> <p>If the condition is <code>True</code>, nothing happens \u2014 the program keeps running. If the condition is <code>False</code>, Python raises an <code>AssertionError</code> with your message.</p> <pre><code>age = 15\nassert age &gt;= 0, \"Age can't be negative!\"       # Passes\nassert age &lt; 200, \"That's way too old!\"          # Passes\nassert age &gt;= 18, \"Must be 18 or older to vote\"  # Fails!\n</code></pre> <p>Assert statements are perfect for testing because they make your expectations explicit. Instead of staring at a <code>print()</code> output and thinking \"is that right?\", an assert either passes silently or screams at you. There's no ambiguity.</p> <p>Monty says: Let's code this!</p> <p> Pro tip: Always include a descriptive error message in your assert statements. When a test fails at 2 AM the night before your project is due, <code>\"Expected 212, got 213\"</code> is a lot more helpful than just <code>AssertionError</code> with no context!</p>"},{"location":"chapters/17-testing-and-debugging/#the-unittest-module","title":"The Unittest Module","text":"<p>Writing your own test functions with <code>assert</code> is a great start, but Python provides a more powerful tool built right into the standard library: the unittest module. It gives you a structured framework for organizing, running, and reporting on your tests.</p> <p>With unittest, you create a test class that inherits from <code>unittest.TestCase</code>. Each test method in that class starts with the word <code>test_</code>. The framework automatically finds and runs all of these test functions for you.</p> <p>Here's a complete example:</p> <pre><code>import unittest\n\ndef is_palindrome(text):\n    \"\"\"Check if a string reads the same forward and backward.\"\"\"\n    cleaned = text.lower().replace(\" \", \"\")\n    return cleaned == cleaned[::-1]\n\nclass TestPalindrome(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Runs before each test method.\"\"\"\n        self.simple_palindrome = \"racecar\"\n        self.sentence_palindrome = \"A man a plan a canal Panama\"\n        self.not_palindrome = \"hello\"\n\n    def test_simple_palindrome(self):\n        self.assertTrue(is_palindrome(self.simple_palindrome))\n\n    def test_sentence_palindrome(self):\n        self.assertTrue(is_palindrome(self.sentence_palindrome))\n\n    def test_not_palindrome(self):\n        self.assertFalse(is_palindrome(self.not_palindrome))\n\n    def test_single_character(self):\n        self.assertTrue(is_palindrome(\"a\"))\n\n    def test_empty_string(self):\n        self.assertTrue(is_palindrome(\"\"))\n\nif __name__ == \"__main__\":\n    unittest.main()\n</code></pre> <p>Let's break down what's happening:</p> <ul> <li><code>setUp()</code> runs before each test method. It's where you prepare test data that multiple tests share.</li> <li>Each <code>test_</code> method checks one specific thing using assertion methods like <code>assertTrue()</code>, <code>assertFalse()</code>, and <code>assertEqual()</code>.</li> <li><code>unittest.main()</code> discovers and runs all test methods in the class.</li> </ul> <p>When you run this file, you'll see output like:</p> <pre><code>.....\n----------------------------------------------------------------------\nRan 5 tests in 0.001s\n\nOK\n</code></pre> <p>Each dot represents a passing test. If a test fails, you'll see an <code>F</code> instead of a dot, plus a detailed error message telling you exactly what went wrong.</p> <p>Here are the most common unittest assertion methods:</p> Method Checks That... <code>assertEqual(a, b)</code> <code>a == b</code> <code>assertNotEqual(a, b)</code> <code>a != b</code> <code>assertTrue(x)</code> <code>x is True</code> <code>assertFalse(x)</code> <code>x is False</code> <code>assertIn(a, b)</code> <code>a in b</code> <code>assertRaises(Error)</code> A specific exception is raised <code>assertIsNone(x)</code> <code>x is None</code> MicroSim: Unit Test Runner Visualization"},{"location":"chapters/17-testing-and-debugging/#diagram-unit-test-runner","title":"Diagram: Unit Test Runner","text":"<p>Type: microsim sim-id: unit-test-runner Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: execute, interpret</p> <p>Learning Objective: Students will be able to trace the execution of a unit test suite and interpret pass/fail results to identify which test cases succeeded and which revealed bugs.</p> <p>Purpose: An animated visualization showing how a unittest framework discovers, runs, and reports on test methods. Students watch tests execute one by one and see pass/fail indicators update in real time.</p> <p>Layout: - Left panel: Source code of a simple function (e.g., <code>find_max</code>) with a subtle bug - Right panel: A list of 5 test cases, each showing status (pending, running, pass, fail) - Bottom: A results summary bar showing total passed/failed</p> <p>Interactive elements: - \"Run All Tests\" button to execute the entire suite - \"Step\" button to run one test at a time - \"Fix Bug\" button that corrects the code and lets students re-run - Tests turn green (pass) or red (fail) as they execute</p> <p>Visual style: Clean code display with syntax highlighting, traffic-light colored status indicators Responsive: Two-panel layout collapses to single column on narrow screens</p> <p>Instructional Rationale: Watching tests execute sequentially builds understanding of how test frameworks operate. The deliberate bug encourages students to interpret failure messages and connect them back to the source code.</p>"},{"location":"chapters/17-testing-and-debugging/#edge-cases-and-boundary-testing","title":"Edge Cases and Boundary Testing","text":"<p>Here's a secret that experienced programmers know: most bugs hide at the edges. An edge case is an unusual or extreme input that your function might not handle correctly. Boundary testing focuses specifically on values right at the limits of what your code is supposed to handle.</p> <p>Think of it like a fence around a yard. You don't just check whether the fence works in the middle \u2014 you check the corners, the gates, and the posts at each end. Those boundaries are where things are most likely to go wrong.</p> <p>Common edge cases to test:</p> Input Type Edge Cases to Try Numbers 0, negative numbers, very large numbers, decimals Strings Empty string <code>\"\"</code>, single character, very long string, special characters Lists Empty list <code>[]</code>, list with one item, list with duplicates Booleans Both <code>True</code> and <code>False</code> Division Dividing by zero Indices First item, last item, out of range <p>Here's an example that shows why edge cases matter:</p> <pre><code>def calculate_average(grades):\n    \"\"\"Calculate the average of a list of grades.\"\"\"\n    total = sum(grades)\n    return total / len(grades)\n\n# Normal test - works fine\nassert calculate_average([90, 80, 70]) == 80.0\n\n# Edge case - empty list!\n# calculate_average([])  # ZeroDivisionError!\n</code></pre> <p>Oops! Our function crashes on an empty list because it tries to divide by zero. Let's fix it:</p> <pre><code>def calculate_average(grades):\n    \"\"\"Calculate the average of a list of grades.\"\"\"\n    if not grades:\n        return 0.0\n    total = sum(grades)\n    return total / len(grades)\n\n# Now the edge case is handled\nassert calculate_average([]) == 0.0\nassert calculate_average([100]) == 100.0\nassert calculate_average([90, 80, 70]) == 80.0\n</code></pre> <p>Boundary testing is a specific type of edge case testing where you focus on boundary values. If a function is supposed to accept grades between 0 and 100, you'd test:</p> <ul> <li>The exact boundaries: <code>0</code> and <code>100</code></li> <li>Just inside: <code>1</code> and <code>99</code></li> <li>Just outside: <code>-1</code> and <code>101</code></li> </ul> <pre><code>def is_valid_grade(grade):\n    \"\"\"Return True if grade is between 0 and 100 inclusive.\"\"\"\n    return 0 &lt;= grade &lt;= 100\n\n# Boundary tests\nassert is_valid_grade(0) == True      # Lower boundary\nassert is_valid_grade(100) == True    # Upper boundary\nassert is_valid_grade(1) == True      # Just inside lower\nassert is_valid_grade(99) == True     # Just inside upper\nassert is_valid_grade(-1) == False    # Just outside lower\nassert is_valid_grade(101) == False   # Just outside upper\n</code></pre> <p>Monty says: You've got this!</p> <p> Here's a pattern to remember: whenever you write a function, ask yourself \"What's the weirdest thing someone could pass in?\" An empty list, a negative number, a string with only spaces, <code>None</code>... Testing the weird stuff is where you find the most bugs!</p> MicroSim: Boundary Testing Playground"},{"location":"chapters/17-testing-and-debugging/#diagram-boundary-testing-playground","title":"Diagram: Boundary Testing Playground","text":"<p>Type: microsim sim-id: boundary-testing Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: test, identify</p> <p>Learning Objective: Students will be able to identify boundary values for a given function specification and predict whether each test input will pass or fail.</p> <p>Purpose: An interactive playground where students select boundary values on a number line to test against a function. They predict pass/fail, then run the test to check their prediction.</p> <p>Layout: - Top: Function specification card (e.g., \"Accept ages 13-19 for teen discount\") - Middle: A number line from -10 to 30 with clickable points - Bottom: Test results panel showing predictions vs. actual results</p> <p>Interactive elements: - Click points on the number line to select test values - For each selected value, choose \"predict pass\" or \"predict fail\" - \"Run Tests\" button executes all selected test cases - Color coding shows correct predictions (green) vs. incorrect (red) - \"New Function\" button loads a different specification</p> <p>Visual style: Clean number line with color-coded regions (valid range in green, invalid in gray) Responsive: Number line scales to canvas width</p> <p>Instructional Rationale: Having students predict outcomes before seeing results activates the Apply level by requiring them to reason about boundary conditions rather than passively observing. The immediate feedback loop reinforces correct mental models.</p>"},{"location":"chapters/17-testing-and-debugging/#test-driven-development","title":"Test-Driven Development","text":"<p>What if you wrote your tests before you wrote your code? That might sound backward, but it's actually a powerful technique called Test-Driven Development (TDD). The idea is simple: define what \"correct\" looks like first, then write the code to make it happen.</p> <p>TDD follows a three-step cycle known as Red, Green, Refactor:</p> <ol> <li>Red \u2014 Write a test for a feature that doesn't exist yet. Run it. It fails (red).</li> <li>Green \u2014 Write the simplest code that makes the test pass. Run it. It passes (green).</li> <li>Refactor \u2014 Clean up your code without changing its behavior. Run the tests again to make sure everything still passes.</li> </ol> <p>Then you repeat the cycle for the next feature.</p> <pre><code># === STEP 1: RED ===\n# Write the test first (the function doesn't exist yet!)\nimport unittest\n\nclass TestFizzBuzz(unittest.TestCase):\n    def test_regular_number(self):\n        self.assertEqual(fizzbuzz(1), \"1\")\n\n    def test_divisible_by_3(self):\n        self.assertEqual(fizzbuzz(3), \"Fizz\")\n\n    def test_divisible_by_5(self):\n        self.assertEqual(fizzbuzz(5), \"Buzz\")\n\n    def test_divisible_by_15(self):\n        self.assertEqual(fizzbuzz(15), \"FizzBuzz\")\n</code></pre> <p>If you try to run these tests now, they'll crash because <code>fizzbuzz</code> doesn't exist. That's the Red step \u2014 your tests are failing.</p> <pre><code># === STEP 2: GREEN ===\n# Write the simplest code to pass the tests\ndef fizzbuzz(n):\n    if n % 15 == 0:\n        return \"FizzBuzz\"\n    elif n % 3 == 0:\n        return \"Fizz\"\n    elif n % 5 == 0:\n        return \"Buzz\"\n    else:\n        return str(n)\n</code></pre> <p>Now run the tests \u2014 they all pass! That's the Green step.</p> <pre><code># === STEP 3: REFACTOR ===\n# The code is already clean, but maybe we want to add more tests\n# for edge cases before moving on\nclass TestFizzBuzz(unittest.TestCase):\n    def test_regular_number(self):\n        self.assertEqual(fizzbuzz(1), \"1\")\n\n    def test_divisible_by_3(self):\n        self.assertEqual(fizzbuzz(3), \"Fizz\")\n\n    def test_divisible_by_5(self):\n        self.assertEqual(fizzbuzz(5), \"Buzz\")\n\n    def test_divisible_by_15(self):\n        self.assertEqual(fizzbuzz(15), \"FizzBuzz\")\n\n    def test_large_number(self):\n        self.assertEqual(fizzbuzz(30), \"FizzBuzz\")\n\n    def test_number_two(self):\n        self.assertEqual(fizzbuzz(2), \"2\")\n</code></pre> <p>Why does TDD work so well? Because you always know exactly what you're trying to build. The tests are your roadmap. You never write code that isn't needed, and you always know when you're done.</p> Diagram: TDD Red-Green-Refactor Cycle"},{"location":"chapters/17-testing-and-debugging/#diagram-tdd-cycle","title":"Diagram: TDD Cycle","text":"<p>Type: infographic sim-id: tdd-cycle Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: describe, explain</p> <p>Learning Objective: Students will be able to describe the three phases of the TDD cycle (Red, Green, Refactor) and explain the purpose of each phase.</p> <p>Purpose: An animated circular diagram showing the TDD cycle with three nodes connected by arrows. Each phase includes a brief description and a code snippet example.</p> <p>Layout: - Circular arrangement with three large nodes at 12 o'clock (Red), 4 o'clock (Green), and 8 o'clock (Refactor) - Arrows connecting Red to Green to Refactor and back to Red - Center text: \"TDD Cycle\"</p> <p>Nodes: 1. Red (red circle): \"Write a failing test\" - shows a test with a red X 2. Green (green circle): \"Write code to pass\" - shows code with a green checkmark 3. Refactor (blue circle): \"Clean up the code\" - shows improved code with a green checkmark</p> <p>Interactive elements: - Click any node to see a detailed example with code snippets - \"Animate Cycle\" button rotates through all three phases with explanations - Hover reveals the key question for each phase (\"What should it do?\", \"What's the simplest fix?\", \"Can I make it cleaner?\")</p> <p>Visual style: Bold colored circles with clean connecting arrows, modern flat design Responsive: Circle scales proportionally with canvas</p> <p>Instructional Rationale: The circular visual reinforces that TDD is an ongoing cycle, not a one-time process. Interactive exploration lets students absorb each phase at their own pace.</p>"},{"location":"chapters/17-testing-and-debugging/#what-is-debugging","title":"What Is Debugging?","text":"<p>You've written your tests. Some of them are failing. Now what? Time to debug! Debugging is the process of finding and fixing errors (bugs) in your code. The term supposedly comes from an actual bug \u2014 a moth that was found stuck inside an early computer in 1947, causing it to malfunction. (Yes, really.)</p> <p>Debugging is part detective work, part puzzle solving. You know something is wrong (your test fails, or your program produces unexpected output). Now you have to figure out where the problem is and why it's happening.</p> <p>Here's a general debugging process:</p> <ol> <li>Reproduce the bug \u2014 Make it happen consistently</li> <li>Isolate the problem \u2014 Narrow down where in the code the bug lives</li> <li>Identify the cause \u2014 Figure out why the code behaves incorrectly</li> <li>Fix the bug \u2014 Change the code to correct the behavior</li> <li>Verify the fix \u2014 Run your tests to confirm the bug is gone and nothing else broke</li> </ol> <p>Let's look at the specific debugging techniques you can use.</p>"},{"location":"chapters/17-testing-and-debugging/#print-debugging","title":"Print Debugging","text":"<p>The simplest debugging technique is also one of the most common: print debugging. You add <code>print()</code> statements to your code to display the values of variables at different points during execution. It's like leaving yourself breadcrumbs through a dark forest.</p> <pre><code>def find_second_largest(numbers):\n    # print debugging to trace values\n    print(f\"Input: {numbers}\")\n\n    largest = numbers[0]\n    second = numbers[0]\n\n    for num in numbers:\n        print(f\"  Checking {num}: largest={largest}, second={second}\")\n        if num &gt; largest:\n            second = largest\n            largest = num\n        elif num &gt; second:\n            second = num\n\n    print(f\"Result: largest={largest}, second={second}\")\n    return second\n\n# Something seems wrong...\nresult = find_second_largest([3, 1, 4, 1, 5])\nprint(f\"Second largest: {result}\")\n</code></pre> <p>Running this would show you the value of every variable at each step, making it much easier to spot where things go wrong.</p> <p>Print debugging is quick and easy, but it has downsides:</p> <ul> <li>You have to remember to remove all those <code>print()</code> statements when you're done</li> <li>It clutters your code while you're debugging</li> <li>For complex programs, you might need dozens of print statements</li> </ul> <p>Still, don't underestimate it. Even experienced developers reach for <code>print()</code> debugging regularly. It works.</p>"},{"location":"chapters/17-testing-and-debugging/#debugger-tools","title":"Debugger Tools","text":"<p>For more complex bugs, you need more powerful tools. A debugger tool is a program that lets you pause your code mid-execution and inspect everything that's happening \u2014 variables, the call stack, the flow of execution \u2014 without adding print statements.</p> <p>Python comes with a built-in debugger called <code>pdb</code>, and most code editors (like VS Code, PyCharm, and Thonny) have visual debuggers built right in. Visual debuggers are especially beginner-friendly because you can see your code, your variables, and the execution flow all at once.</p> <p>Here's what a debugger typically lets you do:</p> Feature What It Does Pause execution Stop the program at any point to examine state Inspect variables See the current value of every variable View call stack See which functions called which Control execution Move through your code line by line Evaluate expressions Type in expressions to test on the fly"},{"location":"chapters/17-testing-and-debugging/#breakpoints","title":"Breakpoints","text":"<p>A breakpoint is a marker you place on a specific line of code that tells the debugger \"stop here.\" When the program reaches that line, it pauses, and you can look around at the state of everything.</p> <p>In most editors, you set a breakpoint by clicking in the left margin next to a line number. A red dot appears, and the next time you run the program in debug mode, it'll stop at that line.</p> <pre><code>def calculate_discount(price, discount_percent):\n    # Set a breakpoint on the next line to inspect values\n    discount_amount = price * discount_percent / 100  # &lt;-- breakpoint here\n    final_price = price - discount_amount\n    return final_price\n\nresult = calculate_discount(50, 20)\n</code></pre> <p>When the debugger pauses at the breakpoint, you can see that <code>price</code> is <code>50</code>, <code>discount_percent</code> is <code>20</code>, and <code>discount_amount</code> is about to be calculated. You can then step through code line by line to watch the calculation unfold.</p>"},{"location":"chapters/17-testing-and-debugging/#step-through-code","title":"Step Through Code","text":"<p>Once your program is paused at a breakpoint, you can step through code \u2014 executing one line at a time. Most debuggers offer three stepping options:</p> <ul> <li>Step Over \u2014 Run the current line and move to the next one (if the line calls a function, run the whole function without going inside it)</li> <li>Step Into \u2014 If the current line calls a function, jump inside that function and pause at its first line</li> <li>Step Out \u2014 Finish running the current function and pause when you return to the caller</li> </ul> <p>Stepping through code is like watching a movie in slow motion. You see exactly what happens at each moment, which makes it much easier to spot the frame where things go wrong.</p> MicroSim: Visual Debugger Simulator"},{"location":"chapters/17-testing-and-debugging/#diagram-visual-debugger-simulator","title":"Diagram: Visual Debugger Simulator","text":"<p>Type: microsim sim-id: visual-debugger Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: execute, trace</p> <p>Learning Objective: Students will be able to use breakpoints and step-through controls to trace the execution of a Python function and identify where a bug occurs.</p> <p>Purpose: A simulated debugger environment where students can set breakpoints, step through code line by line, and watch variable values change in real time.</p> <p>Layout: - Left panel: Python code with line numbers (a function with a subtle bug) - Right panel: Variable inspector showing current values - Bottom: Debugger controls (Step Over, Step Into, Step Out, Continue, Reset) - Current line highlighted in yellow</p> <p>Interactive elements: - Click line numbers to toggle breakpoints (red dots) - \"Run\" button starts execution, pausing at first breakpoint - Step buttons advance execution one line at a time - Variable panel updates in real time as values change - Output console shows any print() output - \"Find the Bug\" challenge mode that asks students to identify the buggy line</p> <p>Visual style: Dark code editor theme with syntax highlighting, professional debugger appearance Responsive: Panels stack vertically on narrow screens</p> <p>Instructional Rationale: Hands-on debugger experience in a safe, simulated environment removes the intimidation factor of real debugger tools. Students build muscle memory for the step/inspect workflow before encountering it in their actual IDE.</p>"},{"location":"chapters/17-testing-and-debugging/#code-tracing","title":"Code Tracing","text":"<p>Code tracing is the technique of manually stepping through your code with pen and paper (or in your head), keeping track of every variable's value as each line executes. It's like being a human debugger.</p> <p>Here's how you trace code. Take this function:</p> <pre><code>def mystery(n):\n    result = 0\n    for i in range(1, n + 1):\n        result = result + i\n    return result\n\nprint(mystery(4))\n</code></pre> <p>To trace it, you create a table that tracks every variable at each step:</p> Step Line <code>n</code> <code>i</code> <code>result</code> Notes 1 <code>result = 0</code> 4 \u2014 0 Initialize result 2 <code>for i in range(1, 5)</code> 4 1 0 First loop iteration 3 <code>result = result + i</code> 4 1 1 0 + 1 = 1 4 <code>for i in range(1, 5)</code> 4 2 1 Second iteration 5 <code>result = result + i</code> 4 2 3 1 + 2 = 3 6 <code>for i in range(1, 5)</code> 4 3 3 Third iteration 7 <code>result = result + i</code> 4 3 6 3 + 3 = 6 8 <code>for i in range(1, 5)</code> 4 4 6 Fourth iteration 9 <code>result = result + i</code> 4 4 10 6 + 4 = 10 10 <code>return result</code> 4 \u2014 10 Returns 10 <p>The function computes 1 + 2 + 3 + 4 = 10. Code tracing is a skill that's tested on the AP exam, so practicing it now will pay off later. It's also a great way to understand someone else's code \u2014 or to figure out why your own code isn't doing what you expected.</p>"},{"location":"chapters/17-testing-and-debugging/#rubber-duck-debugging","title":"Rubber Duck Debugging","text":"<p>This is going to sound silly, but bear with us. Rubber duck debugging is a technique where you explain your code, line by line, to a rubber duck (or any inanimate object \u2014 a stuffed animal, a houseplant, a very patient pet).</p> <p>Why does this work? Because the act of explaining your code forces you to slow down and think about what each line actually does. When you're just reading code in your head, it's easy to skip over the problem. But when you have to articulate \"this line takes the list and... wait, it should be sorting it, but I'm calling <code>reverse()</code> instead of <code>sort()</code>!\" \u2014 the bug reveals itself.</p> <p>Here's the official rubber duck debugging protocol:</p> <ol> <li>Get a rubber duck (or any willing listener \u2014 including stuffed animals and coffee mugs)</li> <li>Place the duck on your desk</li> <li>Explain your code to the duck, line by line</li> <li>When you reach the line where what you say doesn't match what the code does \u2014 that's your bug!</li> </ol> <p>This technique was popularized by the book The Pragmatic Programmer, and developers around the world swear by it. Some software companies even keep rubber ducks at every desk. It sounds ridiculous, but it genuinely works.</p> <p>Why? Because there's a difference between reading code and understanding code. When you explain it out loud, you switch from passively scanning to actively reasoning. Your brain processes the logic differently when you have to put it into words.</p> <p>Monty says: Let's debug this together!</p> <p> If you don't have a rubber duck, you can always explain your code to me! But seriously \u2014 talking through your code out loud is one of the most effective debugging techniques out there. Try it next time you're stuck. You'll be amazed at how often the bug just pops out while you're explaining the code.</p>"},{"location":"chapters/17-testing-and-debugging/#debugging-strategies-comparison","title":"Debugging Strategies Comparison","text":"<p>Here's a handy reference comparing all the debugging techniques we've covered:</p> Strategy How It Works Best For Difficulty Print Debugging Add <code>print()</code> statements to show variable values Quick checks, simple bugs Beginner Debugger Tools Use breakpoints and step-through in an IDE Complex bugs, understanding flow Intermediate Code Tracing Manually track variables on paper Understanding logic, exam prep Beginner Rubber Duck Explain code out loud to find logical errors Logic bugs, when you're stuck Beginner Breakpoints Pause execution at specific lines Targeting a specific area Intermediate Step Through Execute one line at a time in the debugger Watching variable changes Intermediate <p>Each strategy has its place. Smart debuggers use multiple techniques. Start with the simple ones (print, rubber duck), and reach for the debugger when those aren't enough.</p> Diagram: Debugging Decision Flowchart"},{"location":"chapters/17-testing-and-debugging/#diagram-which-debugging-strategy-should-you-use","title":"Diagram: Which Debugging Strategy Should You Use?","text":"<p>Type: infographic sim-id: debugging-flowchart Library: p5.js Status: Specified</p> <p>Bloom Level: Analyze (L4) Bloom Verb: choose, determine</p> <p>Learning Objective: Students will be able to select an appropriate debugging strategy based on the type of bug and context.</p> <p>Purpose: A decision tree flowchart that guides students through choosing the right debugging technique based on their situation.</p> <p>Layout: - Start node: \"I have a bug!\" - Decision diamonds: \"Do you know roughly where the bug is?\", \"Is it a logic error or a crash?\", \"Is the code short enough to trace by hand?\" - Leaf nodes: Each debugging technique with a brief tip</p> <p>Flow: - Know where? Yes -&gt; Breakpoint + Step Through. No -&gt; continue - Crash or logic? Crash -&gt; Print debugging to find the line. Logic -&gt; continue - Short enough to trace? Yes -&gt; Code Tracing. No -&gt; Rubber Duck first, then Debugger</p> <p>Interactive elements: - Click decision diamonds to follow the path - Each leaf node expands to show a mini-tutorial for that technique - \"Start Over\" button resets to the beginning</p> <p>Visual style: Clean flowchart with rounded rectangles and diamond shapes, color-coded paths Responsive: Flowchart scales and repositions on resize</p> <p>Instructional Rationale: A decision tree teaches the metacognitive skill of choosing the right tool for the job, which is a higher-order thinking skill (Analyze level). Students internalize a problem-solving strategy, not just a list of techniques.</p>"},{"location":"chapters/17-testing-and-debugging/#defensive-programming","title":"Defensive Programming","text":"<p>So far, we've talked about finding and fixing bugs after they happen. But what if you could prevent bugs from happening in the first place? That's the idea behind defensive programming \u2014 writing code that anticipates problems and handles them gracefully, rather than crashing unexpectedly.</p> <p>Defensive programming means assuming that things will go wrong and preparing for it. It's like wearing a seatbelt \u2014 you hope you never need it, but you're glad it's there when you do.</p> <p>Key defensive programming practices:</p> <ul> <li>Check your inputs before using them</li> <li>Handle edge cases explicitly</li> <li>Use try-except blocks to catch potential errors</li> <li>Validate data before processing it</li> <li>Add assertions to check assumptions in your code</li> </ul> <p>Here's a function written without defensive programming:</p> <pre><code># Fragile \u2014 crashes on bad input\ndef divide(a, b):\n    return a / b\n</code></pre> <p>And here's the same function written with defensive programming:</p> <pre><code># Defensive \u2014 handles problems gracefully\ndef divide(a, b):\n    if not isinstance(a, (int, float)):\n        raise TypeError(f\"Expected a number, got {type(a).__name__}\")\n    if not isinstance(b, (int, float)):\n        raise TypeError(f\"Expected a number, got {type(b).__name__}\")\n    if b == 0:\n        raise ValueError(\"Cannot divide by zero\")\n    return a / b\n</code></pre> <p>The defensive version checks everything before attempting the division. If something is wrong, it raises a clear, descriptive error instead of crashing with a confusing traceback.</p>"},{"location":"chapters/17-testing-and-debugging/#input-validation","title":"Input Validation","text":"<p>A specific form of defensive programming is input validation \u2014 checking that data from the user (or any external source) is correct, safe, and sensible before your program uses it.</p> <p>Users are creative. They'll type letters where you expect numbers, leave fields blank, enter negative ages, and paste entire novels into a \"phone number\" field. Your job as a programmer is to expect the unexpected.</p> <pre><code>def get_age():\n    \"\"\"Get a valid age from the user.\"\"\"\n    while True:\n        user_input = input(\"Enter your age: \")\n\n        # Check that it's a number\n        if not user_input.isdigit():\n            print(\"Please enter a positive whole number.\")\n            continue\n\n        age = int(user_input)\n\n        # Check that it's reasonable\n        if age &lt; 0 or age &gt; 150:\n            print(\"Please enter a realistic age (0-150).\")\n            continue\n\n        return age\n</code></pre> <p>This function refuses to accept bad input. It keeps asking until the user provides something valid. That's input validation in action.</p> <p>Here's a more thorough example for a password validator:</p> <pre><code>def validate_password(password):\n    \"\"\"Check if a password meets security requirements.\"\"\"\n    errors = []\n\n    if len(password) &lt; 8:\n        errors.append(\"Password must be at least 8 characters\")\n\n    if not any(c.isupper() for c in password):\n        errors.append(\"Password must contain an uppercase letter\")\n\n    if not any(c.islower() for c in password):\n        errors.append(\"Password must contain a lowercase letter\")\n\n    if not any(c.isdigit() for c in password):\n        errors.append(\"Password must contain a digit\")\n\n    if errors:\n        return False, errors\n    return True, [\"Password is valid!\"]\n\n# Test it\nvalid, messages = validate_password(\"abc\")\nprint(valid)       # False\nprint(messages)    # ['Password must be at least 8 characters',\n                   #  'Password must contain an uppercase letter',\n                   #  'Password must contain a digit']\n</code></pre> <p>Monty says: Let's debug this together!</p> <p> Never trust user input! Even if your program is just a class project, get in the habit of validating inputs. In professional software, unvalidated input is one of the top causes of security vulnerabilities and crashes. Build the habit now, and future-you will thank you.</p> MicroSim: Input Validation Tester"},{"location":"chapters/17-testing-and-debugging/#diagram-input-validation-tester","title":"Diagram: Input Validation Tester","text":"<p>Type: microsim sim-id: input-validation-tester Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: test, validate</p> <p>Learning Objective: Students will be able to write and test input validation rules for common data types (age, email, password) and predict which inputs will pass or fail validation.</p> <p>Purpose: An interactive tool where students define validation rules and then test various inputs against them, seeing which pass and which fail with specific error messages.</p> <p>Layout: - Top: Dropdown to select validation scenario (Age, Email, Password, Grade) - Middle: Input field where students type test values - Right: Validation rules panel showing the current rules - Bottom: Results log showing pass/fail history with reasons</p> <p>Interactive elements: - Type any input and press \"Validate\" to check it - Green/red indicator for pass/fail - Error messages explain exactly why validation failed - \"Challenge Mode\" presents tricky inputs and asks students to predict pass/fail before checking</p> <p>Visual style: Form-like layout with clear pass/fail indicators Responsive: Single column layout that works on all screen sizes</p> <p>Instructional Rationale: Hands-on testing of validation rules builds practical skill in thinking about edge cases and boundary conditions in real-world input scenarios.</p>"},{"location":"chapters/17-testing-and-debugging/#code-review","title":"Code Review","text":"<p>The last quality assurance technique in our toolkit is code review \u2014 having another person read your code and provide feedback. Code review is standard practice at every professional software company. At Google, for example, every single line of code must be reviewed by at least one other engineer before it can be added to the codebase.</p> <p>Why is code review so valuable?</p> <ul> <li>Fresh eyes catch bugs you've become blind to after staring at the code for hours</li> <li>Knowledge sharing \u2014 reviewers learn about your code, and you learn from their feedback</li> <li>Better design \u2014 explaining your code to someone else (sound familiar?) often reveals improvements</li> <li>Consistency \u2014 reviewers can catch style issues and ensure the code follows team conventions</li> </ul> <p>Here's what a code review typically focuses on:</p> Area Questions to Ask Correctness Does the code actually do what it's supposed to? Readability Can someone else understand this code easily? Edge cases Are unusual inputs handled? Efficiency Is there an obviously better way to do this? Style Does it follow PEP 8 and team conventions? Tests Are there tests? Do they cover the important cases? Naming Are variable and function names clear and descriptive? <p>You don't need to be a professional to practice code review. Swap code with a classmate, review each other's homework, or even review your own code after taking a break. A few hours away from your code gives you fresh eyes \u2014 you'll be surprised what you catch.</p> <p>Here's a simple code review checklist you can use:</p> <pre><code># CODE REVIEW CHECKLIST\n# [ ] Does the code run without errors?\n# [ ] Are variable names descriptive?\n# [ ] Are there comments where needed?\n# [ ] Are edge cases handled?\n# [ ] Is the code DRY (no unnecessary repetition)?\n# [ ] Are there tests?\n# [ ] Would I understand this code in 3 months?\n</code></pre>"},{"location":"chapters/17-testing-and-debugging/#putting-it-all-together-a-complete-example","title":"Putting It All Together: A Complete Example","text":"<p>Let's tie everything together with a real-world example. We'll build a <code>GradeBook</code> class using TDD, defensive programming, and thorough testing.</p> <pre><code>import unittest\n\nclass GradeBook:\n    \"\"\"A simple grade book that stores and analyzes student grades.\"\"\"\n\n    def __init__(self):\n        self.grades = {}\n\n    def add_grade(self, student, grade):\n        \"\"\"Add a grade for a student. Validates inputs.\"\"\"\n        # Input validation\n        if not isinstance(student, str) or not student.strip():\n            raise ValueError(\"Student name must be a non-empty string\")\n        if not isinstance(grade, (int, float)):\n            raise TypeError(\"Grade must be a number\")\n        if grade &lt; 0 or grade &gt; 100:\n            raise ValueError(\"Grade must be between 0 and 100\")\n\n        student = student.strip()\n        if student not in self.grades:\n            self.grades[student] = []\n        self.grades[student].append(grade)\n\n    def get_average(self, student):\n        \"\"\"Get a student's average grade.\"\"\"\n        if student not in self.grades:\n            raise KeyError(f\"Student '{student}' not found\")\n        grades = self.grades[student]\n        return sum(grades) / len(grades)\n\n    def get_highest(self):\n        \"\"\"Get the student with the highest average.\"\"\"\n        if not self.grades:\n            return None\n        best_student = None\n        best_avg = -1\n        for student in self.grades:\n            avg = self.get_average(student)\n            if avg &gt; best_avg:\n                best_avg = avg\n                best_student = student\n        return best_student, best_avg\n\n\nclass TestGradeBook(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Create a fresh grade book for each test.\"\"\"\n        self.gb = GradeBook()\n\n    # --- Test add_grade ---\n    def test_add_single_grade(self):\n        self.gb.add_grade(\"Alice\", 95)\n        self.assertIn(\"Alice\", self.gb.grades)\n        self.assertEqual(self.gb.grades[\"Alice\"], [95])\n\n    def test_add_multiple_grades(self):\n        self.gb.add_grade(\"Bob\", 80)\n        self.gb.add_grade(\"Bob\", 90)\n        self.assertEqual(self.gb.grades[\"Bob\"], [80, 90])\n\n    # --- Test input validation ---\n    def test_invalid_student_name(self):\n        with self.assertRaises(ValueError):\n            self.gb.add_grade(\"\", 85)\n\n    def test_grade_too_high(self):\n        with self.assertRaises(ValueError):\n            self.gb.add_grade(\"Alice\", 105)\n\n    def test_grade_too_low(self):\n        with self.assertRaises(ValueError):\n            self.gb.add_grade(\"Alice\", -5)\n\n    def test_non_numeric_grade(self):\n        with self.assertRaises(TypeError):\n            self.gb.add_grade(\"Alice\", \"A+\")\n\n    # --- Test get_average ---\n    def test_average_single_grade(self):\n        self.gb.add_grade(\"Alice\", 90)\n        self.assertEqual(self.gb.get_average(\"Alice\"), 90.0)\n\n    def test_average_multiple_grades(self):\n        self.gb.add_grade(\"Alice\", 80)\n        self.gb.add_grade(\"Alice\", 90)\n        self.gb.add_grade(\"Alice\", 100)\n        self.assertEqual(self.gb.get_average(\"Alice\"), 90.0)\n\n    def test_average_unknown_student(self):\n        with self.assertRaises(KeyError):\n            self.gb.get_average(\"Nobody\")\n\n    # --- Test get_highest ---\n    def test_highest_single_student(self):\n        self.gb.add_grade(\"Alice\", 95)\n        name, avg = self.gb.get_highest()\n        self.assertEqual(name, \"Alice\")\n\n    def test_highest_multiple_students(self):\n        self.gb.add_grade(\"Alice\", 85)\n        self.gb.add_grade(\"Bob\", 92)\n        self.gb.add_grade(\"Charlie\", 88)\n        name, avg = self.gb.get_highest()\n        self.assertEqual(name, \"Bob\")\n\n    # --- Edge cases ---\n    def test_highest_empty_gradebook(self):\n        self.assertIsNone(self.gb.get_highest())\n\n    def test_boundary_grade_zero(self):\n        self.gb.add_grade(\"Alice\", 0)\n        self.assertEqual(self.gb.get_average(\"Alice\"), 0.0)\n\n    def test_boundary_grade_hundred(self):\n        self.gb.add_grade(\"Alice\", 100)\n        self.assertEqual(self.gb.get_average(\"Alice\"), 100.0)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n</code></pre> <p>This example shows everything working together: a well-tested class with input validation, edge case handling, boundary testing, and organized test cases using the unittest module. Notice how the test class has a <code>setUp</code> method that creates a fresh <code>GradeBook</code> for each test, ensuring tests don't interfere with each other.</p> <p>Monty says: You've got this!</p> <p> Amazing work getting through this chapter, coders! You now have a complete testing and debugging toolkit. Remember: every professional programmer writes bugs. What makes you a great programmer isn't writing perfect code \u2014 it's knowing how to find and fix problems quickly. Keep testing, keep debugging, and keep coding!</p>"},{"location":"chapters/17-testing-and-debugging/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Testing is the process of verifying that your code works correctly. Start with manual testing, then level up to automated unit tests.</li> <li>Unit testing checks individual functions in isolation. Python's unittest module provides a structured framework with <code>setUp()</code>, test methods, and assertion helpers.</li> <li>Test cases should cover normal inputs, edge cases (unusual inputs), and boundary values (inputs at the limits).</li> <li>Assert statements make your expectations explicit: if the condition is false, the program raises an error immediately.</li> <li>Test-Driven Development (TDD) follows the Red-Green-Refactor cycle: write a failing test, make it pass, then clean up.</li> <li>Debugging is a systematic process: reproduce, isolate, identify, fix, verify.</li> <li>Print debugging uses <code>print()</code> to inspect variable values. Debugger tools use breakpoints and step through code for more powerful inspection.</li> <li>Code tracing means manually tracking variable values on paper \u2014 essential for understanding logic and for AP exam prep.</li> <li>Rubber duck debugging works by forcing you to explain your code out loud, which reveals logic errors.</li> <li>Defensive programming anticipates problems before they happen. Input validation ensures user data is correct and safe before your program uses it.</li> <li>Code review uses fresh eyes to catch bugs, share knowledge, and improve code quality.</li> </ul> Check Your Understanding: What are the three steps of the TDD cycle? <p>The three steps are Red, Green, Refactor: (1) Red \u2014 write a test that fails because the feature doesn't exist yet. (2) Green \u2014 write the simplest code that makes the test pass. (3) Refactor \u2014 clean up the code while keeping all tests passing. Then repeat the cycle for the next feature.</p> Check Your Understanding: Why is testing edge cases important? <p>Edge cases are unusual or extreme inputs (like empty lists, negative numbers, or very large values) that are most likely to reveal bugs. Most bugs hide at the edges of what your code handles, not in the typical \"happy path.\" Testing edge cases ensures your code is robust and handles all situations \u2014 not just the easy ones.</p> Check Your Understanding: How does rubber duck debugging work, and why is it effective? <p>Rubber duck debugging involves explaining your code, line by line, to a rubber duck (or any inanimate object). It works because the act of putting your logic into words forces you to think carefully about what each line actually does. When what you say doesn't match what the code does, you've found your bug. It's effective because it switches your brain from passively reading to actively reasoning about the code.</p>"},{"location":"chapters/18-searching-and-sorting/","title":"Searching and Sorting","text":""},{"location":"chapters/18-searching-and-sorting/#searching-and-sorting","title":"Searching and Sorting","text":""},{"location":"chapters/18-searching-and-sorting/#summary","title":"Summary","text":"<p>This chapter introduces fundamental algorithms for searching and sorting data. Students will learn linear and binary search, then study selection sort, insertion sort, and merge sort (including its recursive implementation). The chapter covers algorithm correctness through loop invariants, Big-O notation for analyzing time and space complexity, and introduces the key complexity classes. Comparing algorithms by their efficiency is a core computer science skill.</p>"},{"location":"chapters/18-searching-and-sorting/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 20 concepts from the learning graph:</p> <ol> <li>Algorithm Design</li> <li>Pseudocode</li> <li>Flowcharts</li> <li>Linear Search</li> <li>Binary Search</li> <li>Search Comparison</li> <li>Selection Sort</li> <li>Insertion Sort</li> <li>Merge Sort</li> <li>Merge Sort Recursion</li> <li>Sorting Comparison</li> <li>Stable vs Unstable Sort</li> <li>Algorithm Correctness</li> <li>Loop Invariants</li> <li>Big-O Notation</li> <li>Time Complexity</li> <li>Space Complexity</li> <li>Constant Time O(1)</li> <li>Linear Time O(n)</li> <li>Quadratic Time O(n^2)</li> </ol>"},{"location":"chapters/18-searching-and-sorting/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 1: Introduction to Computer Science</li> <li>Chapter 3: Boolean Logic and Comparisons</li> <li>Chapter 4: Control Flow</li> <li>Chapter 7: Higher-Order Functions and Recursion</li> <li>Chapter 8: Lists</li> <li>Chapter 9: Advanced List Operations</li> </ul> <p>Monty says: Let's code this!</p> <p> Welcome back, coders! Imagine you've got a huge pile of homework papers and you need to find one specific sheet. Do you flip through every single page, or do you use a smarter strategy? That's exactly the kind of question we'll answer in this chapter. We're going to learn how computers search through data and sort it into order \u2014 and we'll figure out which approaches are fast, which are slow, and why. Let's do this!</p>"},{"location":"chapters/18-searching-and-sorting/#algorithm-design-thinking-before-coding","title":"Algorithm Design: Thinking Before Coding","text":"<p>Before you write a single line of Python, you need a plan. Algorithm design is the process of figuring out the step-by-step strategy you'll use to solve a problem. A well-designed algorithm is clear, correct, and efficient. A poorly designed one might work... eventually... but it could take your computer hours instead of milliseconds.</p> <p>Good algorithm design starts with asking yourself three questions:</p> <ol> <li>What is the input? (What data am I starting with?)</li> <li>What is the desired output? (What do I want the answer to look like?)</li> <li>What steps transform the input into the output?</li> </ol> <p>For example, if the problem is \"find the largest number in a list,\" the input is the list, the output is the largest value, and the steps involve checking each number and keeping track of the biggest one you've seen so far.</p>"},{"location":"chapters/18-searching-and-sorting/#pseudocode-planning-in-plain-english","title":"Pseudocode: Planning in Plain English","text":"<p>Pseudocode is a way to write out your algorithm in plain, human-readable language before translating it into Python (or any programming language). It looks like code, but it doesn't follow any strict syntax rules. The goal is to capture the logic without worrying about commas, colons, or indentation.</p> <p>Here's pseudocode for finding the largest number:</p> <pre><code>SET max_value TO first element of the list\nFOR each element in the list:\n    IF element &gt; max_value:\n        SET max_value TO element\nRETURN max_value\n</code></pre> <p>Notice how you can read it almost like English? That's the point. Pseudocode helps you focus on what to do before getting bogged down in how to say it in Python.</p>"},{"location":"chapters/18-searching-and-sorting/#flowcharts-seeing-the-logic","title":"Flowcharts: Seeing the Logic","text":"<p>A flowchart is a diagram that shows the steps of an algorithm visually. Different shapes have different meanings:</p> <ul> <li>Oval = Start or End</li> <li>Rectangle = A process or action step</li> <li>Diamond = A decision (yes/no question)</li> <li>Arrow = The flow from one step to the next</li> </ul> <p>Flowcharts are especially helpful when your algorithm has branches (if/else) or loops, because you can literally see where the path splits and where it loops back.</p> Linear Search Flowchart"},{"location":"chapters/18-searching-and-sorting/#diagram-linear-search-flowchart","title":"Diagram: Linear Search Flowchart","text":"<p>Type: diagram sim-id: linear-search-flowchart Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: trace, explain</p> <p>Learning Objective: Students will be able to trace the steps of a linear search algorithm through a flowchart and explain the decision logic at each step.</p> <p>Purpose: An interactive flowchart that animates the steps of linear search. Students can enter a target value and watch the algorithm walk through an array one element at a time, highlighting the current node in the flowchart.</p> <p>Layout:</p> <ul> <li>Top: \"Start\" oval</li> <li>Process box: \"Set index = 0\"</li> <li>Diamond: \"Is index &lt; length?\"</li> <li>No branch: Process box \"Return -1 (not found)\" then End oval</li> <li>Yes branch: Diamond \"Is list[index] == target?\"<ul> <li>Yes: Process box \"Return index\" then End oval</li> <li>No: Process box \"index = index + 1\" then loop back to first diamond</li> </ul> </li> <li>Right panel: the array being searched, with the current element highlighted</li> </ul> <p>Interactive controls:</p> <ul> <li>Input field for target value</li> <li>\"Step\" button to advance one flowchart node at a time</li> <li>\"Auto Run\" button to animate the full search</li> <li>\"Reset\" button to start over</li> <li>Array is editable: students can type comma-separated values</li> </ul> <p>Visual style: Rounded rectangles for processes, diamonds for decisions, ovals for start/end. Active node glows yellow. Completed nodes turn green (found) or gray (passed).</p> <p>Instructional Rationale: Tracing through a flowchart step by step builds understanding of control flow in algorithms. Connecting the flowchart nodes to the actual array state gives students a dual representation \u2014 abstract logic and concrete data \u2014 which strengthens comprehension.</p>"},{"location":"chapters/18-searching-and-sorting/#searching-finding-the-needle","title":"Searching: Finding the Needle","text":"<p>Searching is one of the most common operations in computer science. Think about all the searching you do every day: looking up a contact on your phone, finding a song on a streaming app, or searching the web. Under the hood, computers use search algorithms to find what you're looking for.</p> <p>We'll explore two fundamental search algorithms: linear search and binary search.</p>"},{"location":"chapters/18-searching-and-sorting/#linear-search-one-at-a-time","title":"Linear Search: One at a Time","text":"<p>Linear search (also called sequential search) is the simplest search strategy: start at the beginning of the list and check each element one by one until you find what you're looking for \u2014 or reach the end.</p> <p>It's like looking for a specific card in an unsorted deck. You flip through each card from top to bottom. Not fancy, but it always works.</p> <p>Let's walk through an example. Suppose we have this list and we're searching for the value <code>7</code>:</p> <pre><code>[3, 8, 1, 7, 5, 2]\n</code></pre> Step Index Element Match? 1 0 3 No 2 1 8 No 3 2 1 No 4 3 7 Yes! Return index 3 <p>We found <code>7</code> at index 3 after checking 4 elements. Here's the Python code:</p> <pre><code>def linear_search(data, target):\n    \"\"\"Search for target in data using linear search.\n    Returns the index if found, or -1 if not found.\"\"\"\n    for i in range(len(data)):\n        if data[i] == target:\n            return i\n    return -1\n\n# Example usage\nnumbers = [3, 8, 1, 7, 5, 2]\nresult = linear_search(numbers, 7)\nprint(f\"Found at index: {result}\")  # Output: Found at index: 3\n</code></pre> <p>Linear search works on any list \u2014 sorted or unsorted. But here's the downside: if the list has a million elements and your target is the very last one (or not in the list at all), you'll have to check all million elements. That's a lot of flipping.</p> Linear Search Visualization MicroSim"},{"location":"chapters/18-searching-and-sorting/#diagram-linear-search-step-by-step","title":"Diagram: Linear Search Step-by-Step","text":"<p>Type: microsim sim-id: linear-search-visualization Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: execute, demonstrate</p> <p>Learning Objective: Students will be able to execute a linear search on a given array by stepping through the algorithm and predicting whether each element matches the target.</p> <p>Purpose: An interactive MicroSim that displays an array of colored bars (heights represent values). The student picks a target, and the simulation highlights each bar one at a time as the linear search scans from left to right.</p> <p>Layout:</p> <ul> <li>Top: Title \"Linear Search\" and a target value input field</li> <li>Center: Array displayed as vertical bars. Each bar labeled with its value. The currently inspected bar glows yellow. Bars that have been checked but didn't match turn gray. A matching bar turns green.</li> <li>Bottom: Step counter and status message (\"Checking index 3... Not a match\" or \"Found at index 3!\")</li> </ul> <p>Interactive controls:</p> <ul> <li>Input field for the target value (or dropdown with preset values)</li> <li>\"Step\" button: advance one comparison</li> <li>\"Auto Search\" button: animate the full search</li> <li>\"Shuffle\" button: randomize the array</li> <li>\"Reset\" button: clear and start over</li> <li>Speed slider for auto search</li> </ul> <p>Visual style: Colorful vertical bars with smooth transitions. Active bar bounces slightly. Found bar pulses green.</p> <p>Instructional Rationale: Step-by-step visualization connects the abstract loop of linear search to a concrete visual. Students can predict the next comparison before pressing \"Step,\" reinforcing active learning.</p>"},{"location":"chapters/18-searching-and-sorting/#binary-search-divide-and-conquer","title":"Binary Search: Divide and Conquer","text":"<p>What if the list is already sorted? Then we can do something much smarter. Binary search works by repeatedly cutting the list in half. At each step, you compare the target to the middle element:</p> <ul> <li>If the target equals the middle element, you're done!</li> <li>If the target is smaller, search the left half.</li> <li>If the target is larger, search the right half.</li> </ul> <p>It's like the classic \"guess the number\" game. Someone picks a number between 1 and 100, and you guess the middle: \"Is it 50?\" \"Too high.\" \"Is it 25?\" \"Too low.\" \"Is it 37?\" Each guess eliminates half the remaining possibilities.</p> <p>Let's walk through an example. Our sorted list is:</p> <pre><code>[2, 5, 8, 12, 16, 23, 38, 56, 72, 91]\n</code></pre> <p>We're searching for <code>23</code>.</p> Step Low High Mid list[mid] Action 1 0 9 4 16 23 &gt; 16, search right half 2 5 9 7 56 23 &lt; 56, search left half 3 5 6 5 23 23 == 23, found it! <p>Only 3 comparisons to search a list of 10 elements! With linear search, we might have needed up to 10. Here's the Python code:</p> <pre><code>def binary_search(data, target):\n    \"\"\"Search for target in a sorted list using binary search.\n    Returns the index if found, or -1 if not found.\"\"\"\n    low = 0\n    high = len(data) - 1\n\n    while low &lt;= high:\n        mid = (low + high) // 2\n        if data[mid] == target:\n            return mid\n        elif data[mid] &lt; target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1\n\n# Example usage\nsorted_numbers = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]\nresult = binary_search(sorted_numbers, 23)\nprint(f\"Found at index: {result}\")  # Output: Found at index: 5\n</code></pre> <p>Monty says: You've got this!</p> <p> Here's a wild fact: binary search on a sorted list of one billion items finds any element in at most 30 comparisons. That's because ( \\log_2(1{,}000{,}000{,}000) \\approx 30 ). Linear search might need all one billion checks. That's the power of cutting things in half!</p> <p>Important caveat: Binary search only works on sorted data. If your list isn't sorted, you have to sort it first (or use linear search instead).</p> Binary Search Visualization MicroSim"},{"location":"chapters/18-searching-and-sorting/#diagram-binary-search-step-by-step","title":"Diagram: Binary Search Step-by-Step","text":"<p>Type: microsim sim-id: binary-search-visualization Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: execute, trace</p> <p>Learning Objective: Students will be able to trace through a binary search algorithm on a sorted array, identifying the low, high, and mid pointers at each step.</p> <p>Purpose: An interactive MicroSim showing a sorted array of bars. At each step, the algorithm highlights the mid element and eliminates half the array (graying out the discarded half). Pointer markers for <code>low</code>, <code>high</code>, and <code>mid</code> move along the array.</p> <p>Layout:</p> <ul> <li>Top: Title \"Binary Search\" and target value input</li> <li>Center: Sorted array displayed as vertical bars. Three labeled pointer arrows (low = blue, mid = yellow, high = red) sit below the bars. The active search range is bright; eliminated portions fade to gray.</li> <li>Bottom: Step log showing each comparison (\"Step 2: mid=7, list[7]=56, 23 &lt; 56, search left\")</li> </ul> <p>Interactive controls:</p> <ul> <li>Input field for target value</li> <li>\"Step\" button: advance one comparison</li> <li>\"Auto Search\" button: animate the full search</li> <li>\"Reset\" button</li> <li>Speed slider</li> </ul> <p>Visual style: Sorted bars in gradient from short to tall. Active range stays colorful; eliminated range fades. Mid element bounces on inspection.</p> <p>Instructional Rationale: Visualizing the shrinking search range makes the \"divide and conquer\" strategy tangible. Pointer labels reinforce the roles of low, high, and mid variables.</p>"},{"location":"chapters/18-searching-and-sorting/#search-comparison","title":"Search Comparison","text":"<p>Now let's put these two algorithms side by side. This search comparison reveals when to use each one:</p> Feature Linear Search Binary Search Requires sorted data? No Yes Best case ( O(1) ) \u2014 first element ( O(1) ) \u2014 middle element Worst case ( O(n) ) \u2014 last element or not found ( O(\\log n) ) \u2014 not found Average case ( O(n) ) ( O(\\log n) ) Easy to implement? Very easy Slightly trickier <p>When to use linear search: Your data is unsorted, your list is small, or you only need to search once (not worth sorting first).</p> <p>When to use binary search: Your data is already sorted and you'll be searching many times. The upfront cost of sorting pays off with much faster searches.</p>"},{"location":"chapters/18-searching-and-sorting/#sorting-putting-things-in-order","title":"Sorting: Putting Things in Order","text":"<p>Now that we've seen how powerful binary search is on sorted data, the natural question is: how do we sort data in the first place? Sorting is one of the most studied problems in all of computer science. There are dozens of sorting algorithms, each with different strengths.</p> <p>We'll focus on three: selection sort, insertion sort, and merge sort. For each one, we'll walk through a concrete example with a small array.</p>"},{"location":"chapters/18-searching-and-sorting/#selection-sort-find-the-smallest-repeat","title":"Selection Sort: Find the Smallest, Repeat","text":"<p>Selection sort works by repeatedly finding the smallest element in the unsorted portion of the list and swapping it into its correct position.</p> <p>Here's the idea: scan the entire list to find the minimum value, then swap it with the first element. Now the first element is sorted. Next, scan the rest of the list (everything after index 0) to find the new minimum, and swap it with the second element. Keep going until the whole list is sorted.</p> <p>Let's sort <code>[29, 10, 14, 37, 13]</code>:</p> Pass Action List State Start [29, 10, 14, 37, 13] 1 Min of [29,10,14,37,13] is 10. Swap with index 0. [10, 29, 14, 37, 13] 2 Min of [29,14,37,13] is 13. Swap with index 1. [10, 13, 14, 37, 29] 3 Min of [14,37,29] is 14. Already at index 2. [10, 13, 14, 37, 29] 4 Min of [37,29] is 29. Swap with index 3. [10, 13, 14, 29, 37] Done [10, 13, 14, 29, 37] <pre><code>def selection_sort(data):\n    \"\"\"Sort a list in place using selection sort.\"\"\"\n    n = len(data)\n    for i in range(n):\n        # Find the index of the minimum element in data[i:]\n        min_index = i\n        for j in range(i + 1, n):\n            if data[j] &lt; data[min_index]:\n                min_index = j\n        # Swap the found minimum with the element at index i\n        data[i], data[min_index] = data[min_index], data[i]\n    return data\n\nnumbers = [29, 10, 14, 37, 13]\nprint(selection_sort(numbers))  # Output: [10, 13, 14, 29, 37]\n</code></pre> <p>Selection sort always makes the same number of comparisons regardless of the input, so its time complexity is ( O(n^2) ) in all cases. On the upside, it makes very few swaps \u2014 at most ( n - 1 ).</p>"},{"location":"chapters/18-searching-and-sorting/#insertion-sort-build-a-sorted-hand","title":"Insertion Sort: Build a Sorted Hand","text":"<p>Insertion sort works the way most people sort playing cards. You pick up cards one at a time and insert each new card into its correct position among the cards you're already holding.</p> <p>Start with the second element. Compare it to the first \u2014 if it's smaller, shift the first element right and insert. Then take the third element and insert it in the right spot among the first two. Continue until every element has been inserted into the sorted portion.</p> <p>Let's sort <code>[29, 10, 14, 37, 13]</code>:</p> Pass Key Action List State Start [29, 10, 14, 37, 13] 1 10 10 &lt; 29, shift 29 right, insert 10 [10, 29, 14, 37, 13] 2 14 14 &lt; 29, shift 29 right; 14 &gt; 10, insert [10, 14, 29, 37, 13] 3 37 37 &gt; 29, already in place [10, 14, 29, 37, 13] 4 13 13 &lt; 37, shift; 13 &lt; 29, shift; 13 &lt; 14, shift; 13 &gt; 10, insert [10, 13, 14, 29, 37] <pre><code>def insertion_sort(data):\n    \"\"\"Sort a list in place using insertion sort.\"\"\"\n    for i in range(1, len(data)):\n        key = data[i]\n        j = i - 1\n        # Shift elements that are greater than key to the right\n        while j &gt;= 0 and data[j] &gt; key:\n            data[j + 1] = data[j]\n            j -= 1\n        data[j + 1] = key\n    return data\n\nnumbers = [29, 10, 14, 37, 13]\nprint(insertion_sort(numbers))  # Output: [10, 13, 14, 29, 37]\n</code></pre> <p>Insertion sort is ( O(n^2) ) in the worst case (a reverse-sorted list), but it shines on nearly sorted data \u2014 in that case, it approaches ( O(n) ). It's also great for small lists.</p> <p>Monty says: Let's debug this together!</p> <p> Here's a handy trick: Python's built-in <code>sorted()</code> function actually uses Timsort, which is a hybrid algorithm based on insertion sort and merge sort. So the ideas in this chapter power the sorting you use every day in Python!</p>"},{"location":"chapters/18-searching-and-sorting/#merge-sort-divide-sort-merge","title":"Merge Sort: Divide, Sort, Merge","text":"<p>Merge sort takes a completely different approach. Instead of scanning through the list repeatedly, it uses a strategy called divide and conquer: split the list in half, recursively sort each half, then merge the two sorted halves back together.</p> <p>The merging step is the clever part. When you merge two already-sorted lists, you just compare the first element of each list and take the smaller one. Repeat until both lists are empty. This merging process is very efficient.</p> <p>Let's sort <code>[38, 27, 43, 3, 9, 82, 10]</code>:</p> <p>Step 1 \u2014 Divide:</p> <pre><code>[38, 27, 43, 3, 9, 82, 10]\n         /              \\\n  [38, 27, 43, 3]    [9, 82, 10]\n     /       \\          /      \\\n [38, 27]  [43, 3]   [9, 82]  [10]\n  /   \\     /   \\     /   \\      |\n[38] [27] [43]  [3] [9]  [82]  [10]\n</code></pre> <p>Step 2 \u2014 Merge back together (sorted):</p> <pre><code>[27, 38] [3, 43]   [9, 82]  [10]\n     \\     /          \\      /\n  [3, 27, 38, 43]    [9, 10, 82]\n         \\              /\n  [3, 9, 10, 27, 38, 43, 82]\n</code></pre> <p>Here's the Python implementation. Merge sort recursion is a textbook example of how recursion naturally solves divide-and-conquer problems:</p> <pre><code>def merge_sort(data):\n    \"\"\"Sort a list using merge sort (returns a new sorted list).\"\"\"\n    # Base case: a list of 0 or 1 elements is already sorted\n    if len(data) &lt;= 1:\n        return data\n\n    # Divide: split the list in half\n    mid = len(data) // 2\n    left_half = merge_sort(data[:mid])\n    right_half = merge_sort(data[mid:])\n\n    # Conquer: merge the two sorted halves\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    \"\"\"Merge two sorted lists into one sorted list.\"\"\"\n    result = []\n    i = 0  # pointer for left\n    j = 0  # pointer for right\n\n    while i &lt; len(left) and j &lt; len(right):\n        if left[i] &lt;= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    # Append any remaining elements\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\n\nnumbers = [38, 27, 43, 3, 9, 82, 10]\nprint(merge_sort(numbers))  # Output: [3, 9, 10, 27, 38, 43, 82]\n</code></pre> <p>Notice the base case: a list with zero or one elements is already sorted. That's what stops the recursion. Each recursive call splits the list in half, and the <code>merge</code> function combines them back in sorted order.</p> <p>Merge sort's time complexity is ( O(n \\log n) ) in all cases \u2014 best, average, and worst. That's significantly faster than ( O(n^2) ) for large lists. The tradeoff? It uses extra memory to store the temporary merged lists.</p> Sorting Algorithm Comparison MicroSim"},{"location":"chapters/18-searching-and-sorting/#diagram-sorting-algorithm-race","title":"Diagram: Sorting Algorithm Race","text":"<p>Type: microsim sim-id: sorting-algorithm-race Library: p5.js Status: Specified</p> <p>Bloom Level: Analyze (L4) Bloom Verb: compare, differentiate</p> <p>Learning Objective: Students will be able to compare the performance of selection sort, insertion sort, and merge sort by watching them sort identical arrays side by side and observing the number of comparisons and swaps each algorithm makes.</p> <p>Purpose: A side-by-side animated race between three sorting algorithms. All three operate on identical copies of the same random array simultaneously, allowing students to visually see the speed differences.</p> <p>Layout:</p> <ul> <li>Three columns, one per algorithm: \"Selection Sort,\" \"Insertion Sort,\" \"Merge Sort\"</li> <li>Each column shows an array as vertical bars</li> <li>Below each column: comparison counter, swap/move counter, and elapsed step counter</li> <li>Bottom: shared controls</li> </ul> <p>Interactive controls:</p> <ul> <li>\"Generate Array\" button: creates a new random array (shared across all three)</li> <li>Array size slider (10 to 100 elements)</li> <li>\"Start Race\" button: begins all three sorts simultaneously</li> <li>Speed slider (slow for studying, fast for comparison)</li> <li>\"Reset\" button</li> <li>Dropdown for initial arrangement: Random, Nearly Sorted, Reverse Sorted, Few Unique Values</li> </ul> <p>Visual elements:</p> <ul> <li>Bars being compared glow yellow</li> <li>Bars being swapped flash red</li> <li>Sorted portions turn green</li> <li>Step counters update in real-time</li> </ul> <p>Instructional Rationale: Side-by-side comparison directly supports the Analyze level by asking students to observe differences in algorithm behavior. Different initial arrangements (nearly sorted, reversed) reveal best-case and worst-case scenarios for each algorithm.</p>"},{"location":"chapters/18-searching-and-sorting/#sorting-comparison","title":"Sorting Comparison","text":"<p>Let's put all three algorithms into a sorting comparison table:</p> Algorithm Best Case Average Case Worst Case Space Stable? Selection Sort ( O(n^2) ) ( O(n^2) ) ( O(n^2) ) ( O(1) ) No Insertion Sort ( O(n) ) ( O(n^2) ) ( O(n^2) ) ( O(1) ) Yes Merge Sort ( O(n \\log n) ) ( O(n \\log n) ) ( O(n \\log n) ) ( O(n) ) Yes <p>Selection sort is consistent but always slow. Insertion sort is great for small or nearly sorted data. Merge sort is the champ for large datasets but uses more memory. There's no single \"best\" sorting algorithm \u2014 the right choice depends on your situation.</p>"},{"location":"chapters/18-searching-and-sorting/#stable-vs-unstable-sort","title":"Stable vs. Unstable Sort","text":"<p>Have you noticed the \"Stable?\" column in the table above? A stable sort preserves the relative order of elements that have equal values. An unstable sort might rearrange equal elements.</p> <p>Why does this matter? Imagine you have a list of students sorted by name, and you want to re-sort by grade. With a stable sort, students who have the same grade will remain in alphabetical order. With an unstable sort, their name order might get scrambled.</p> <ul> <li>Stable: Insertion sort, merge sort</li> <li>Unstable: Selection sort (a swap might jump equal elements past each other)</li> </ul> <p>When you're sorting simple numbers, stability doesn't matter. But when you're sorting complex records (like database rows), stability can be very important.</p>"},{"location":"chapters/18-searching-and-sorting/#how-good-is-your-algorithm-analyzing-efficiency","title":"How Good Is Your Algorithm? Analyzing Efficiency","text":"<p>You've now seen several algorithms. Some are fast, some are slow. But how do we measure that difference precisely? This is where we enter the world of algorithm analysis.</p>"},{"location":"chapters/18-searching-and-sorting/#algorithm-correctness","title":"Algorithm Correctness","text":"<p>Before worrying about speed, we should ask: \"Does this algorithm actually work?\" Algorithm correctness means proving that an algorithm produces the right answer for every valid input, not just the ones you tested.</p> <p>Testing helps, but it can't cover every possible input. For important algorithms, computer scientists use mathematical reasoning to prove correctness.</p>"},{"location":"chapters/18-searching-and-sorting/#loop-invariants-proof-by-repetition","title":"Loop Invariants: Proof by Repetition","text":"<p>A loop invariant is a condition that's true before the loop starts, stays true after each iteration, and is still true when the loop ends. It's like a promise the loop keeps at every step.</p> <p>Let's look at the loop invariant for insertion sort:</p> <p>At the start of each pass ( i ), the subarray <code>data[0..i-1]</code> is sorted and contains the same elements it originally had.</p> <ul> <li>Before the loop (i = 1): <code>data[0..0]</code> is a single element \u2014 trivially sorted. True!</li> <li>During each pass: We insert <code>data[i]</code> into its correct position in the sorted subarray. After inserting, <code>data[0..i]</code> is sorted. True!</li> <li>After the loop (i = n): <code>data[0..n-1]</code> is the entire array, and it's sorted. That's our answer!</li> </ul> <p>This three-step reasoning (initialization, maintenance, termination) is a powerful technique for verifying that loops do what they claim.</p> <p>Monty says: Watch out!</p> <p> A common mistake when writing binary search is using <code>low + high</code> instead of <code>low + (high - low) // 2</code> for the midpoint calculation. In languages with fixed-size integers, <code>low + high</code> can overflow! Python handles big numbers gracefully, but it's a good habit to use the safer formula \u2014 and it shows interviewers you know your stuff.</p>"},{"location":"chapters/18-searching-and-sorting/#big-o-notation-the-language-of-efficiency","title":"Big-O Notation: The Language of Efficiency","text":"<p>Big-O notation is a mathematical shorthand that describes how an algorithm's running time (or memory usage) grows as the input size increases. It doesn't tell you the exact time in seconds \u2014 instead, it tells you the growth rate.</p> <p>Think of it this way: if you're mailing letters, the cost grows with the number of letters. Big-O tells you whether that growth is steady (one extra stamp per letter) or explosive (doubling with each letter).</p> <p>We use Big-O to answer the question: \"If I double the size of my input, what happens to the running time?\"</p>"},{"location":"chapters/18-searching-and-sorting/#time-complexity","title":"Time Complexity","text":"<p>Time complexity measures how the number of operations an algorithm performs grows with input size ( n ). It's what we usually mean when we say an algorithm is \"fast\" or \"slow.\"</p> <p>We focus on the worst case because it gives us a guarantee: \"No matter what input you throw at me, I'll never be slower than this.\" You can also analyze best-case and average-case, but worst-case is the standard.</p>"},{"location":"chapters/18-searching-and-sorting/#space-complexity","title":"Space Complexity","text":"<p>Space complexity measures how much extra memory an algorithm needs beyond the input itself. An algorithm that sorts a list in place (like selection sort or insertion sort) uses ( O(1) ) extra space \u2014 just a few temporary variables. Merge sort creates new lists during merging, so it uses ( O(n) ) extra space.</p> <p>Both time and space matter. A blazing-fast algorithm that requires more memory than your computer has is no good. There's often a tradeoff between the two.</p>"},{"location":"chapters/18-searching-and-sorting/#the-key-complexity-classes","title":"The Key Complexity Classes","text":"<p>Let's break down the three most important complexity classes you'll encounter in this course.</p>"},{"location":"chapters/18-searching-and-sorting/#constant-time-o1","title":"Constant Time: ( O(1) )","text":"<p>Constant time means the operation takes the same amount of time regardless of how big the input is. Accessing an element by index in a list is ( O(1) ) \u2014 whether the list has 10 elements or 10 million, <code>data[5]</code> takes the same time.</p> <pre><code>def get_first(data):\n    \"\"\"Return the first element \u2014 O(1) time.\"\"\"\n    return data[0]\n</code></pre> <p>Double the list size? The time stays the same. That's constant time.</p>"},{"location":"chapters/18-searching-and-sorting/#linear-time-on","title":"Linear Time: ( O(n) )","text":"<p>Linear time means the running time grows proportionally with the input size. If the input doubles, the time roughly doubles. Linear search is ( O(n) ) \u2014 in the worst case, you check every element once.</p> <pre><code>def sum_all(data):\n    \"\"\"Sum all elements \u2014 O(n) time.\"\"\"\n    total = 0\n    for value in data:\n        total += value\n    return total\n</code></pre> <p>A list with 1,000 elements takes about 1,000 steps. A list with 2,000 takes about 2,000. Nice and predictable.</p>"},{"location":"chapters/18-searching-and-sorting/#quadratic-time-on2","title":"Quadratic Time: ( O(n^2) )","text":"<p>Quadratic time means the running time grows with the square of the input size. If the input doubles, the time roughly quadruples. Selection sort and insertion sort (worst case) are both ( O(n^2) ) because they use nested loops \u2014 one loop inside another.</p> <pre><code>def all_pairs(data):\n    \"\"\"Print all pairs \u2014 O(n^2) time.\"\"\"\n    for i in range(len(data)):\n        for j in range(len(data)):\n            print(data[i], data[j])\n</code></pre> <p>A list of 100 elements produces 10,000 pairs. A list of 200 produces 40,000. Things get ugly fast.</p>"},{"location":"chapters/18-searching-and-sorting/#big-o-growth-rate-comparison","title":"Big-O Growth Rate Comparison","text":"<p>Here's a table that shows how these growth rates compare as the input size ( n ) increases:</p> ( n ) ( O(1) ) ( O(\\log n) ) ( O(n) ) ( O(n \\log n) ) ( O(n^2) ) 10 1 3 10 33 100 100 1 7 100 664 10,000 1,000 1 10 1,000 9,966 1,000,000 10,000 1 13 10,000 132,877 100,000,000 100,000 1 17 100,000 1,660,964 10,000,000,000 <p>Look at that last row. At ( n = 100{,}000 ), an ( O(n^2) ) algorithm performs ten billion operations while an ( O(n \\log n) ) algorithm does about 1.7 million. That's the difference between a few seconds and several hours.</p> Big-O Growth Rate Chart MicroSim <p>Here's a visual summary of how each complexity class feels:</p> Complexity Nickname How It Feels ( O(1) ) Constant Instant, no matter what ( O(\\log n) ) Logarithmic Barely noticeable growth ( O(n) ) Linear Scales proportionally \u2014 fair and square ( O(n \\log n) ) Linearithmic A little worse than linear, but manageable ( O(n^2) ) Quadratic Slows down fast \u2014 avoid for large data <p>Monty says: You've got this!</p> <p> Big-O notation can feel abstract at first, but here's the thing: once you understand these five growth rates, you can quickly evaluate almost any algorithm you encounter. It's one of the most useful tools in a programmer's toolkit. You're building real computer science intuition right now!</p>"},{"location":"chapters/18-searching-and-sorting/#diagram-big-o-growth-rate-chart","title":"Diagram: Big-O Growth Rate Chart","text":"<p>Type: microsim sim-id: big-o-growth-chart Library: p5.js Status: Specified</p> <p>Bloom Level: Analyze (L4) Bloom Verb: compare, classify</p> <p>Learning Objective: Students will be able to classify common Big-O complexity classes by their growth rate and predict how doubling the input size affects running time for each class.</p> <p>Purpose: An interactive chart plotting the growth curves for ( O(1) ), ( O(\\log n) ), ( O(n) ), ( O(n \\log n) ), and ( O(n^2) ) on the same axes. Students can adjust the input size and see how dramatically the curves diverge.</p> <p>Layout:</p> <ul> <li>X-axis: Input size ( n ) (from 0 to adjustable maximum)</li> <li>Y-axis: Number of operations</li> <li>Five labeled curves, each in a distinct color:</li> <li>( O(1) ) \u2014 flat green line</li> <li>( O(\\log n) ) \u2014 gentle blue curve</li> <li>( O(n) ) \u2014 diagonal orange line</li> <li>( O(n \\log n) ) \u2014 steeper purple curve</li> <li>( O(n^2) ) \u2014 steeply rising red curve</li> <li>Right panel: legend with checkboxes to show/hide individual curves</li> </ul> <p>Interactive controls:</p> <ul> <li>Slider to set the maximum ( n ) value on the x-axis (10 to 100,000)</li> <li>Checkboxes to toggle each curve on/off</li> <li>Hover over any point on a curve to see the exact ( (n, \\text{operations}) ) values</li> <li>\"Zoom In\" button to focus on the range where ( O(n) ) and ( O(n \\log n) ) curves are close together (showing they diverge at scale)</li> </ul> <p>Visual elements:</p> <ul> <li>Curves drawn as smooth lines with distinct colors</li> <li>Grid lines for reference</li> <li>Annotation arrows pointing out key observations (e.g., \"At n=1000, O(n^2) is 1000x larger than O(n)\")</li> </ul> <p>Instructional Rationale: Seeing all growth curves on the same chart makes the dramatic differences between complexity classes visceral. The interactive slider lets students discover for themselves that ( O(n^2) ) \"explodes\" at large ( n ), which is far more impactful than reading about it.</p>"},{"location":"chapters/18-searching-and-sorting/#putting-it-all-together-choosing-the-right-algorithm","title":"Putting It All Together: Choosing the Right Algorithm","text":"<p>Algorithm design is all about tradeoffs. Here's a decision guide for searching and sorting:</p> <p>For searching:</p> <ul> <li>Small list or unsorted data? Use linear search. Simple and reliable.</li> <li>Large sorted data with many searches? Use binary search. Dramatically faster.</li> </ul> <p>For sorting:</p> <ul> <li>Tiny list (under ~20 elements)? Insertion sort is fast and simple.</li> <li>Nearly sorted data? Insertion sort shines \u2014 close to ( O(n) ).</li> <li>Large dataset? Merge sort guarantees ( O(n \\log n) ) every time.</li> <li>Memory is tight? Selection sort or insertion sort use ( O(1) ) extra space.</li> </ul> <p>In practice, Python's built-in <code>sorted()</code> and <code>.sort()</code> use Timsort, which intelligently combines insertion sort for small runs with merge sort for combining them. So when you write <code>sorted(my_list)</code> in Python, you're getting the best of both worlds.</p> Algorithm Decision Flowchart <p>Monty says: Nice work, coder!</p> <p> You just tackled one of the most important chapters in computer science! You can now search through data, sort it into order, prove your algorithms are correct, and analyze how fast they run. These skills will serve you in every programming challenge ahead. High five!</p>"},{"location":"chapters/18-searching-and-sorting/#diagram-choosing-a-search-or-sort-algorithm","title":"Diagram: Choosing a Search or Sort Algorithm","text":"<p>Type: diagram sim-id: algorithm-decision-flowchart Library: p5.js Status: Specified</p> <p>Bloom Level: Evaluate (L5) Bloom Verb: select, justify</p> <p>Learning Objective: Students will be able to select an appropriate search or sort algorithm for a given scenario and justify their choice based on input characteristics and complexity requirements.</p> <p>Purpose: An interactive decision tree that asks the student a series of yes/no questions about their data and requirements, then recommends an algorithm and explains why.</p> <p>Layout:</p> <ul> <li>Decision tree starting with \"Are you searching or sorting?\"</li> <li>Search branch: \"Is the data sorted?\" leads to binary search (yes) or linear search (no)</li> <li>Sort branch: \"How large is the dataset?\" -&gt; \"Is it nearly sorted?\" -&gt; \"Is memory limited?\" Each branch leads to a recommended algorithm with a brief justification.</li> <li>Clicking any leaf node shows the algorithm's Big-O complexity and a one-sentence explanation.</li> </ul> <p>Interactive elements:</p> <ul> <li>Click yes/no at each diamond node to navigate the tree</li> <li>Leaf nodes are color-coded by algorithm</li> <li>\"Start Over\" button at any point</li> <li>Optional \"Quiz Mode\" that presents a scenario and asks the student to navigate to the correct algorithm</li> </ul> <p>Visual style: Tree flows top to bottom with branching arrows. Active path is highlighted. Inactive branches are dimmed.</p> <p>Instructional Rationale: A decision tree supports the Evaluate level by requiring students to consider multiple criteria and justify algorithm selection. Quiz mode provides practice applying the decision framework to novel scenarios.</p>"},{"location":"chapters/18-searching-and-sorting/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Algorithm design means planning your step-by-step strategy before coding. Use pseudocode and flowcharts to sketch out your logic first.</li> <li>Linear search checks each element one by one \u2014 simple but ( O(n) ). Binary search cuts a sorted list in half each time \u2014 powerful at ( O(\\log n) ).</li> <li>Selection sort repeatedly finds the minimum and swaps it into place \u2014 always ( O(n^2) ).</li> <li>Insertion sort builds a sorted portion by inserting each element where it belongs \u2014 ( O(n^2) ) worst case but ( O(n) ) on nearly sorted data.</li> <li>Merge sort divides the list in half, recursively sorts both halves, and merges them \u2014 guaranteed ( O(n \\log n) ) but uses ( O(n) ) extra space.</li> <li>A stable sort preserves the order of equal elements; an unstable sort does not.</li> <li>Algorithm correctness can be verified using loop invariants \u2014 conditions that remain true before, during, and after each loop iteration.</li> <li>Big-O notation describes growth rate: ( O(1) ) is constant, ( O(n) ) is linear, ( O(n^2) ) is quadratic. Time complexity measures operations; space complexity measures memory.</li> <li>There's no single \"best\" algorithm \u2014 the right choice depends on your data size, whether it's sorted, and your memory constraints.</li> </ul> Check Your Understanding: Why can't you use binary search on an unsorted list? <p>Binary search relies on the list being sorted so it can eliminate half the remaining elements at each step. When it compares the target to the middle element, it assumes everything to the left is smaller and everything to the right is larger. If the list isn't sorted, that assumption breaks down, and the algorithm might skip right past the target value. You'd need to use linear search on unsorted data, or sort the list first.</p> Check Your Understanding: You have a list of 10,000 student records sorted by ID number. Which search algorithm should you use to find a specific student, and how many comparisons will it take at most? <p>You should use binary search because the data is already sorted. The maximum number of comparisons is ( \\lceil \\log_2(10{,}000) \\rceil = 14 ). That means you can find any student among ten thousand records in at most 14 comparisons. Linear search could take up to 10,000 comparisons in the worst case \u2014 that's over 700 times more!</p> Check Your Understanding: Insertion sort has a worst-case time complexity of O(n^2), but it can perform much better. When does insertion sort approach O(n) performance, and why? <p>Insertion sort approaches ( O(n) ) when the list is already sorted or nearly sorted. In that case, each new element is already in (or very close to) its correct position. The inner <code>while</code> loop barely executes because there are few or no elements to shift. Each of the ( n ) passes does roughly ( O(1) ) work, so the total is close to ( O(n) ). This is why insertion sort is excellent for data that's \"almost sorted\" \u2014 like a list where only a few elements are out of place.</p>"},{"location":"chapters/19-algorithm-analysis/","title":"Algorithm Analysis and Problem Solving","text":""},{"location":"chapters/19-algorithm-analysis/#algorithm-analysis-and-problem-solving","title":"Algorithm Analysis and Problem Solving","text":""},{"location":"chapters/19-algorithm-analysis/#summary","title":"Summary","text":"<p>This chapter deepens students' understanding of algorithm analysis and introduces problem-solving strategies. Students will learn about logarithmic and linearithmic time complexity, best/average/worst case analysis, empirical analysis, and counting operations. The chapter covers algorithmic strategies including brute force, divide and conquer, and greedy approaches. Common programming patterns like two pointer, sliding window, and frequency counter are introduced. Memoization is covered as an optimization technique that bridges recursion and dictionaries.</p>"},{"location":"chapters/19-algorithm-analysis/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 16 concepts from the learning graph:</p> <ol> <li>Logarithmic Time O(log n)</li> <li>Linearithmic Time</li> <li>Best Average Worst Case</li> <li>Empirical Analysis</li> <li>Counting Operations</li> <li>Brute Force Approach</li> <li>Divide and Conquer</li> <li>Greedy Algorithms</li> <li>Algorithm Tradeoffs</li> <li>Efficiency vs Readability</li> <li>Two Pointer Technique</li> <li>Sliding Window Pattern</li> <li>Frequency Counter Pattern</li> <li>Recursion in Algorithms</li> <li>Algorithm Visualization</li> <li>Memoization</li> </ol>"},{"location":"chapters/19-algorithm-analysis/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 2: Python Fundamentals</li> <li>Chapter 7: Higher-Order Functions and Recursion</li> <li>Chapter 8: Lists</li> <li>Chapter 11: Dictionaries</li> <li>Chapter 17: Testing and Debugging</li> <li>Chapter 18: Searching and Sorting</li> </ul> <p>Monty says: Let's code this!</p> <p> Welcome back, coders! In Chapter 18 you learned the basics of Big-O notation and saw how different sorting algorithms compare. Now we're going to level up. You'll learn why some algorithms seem almost magical in their speed, discover powerful problem-solving strategies, and pick up programming patterns that real software engineers use every day. Ready to think like an algorithm designer? Let's do this!</p>"},{"location":"chapters/19-algorithm-analysis/#beyond-linear-logarithmic-time","title":"Beyond Linear: Logarithmic Time","text":"<p>In Chapter 18 you met ( O(1) ), ( O(n) ), and ( O(n^2) ). But there's a complexity class that sits between constant and linear time, and it's one of the most exciting ones in all of computer science.</p> <p>Logarithmic Time ( O(\\log n) ) describes algorithms where each step cuts the remaining work in half. Binary search is the classic example. If you have a sorted list of 1,000 items, binary search needs at most about 10 comparisons. Double the list to 2,000 items? You only need about 11 comparisons. That's the power of logarithms.</p> <p>Here's the intuition: a logarithm answers the question \"how many times can I divide this number by 2 before I reach 1?\" For ( n = 1{,}024 ), the answer is 10, because ( 2^{10} = 1{,}024 ). So ( \\log_2(1{,}024) = 10 ).</p> <pre><code>def binary_search(sorted_list, target):\n    \"\"\"O(log n) \u2014 cuts the search space in half each step.\"\"\"\n    low = 0\n    high = len(sorted_list) - 1\n\n    while low &lt;= high:\n        mid = (low + high) // 2\n        if sorted_list[mid] == target:\n            return mid\n        elif sorted_list[mid] &lt; target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return -1  # not found\n</code></pre> <p>Why does this matter? Imagine searching through a phone book with one million names. A linear search might need up to 1,000,000 comparisons. Binary search? About 20. That's not a small improvement \u2014 that's the difference between waiting a minute and getting your answer in a blink.</p>"},{"location":"chapters/19-algorithm-analysis/#linearithmic-time-the-sweet-spot","title":"Linearithmic Time: The Sweet Spot","text":"<p>Now let's meet Linearithmic Time, also written ( O(n \\log n) ). This is the time complexity of efficient sorting algorithms like merge sort, quicksort (on average), and Python's built-in <code>sorted()</code> function (which uses Timsort).</p> <p>Think of it as \"do something logarithmic for each of the ( n ) items.\" Merge sort, for example, divides the list in half repeatedly (( \\log n ) levels of splitting), and at each level it does ( O(n) ) work to merge everything back together.</p> <p>Here's the key fact: you cannot sort a list of arbitrary items faster than ( O(n \\log n) ) using comparisons. This is a mathematical proof, not just a practical limit. So when you see an ( O(n \\log n) ) sorting algorithm, you're looking at the best possible general-purpose sort.</p> Complexity Class Comparison Chart"},{"location":"chapters/19-algorithm-analysis/#diagram","title":"Diagram:","text":"Complexity Class Name Example Operations for ( n = 1{,}000 ) ( O(1) ) Constant Dictionary lookup 1 ( O(\\log n) ) Logarithmic Binary search ~10 ( O(n) ) Linear Linear search 1,000 ( O(n \\log n) ) Linearithmic Merge sort ~10,000 ( O(n^2) ) Quadratic Selection sort 1,000,000 ( O(2^n) ) Exponential All subsets ( \\approx 10^{301} ) <p>Notice how the jump from ( O(n \\log n) ) to ( O(n^2) ) is a factor of 100 at ( n = 1{,}000 ). At ( n = 1{,}000{,}000 ), that factor becomes 50,000. The difference between \"good enough\" and \"unacceptable\" is often one complexity class.</p>"},{"location":"chapters/19-algorithm-analysis/#best-average-and-worst-case","title":"Best, Average, and Worst Case","text":"<p>So far we've mostly talked about worst-case complexity. But algorithms don't always behave the same way on every input. Best Average Worst Case analysis looks at all three scenarios.</p> <p>Consider linear search in a list of ( n ) items:</p> <ul> <li>Best case: The target is the very first element. ( O(1) ).</li> <li>Worst case: The target is the last element (or not present). ( O(n) ).</li> <li>Average case: On average, you'll check about half the list. ( O(n) ) \u2014 same order as worst case, but with a smaller constant.</li> </ul> <p>Why does this matter? Quicksort is a great example. Its average case is ( O(n \\log n) ), which is excellent. But its worst case is ( O(n^2) ), which happens when the pivot choices are terrible (like always picking the smallest or largest element). That's why Python's built-in sort uses Timsort instead of plain quicksort \u2014 Timsort guarantees ( O(n \\log n) ) in the worst case.</p> <p>Monty says: Let's debug this together!</p> <p> When someone asks \"what's the time complexity?\" they usually mean the worst case unless they say otherwise. The worst case is the safest guarantee \u2014 it tells you the maximum time your program will ever need.</p>"},{"location":"chapters/19-algorithm-analysis/#counting-operations","title":"Counting Operations","text":"<p>Before you can classify an algorithm's complexity, you need to know how to count operations. This means stepping through your code and tallying how many times each line runs as a function of the input size ( n ).</p> <p>Let's count the operations in a simple function:</p> <pre><code>def sum_of_squares(n):\n    total = 0              # 1 assignment\n    for i in range(n):     # loop runs n times\n        total += i * i     # 1 multiplication + 1 addition per iteration\n    return total           # 1 return\n</code></pre> <p>The assignment and return each happen once: that's 2 operations. Inside the loop, we do 2 operations per iteration, and the loop runs ( n ) times. Total: ( 2n + 2 ) operations. In Big-O, we drop the constants and lower-order terms: ( O(n) ).</p> <p>Now let's count a nested loop:</p> <pre><code>def all_pairs(items):\n    count = 0\n    for i in range(len(items)):         # n iterations\n        for j in range(len(items)):     # n iterations each\n            count += 1                  # 1 operation\n    return count\n</code></pre> <p>The inner operation runs ( n \\times n = n^2 ) times, so this is ( O(n^2) ).</p> Operation Counting Walkthrough"},{"location":"chapters/19-algorithm-analysis/#diagram_1","title":"Diagram:","text":"<p>Here's a step-by-step trace for <code>sum_of_squares(4)</code>:</p> Step i Operation total 1 \u2014 <code>total = 0</code> 0 2 0 <code>total += 0 * 0</code> 0 3 1 <code>total += 1 * 1</code> 1 4 2 <code>total += 2 * 2</code> 5 5 3 <code>total += 3 * 3</code> 14 6 \u2014 <code>return 14</code> 14 <p>Total loop body executions: 4 (which is ( n )). Total operations: ( 2 \\times 4 + 2 = 10 ). Simplified: ( O(n) ).</p>"},{"location":"chapters/19-algorithm-analysis/#empirical-analysis-measuring-real-performance","title":"Empirical Analysis: Measuring Real Performance","text":"<p>Theory is great, but sometimes you just want to see the numbers. Empirical Analysis means running your code, measuring the actual time it takes, and looking for patterns. Python's <code>time</code> module makes this easy.</p> <pre><code>import time\n\ndef time_algorithm(func, *args):\n    \"\"\"Measure the execution time of a function.\"\"\"\n    start = time.time()\n    result = func(*args)\n    end = time.time()\n    return end - start, result\n\n# Compare linear search vs binary search\nimport random\n\ndef linear_search(lst, target):\n    for i, val in enumerate(lst):\n        if val == target:\n            return i\n    return -1\n\nsizes = [10_000, 50_000, 100_000, 500_000, 1_000_000]\n\nprint(f\"{'Size':&gt;10} {'Linear (s)':&gt;12} {'Binary (s)':&gt;12}\")\nprint(\"-\" * 36)\n\nfor n in sizes:\n    data = list(range(n))\n    target = n - 1  # worst case: last element\n\n    t_linear, _ = time_algorithm(linear_search, data, target)\n    t_binary, _ = time_algorithm(binary_search, data, target)\n\n    print(f\"{n:&gt;10,} {t_linear:&gt;12.6f} {t_binary:&gt;12.6f}\")\n</code></pre> <p>When you run this, you'll see linear search times growing proportionally with ( n ), while binary search times barely change. That's the difference between ( O(n) ) and ( O(\\log n) ) made visible.</p> <p>Monty says: Let's debug this together!</p> <p> When doing empirical analysis, run each test several times and take the average. Other programs running on your computer can cause timing noise. Also, use large enough inputs \u2014 with ( n = 10 ), everything looks fast!</p>"},{"location":"chapters/19-algorithm-analysis/#algorithmic-strategies","title":"Algorithmic Strategies","text":"<p>Now that you can analyze algorithms, let's talk about how to design them. There are several classic strategies that programmers reach for when facing a new problem.</p>"},{"location":"chapters/19-algorithm-analysis/#brute-force-try-everything","title":"Brute Force: Try Everything","text":"<p>The Brute Force Approach is the simplest strategy: try every possible solution and pick the best one. It's not clever, but it's reliable. You're guaranteed to find the answer because you've checked everything.</p> <p>For example, to find two numbers in a list that add up to a target:</p> <pre><code>def two_sum_brute(numbers, target):\n    \"\"\"Brute force: check every pair. O(n^2).\"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if numbers[i] + numbers[j] == target:\n                return (i, j)\n    return None\n</code></pre> <p>This works, but with nested loops it's ( O(n^2) ). For large lists, that's painfully slow. Brute force is a great starting point \u2014 get something working, then optimize.</p>"},{"location":"chapters/19-algorithm-analysis/#divide-and-conquer","title":"Divide and Conquer","text":"<p>Divide and Conquer is a strategy where you break a problem into smaller subproblems, solve each one, and combine the results. Merge sort is the textbook example:</p> <ol> <li>Divide: Split the list in half.</li> <li>Conquer: Sort each half (recursively).</li> <li>Combine: Merge the two sorted halves.</li> </ol> <pre><code>def merge_sort(lst):\n    \"\"\"Divide and conquer sorting. O(n log n).\"\"\"\n    if len(lst) &lt;= 1:\n        return lst\n\n    mid = len(lst) // 2\n    left = merge_sort(lst[:mid])\n    right = merge_sort(lst[mid:])\n\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i &lt; len(left) and j &lt; len(right):\n        if left[i] &lt;= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\n</code></pre> <p>Divide and conquer works brilliantly when you can split a problem into independent subproblems of roughly equal size. Other examples include binary search and the fast Fourier transform.</p>"},{"location":"chapters/19-algorithm-analysis/#greedy-algorithms","title":"Greedy Algorithms","text":"<p>A Greedy Algorithm makes the best local choice at each step, hoping that these local choices lead to a globally optimal solution. Greedy algorithms don't look ahead or reconsider past decisions \u2014 they just grab the best option right now.</p> <p>Classic example: the coin change problem. You need to make change for 67 cents using the fewest coins possible (quarters, dimes, nickels, pennies).</p> <pre><code>def greedy_coin_change(amount):\n    \"\"\"Greedy approach to coin change. Works for US coins.\"\"\"\n    coins = [25, 10, 5, 1]\n    result = []\n\n    for coin in coins:\n        while amount &gt;= coin:\n            result.append(coin)\n            amount -= coin\n\n    return result\n\nprint(greedy_coin_change(67))\n# Output: [25, 25, 10, 5, 1, 1]  -&gt; 6 coins\n</code></pre> <p>The greedy approach works perfectly for US coins. But beware: greedy algorithms don't always give the optimal solution. If our coin denominations were [25, 15, 1], trying to make 30 cents greedily gives [25, 1, 1, 1, 1, 1] (6 coins), but the optimal answer is [15, 15] (2 coins). Greedy algorithms need to be proven correct for each specific problem.</p> Strategy Comparison Diagram"},{"location":"chapters/19-algorithm-analysis/#diagram_2","title":"Diagram:","text":"Strategy Approach When to Use Guarantee Brute Force Try all possibilities When the input is small, or as a first draft Always finds the answer Divide and Conquer Split, solve, combine When the problem splits into independent subproblems Correct if subproblems are independent Greedy Best local choice at each step When local optima lead to global optimum Must be proven for each problem <p>Brute force is your safety net. Divide and conquer is your power tool. Greedy is your shortcut \u2014 but only when the road is straight.</p>"},{"location":"chapters/19-algorithm-analysis/#algorithm-tradeoffs","title":"Algorithm Tradeoffs","text":"<p>Every algorithm involves Algorithm Tradeoffs. The most common tradeoff is time vs. space: you can often make an algorithm faster by using more memory, or save memory by accepting a slower runtime.</p> <p>For example, consider checking if a list has duplicate values:</p> <pre><code># Time-optimized: O(n) time, O(n) space\ndef has_duplicates_fast(lst):\n    seen = set()\n    for item in lst:\n        if item in seen:\n            return True\n        seen.add(item)\n    return False\n\n# Space-optimized: O(n^2) time, O(1) space\ndef has_duplicates_slow(lst):\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] == lst[j]:\n                return True\n    return False\n</code></pre> <p>The first version uses a set (extra memory) to achieve ( O(n) ) time. The second version uses no extra memory but takes ( O(n^2) ) time. Which is better? It depends on your situation. If memory is tight (like on an embedded device), the slow version might be the right choice.</p>"},{"location":"chapters/19-algorithm-analysis/#efficiency-vs-readability","title":"Efficiency vs. Readability","text":"<p>Efficiency vs Readability is another important tradeoff. Code that's hyper-optimized can be hard to understand and maintain. Code that's beautifully readable might be too slow for large inputs.</p> <pre><code># Readable but slower: O(n)\ndef is_palindrome_readable(s):\n    return s == s[::-1]\n\n# Efficient and still pretty readable: O(n) \u2014 same big-O,\n# but uses half the memory (no reversed copy)\ndef is_palindrome_efficient(s):\n    left = 0\n    right = len(s) - 1\n    while left &lt; right:\n        if s[left] != s[right]:\n            return False\n        left += 1\n        right -= 1\n    return True\n</code></pre> <p>Both are ( O(n) ), but the first creates a reversed copy of the string (extra memory), while the second uses two pointers and constant extra space. In most cases, the readable version is perfectly fine. Save the clever optimizations for when profiling tells you there's a real bottleneck.</p> <p>Monty says: Watch out!</p> <p> Don't optimize code that doesn't need optimizing! Write clear, correct code first. Only optimize if your program is actually too slow \u2014 and use empirical analysis to find the real bottleneck. Premature optimization is the root of all evil (well, at least in programming).</p>"},{"location":"chapters/19-algorithm-analysis/#programming-patterns","title":"Programming Patterns","text":"<p>Let's learn three powerful patterns that show up in coding interviews, competitions, and real-world programming. These patterns turn ( O(n^2) ) brute force solutions into elegant ( O(n) ) solutions.</p>"},{"location":"chapters/19-algorithm-analysis/#the-two-pointer-technique","title":"The Two Pointer Technique","text":"<p>The Two Pointer Technique uses two index variables that move through a data structure (usually a sorted list) from different positions. This avoids the nested loops that make brute force slow.</p> <p>Problem: Given a sorted list of numbers, find two numbers that add up to a target sum.</p> <pre><code>def two_sum_sorted(numbers, target):\n    \"\"\"Two pointer approach. O(n) for sorted input.\"\"\"\n    left = 0\n    right = len(numbers) - 1\n\n    while left &lt; right:\n        current_sum = numbers[left] + numbers[right]\n\n        if current_sum == target:\n            return (left, right)\n        elif current_sum &lt; target:\n            left += 1     # need a bigger sum\n        else:\n            right -= 1    # need a smaller sum\n\n    return None\n\n# Example\nsorted_nums = [1, 3, 5, 7, 9, 11]\nprint(two_sum_sorted(sorted_nums, 12))\n# Output: (1, 4) \u2014 because 3 + 9 = 12\n</code></pre> <p>The brute force approach checks every pair: ( O(n^2) ). The two pointer approach walks inward from both ends, making at most ( n ) steps: ( O(n) ). That's a massive improvement!</p>"},{"location":"chapters/19-algorithm-analysis/#the-sliding-window-pattern","title":"The Sliding Window Pattern","text":"<p>The Sliding Window Pattern is used when you need to examine a contiguous subarray or substring. Instead of recalculating everything from scratch each time you shift the window, you slide it by removing the outgoing element and adding the incoming one.</p> <p>Problem: Find the maximum sum of any subarray of length ( k ).</p> <pre><code>def max_subarray_sum(numbers, k):\n    \"\"\"Sliding window approach. O(n) instead of O(n*k).\"\"\"\n    if len(numbers) &lt; k:\n        return None\n\n    # Calculate the sum of the first window\n    window_sum = sum(numbers[:k])\n    max_sum = window_sum\n\n    # Slide the window: remove the leftmost, add the new rightmost\n    for i in range(k, len(numbers)):\n        window_sum += numbers[i] - numbers[i - k]\n        max_sum = max(max_sum, window_sum)\n\n    return max_sum\n\n# Example: find max sum of 3 consecutive elements\ndata = [2, 1, 5, 1, 3, 2]\nprint(max_subarray_sum(data, 3))\n# Output: 9 (from subarray [5, 1, 3])\n</code></pre> <p>Without the sliding window, you'd recalculate the sum of each subarray from scratch: ( O(n \\times k) ). With the sliding window, each element is added once and removed once: ( O(n) ).</p> Sliding Window Visualization"},{"location":"chapters/19-algorithm-analysis/#diagram_3","title":"Diagram:","text":"<p>Here's how the window slides through <code>[2, 1, 5, 1, 3, 2]</code> with ( k = 3 ):</p> <pre><code>Step 1:  [2  1  5] 1  3  2    sum = 8\nStep 2:   2 [1  5  1] 3  2    sum = 8-2+1 = 7\nStep 3:   2  1 [5  1  3] 2    sum = 7-1+3 = 9  &lt;- maximum!\nStep 4:   2  1  5 [1  3  2]   sum = 9-5+2 = 6\n</code></pre> <p>At each step, we subtract the element leaving the window (left side) and add the element entering (right side). One subtraction and one addition per step \u2014 that's ( O(1) ) per slide!</p>"},{"location":"chapters/19-algorithm-analysis/#the-frequency-counter-pattern","title":"The Frequency Counter Pattern","text":"<p>The Frequency Counter Pattern uses a dictionary (or <code>Counter</code> from the <code>collections</code> module) to count occurrences of elements. This avoids nested loops when you need to compare frequencies between two collections.</p> <p>Problem: Determine if two strings are anagrams (contain exactly the same characters).</p> <pre><code>def is_anagram(s1, s2):\n    \"\"\"Frequency counter approach. O(n) instead of O(n^2).\"\"\"\n    if len(s1) != len(s2):\n        return False\n\n    freq = {}\n    for char in s1:\n        freq[char] = freq.get(char, 0) + 1\n\n    for char in s2:\n        if char not in freq or freq[char] == 0:\n            return False\n        freq[char] -= 1\n\n    return True\n\nprint(is_anagram(\"listen\", \"silent\"))  # True\nprint(is_anagram(\"hello\", \"world\"))    # False\n</code></pre> <p>A brute force approach might sort both strings and compare them (( O(n \\log n) )), or check each character against all characters in the other string (( O(n^2) )). The frequency counter does it in a single pass through each string: ( O(n) ).</p> <p>Python also has a built-in shortcut:</p> <pre><code>from collections import Counter\n\ndef is_anagram_short(s1, s2):\n    return Counter(s1) == Counter(s2)\n</code></pre>"},{"location":"chapters/19-algorithm-analysis/#recursion-in-problem-solving","title":"Recursion in Problem Solving","text":"<p>Recursion in Algorithms is a technique where a function calls itself to solve smaller instances of the same problem. You saw recursion in Chapter 7, but here we'll see how it powers some of the most important algorithms.</p> <p>Every recursive function needs two things:</p> <ol> <li>Base case: A condition that stops the recursion.</li> <li>Recursive case: The function calling itself with a \"smaller\" input.</li> </ol> <p>Here's a recursive approach to computing the power of a number efficiently:</p> <pre><code>def power(base, exponent):\n    \"\"\"Fast exponentiation. O(log n) instead of O(n).\"\"\"\n    if exponent == 0:\n        return 1\n    if exponent % 2 == 0:\n        half = power(base, exponent // 2)\n        return half * half\n    else:\n        return base * power(base, exponent - 1)\n\nprint(power(2, 10))  # 1024\n</code></pre> <p>This is divide and conquer in action! Instead of multiplying <code>base</code> by itself ( n ) times (( O(n) )), we halve the exponent at each step, giving us ( O(\\log n) ). For ( 2^{1000} ), that's about 10 multiplications instead of 1,000.</p> Recursion Tree for power(2, 8)"},{"location":"chapters/19-algorithm-analysis/#diagram_4","title":"Diagram:","text":"<pre><code>power(2, 8)\n  \u2514\u2500\u2500 half = power(2, 4)\n        \u2514\u2500\u2500 half = power(2, 2)\n              \u2514\u2500\u2500 half = power(2, 1)\n                    \u2514\u2500\u2500 2 * power(2, 0) = 2 * 1 = 2\n                  return 2\n              return 2 * 2 = 4\n        return 4 * 4 = 16\n  return 16 * 16 = 256\n</code></pre> <p>Only 4 recursive calls instead of 8 multiplications. For <code>power(2, 1024)</code>, we'd need only about 10 calls!</p>"},{"location":"chapters/19-algorithm-analysis/#algorithm-visualization","title":"Algorithm Visualization","text":"<p>Algorithm Visualization means creating visual representations of how algorithms work step by step. Visualizations help you understand what an algorithm does at each point in its execution. They're one of the best tools for building intuition about why certain algorithms are fast or slow.</p> <p>You can visualize algorithms in many ways:</p> <ul> <li>Trace tables \u2014 manually track variables at each step (like the operation counting table earlier)</li> <li>Bar charts \u2014 show array elements as bars that swap during sorting</li> <li>Tree diagrams \u2014 show recursive call structures</li> <li>Animated simulations \u2014 interactive programs that let you step through an algorithm</li> </ul> Algorithm Visualization: Sorting Comparison MicroSim"},{"location":"chapters/19-algorithm-analysis/#diagram_5","title":"Diagram:","text":"<p>Imagine a MicroSim where you can watch three sorting algorithms race side by side. Each algorithm gets the same shuffled array. You can see:</p> <ul> <li>Selection sort slowly scanning for the minimum, making ( O(n^2) ) comparisons</li> <li>Insertion sort building the sorted portion from left to right</li> <li>Merge sort splitting, sorting, and merging \u2014 finishing much faster</li> </ul> <p>Visualizations like this make the difference between ( O(n^2) ) and ( O(n \\log n) ) viscerally obvious. You can see merge sort pulling ahead as the array gets larger.</p> <p>When you design your own algorithms, try drawing diagrams or building trace tables. If you can't trace your algorithm by hand, you don't fully understand it yet.</p>"},{"location":"chapters/19-algorithm-analysis/#memoization-remember-and-reuse","title":"Memoization: Remember and Reuse","text":"<p>Now for one of the most satisfying optimization techniques in all of programming. Memoization is a technique where you store the results of expensive function calls and return the cached result when the same inputs occur again.</p> <p>The classic example is the Fibonacci sequence. Here's the naive recursive version:</p> <pre><code>def fib(n):\n    \"\"\"Naive recursive Fibonacci. O(2^n) \u2014 very slow!\"\"\"\n    if n &lt;= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n</code></pre> <p>This looks elegant, but it's horrifically slow. To compute <code>fib(5)</code>, it computes <code>fib(4)</code> and <code>fib(3)</code>. But to compute <code>fib(4)</code>, it also computes <code>fib(3)</code> \u2014 the same work, done twice! The number of function calls grows exponentially: ( O(2^n) ). Try <code>fib(40)</code> and you'll be waiting a very long time.</p> <p>Now watch what happens with memoization:</p> <pre><code>def fib_memo(n, memo={}):\n    \"\"\"Memoized Fibonacci. O(n) \u2014 dramatically faster!\"\"\"\n    if n in memo:\n        return memo[n]\n    if n &lt;= 1:\n        return n\n    memo[n] = fib_memo(n - 1, memo) + fib_memo(n - 2, memo)\n    return memo[n]\n</code></pre> <p>With memoization, each Fibonacci number is computed exactly once and then stored in the dictionary. Instead of ( O(2^n) ), we get ( O(n) ). That's the difference between \"my computer can't do this\" and \"done in a millisecond.\"</p> <p>Let's prove it with empirical analysis:</p> <pre><code>import time\n\n# Naive version (don't try values much above 35!)\nstart = time.time()\nresult = fib(35)\nnaive_time = time.time() - start\n\n# Memoized version\nstart = time.time()\nresult = fib_memo(35)\nmemo_time = time.time() - start\n\nprint(f\"fib(35) = {result}\")\nprint(f\"Naive:    {naive_time:.4f} seconds\")\nprint(f\"Memoized: {memo_time:.8f} seconds\")\nprint(f\"Speedup:  {naive_time / memo_time:,.0f}x faster\")\n</code></pre> <p>Typical output:</p> <pre><code>fib(35) = 9227465\nNaive:    3.2145 seconds\nMemoized: 0.00001200 seconds\nSpeedup:  267,875x faster\n</code></pre> <p>Monty says: You've got this!</p> <p> Over 200,000 times faster from adding a dictionary cache! Memoization is one of those techniques that feels like cheating \u2014 but it's completely legit. Any time you see a recursive function recomputing the same values over and over, memoization is your best friend.</p> <p>Python also provides a built-in decorator for memoization:</p> <pre><code>from functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef fib_cached(n):\n    if n &lt;= 1:\n        return n\n    return fib_cached(n - 1) + fib_cached(n - 2)\n\nprint(fib_cached(100))\n# Output: 354224848179261915075 \u2014 computed instantly!\n</code></pre> <p>The <code>@lru_cache</code> decorator handles all the caching for you. The name stands for \"Least Recently Used cache.\" With <code>maxsize=None</code>, it caches every result without evicting any.</p>"},{"location":"chapters/19-algorithm-analysis/#putting-it-all-together","title":"Putting It All Together","text":"<p>Let's see how these concepts connect by solving a problem using multiple approaches.</p> <p>Problem: Given a list of integers, find the length of the longest subarray where all elements sum to at most a target value.</p> <pre><code># Brute force: O(n^3) \u2014 check every subarray, sum each one\ndef longest_subarray_brute(nums, target):\n    max_length = 0\n    for i in range(len(nums)):\n        for j in range(i, len(nums)):\n            if sum(nums[i:j+1]) &lt;= target:\n                max_length = max(max_length, j - i + 1)\n    return max_length\n\n# Sliding window: O(n) \u2014 elegant and fast\ndef longest_subarray_window(nums, target):\n    max_length = 0\n    window_sum = 0\n    left = 0\n\n    for right in range(len(nums)):\n        window_sum += nums[right]\n\n        while window_sum &gt; target:\n            window_sum -= nums[left]\n            left += 1\n\n        max_length = max(max_length, right - left + 1)\n\n    return max_length\n\n# Test both\ndata = [1, 2, 3, 1, 1, 1, 2, 3]\ntarget = 6\nprint(longest_subarray_brute(data, target))   # 5\nprint(longest_subarray_window(data, target))   # 5\n</code></pre> <p>The brute force version is ( O(n^3) ) \u2014 three layers of work (two loops plus the <code>sum()</code> call). The sliding window version is ( O(n) ) \u2014 a 1,000,000,000x improvement at ( n = 1{,}000 ). Same answer, wildly different performance.</p> <p>Monty says: You've got this!</p> <p> If this chapter felt intense, take a breath. You just learned tools that many college students struggle with. The key is practice: pick a problem, try brute force first, then see if you can apply a pattern (two pointer, sliding window, frequency counter) or a strategy (divide and conquer, greedy, memoization) to make it faster. Every expert started exactly where you are now.</p>"},{"location":"chapters/19-algorithm-analysis/#key-takeaways","title":"Key Takeaways","text":"<ol> <li> <p>Logarithmic time ( O(\\log n) ) cuts the problem in half at each step \u2014 this is why binary search is so fast.</p> </li> <li> <p>Linearithmic time ( O(n \\log n) ) is the best possible for general comparison-based sorting algorithms like merge sort.</p> </li> <li> <p>Always consider best, average, and worst case \u2014 an algorithm's performance can vary dramatically depending on the input.</p> </li> <li> <p>Empirical analysis with Python's <code>time</code> module lets you measure real performance and verify your Big-O predictions.</p> </li> <li> <p>Counting operations is the foundation of complexity analysis \u2014 trace through your code and count how work scales with input size.</p> </li> <li> <p>Brute force is a valid first approach: get it working correctly, then optimize.</p> </li> <li> <p>Divide and conquer splits problems into smaller independent subproblems \u2014 it's the strategy behind merge sort and fast exponentiation.</p> </li> <li> <p>Greedy algorithms make locally optimal choices, but they don't always produce globally optimal results.</p> </li> <li> <p>Algorithm tradeoffs (time vs. space) and efficiency vs. readability are real-world engineering decisions \u2014 context matters.</p> </li> <li> <p>The two pointer, sliding window, and frequency counter patterns transform ( O(n^2) ) brute force solutions into ( O(n) ) solutions.</p> </li> <li> <p>Recursion is a powerful tool when combined with strategies like divide and conquer.</p> </li> <li> <p>Memoization caches the results of function calls, turning exponential algorithms into linear ones (like Fibonacci going from ( O(2^n) ) to ( O(n) )).</p> </li> <li> <p>Algorithm visualization through trace tables, diagrams, and simulations builds deep understanding of how algorithms behave.</p> </li> </ol> Brute Force vs. Two Pointer: What's the Tradeoff? <p>You have a sorted list of 10,000 integers and need to find a pair that sums to a target value. Compare the brute force approach (( O(n^2) )) with the two pointer approach (( O(n) )).</p> <p>(a) How many pair comparisons does the brute force approach make at most?</p> <p>(b) How many steps does the two pointer approach take at most?</p> <p>(c) If each comparison takes 1 microsecond, how long does each approach take?</p> <p>Answer:</p> <p>(a) Brute force checks ( \\frac{n(n-1)}{2} = \\frac{10{,}000 \\times 9{,}999}{2} = 49{,}995{,}000 ) pairs.</p> <p>(b) Two pointer takes at most ( n = 10{,}000 ) steps.</p> <p>(c) Brute force: ( 49{,}995{,}000 \\times 1\\mu s \\approx 50 ) seconds. Two pointer: ( 10{,}000 \\times 1\\mu s = 0.01 ) seconds. The two pointer approach is about 5,000 times faster \u2014 and both give the same correct answer.</p> Memoization Magic: Why Does It Help? <p>Consider the naive recursive Fibonacci function.</p> <p>(a) Draw (or describe) the recursive call tree for <code>fib(6)</code>. How many total function calls are made?</p> <p>(b) With memoization, how many unique computations are needed for <code>fib(6)</code>?</p> <p>(c) Explain in your own words why memoization changes the complexity from ( O(2^n) ) to ( O(n) ).</p> <p>Answer:</p> <p>(a) The call tree for <code>fib(6)</code> makes 25 total calls. <code>fib(3)</code> alone is computed 4 separate times! The tree branches exponentially because each call spawns two more.</p> <p>(b) With memoization, we compute <code>fib(0)</code>, <code>fib(1)</code>, <code>fib(2)</code>, <code>fib(3)</code>, <code>fib(4)</code>, <code>fib(5)</code>, and <code>fib(6)</code> \u2014 exactly 7 unique computations (that's ( n + 1 )).</p> <p>(c) Without memoization, the function recomputes the same subproblems over and over, leading to an exponential explosion of duplicate work. Memoization stores each result the first time it's computed, so every subsequent call with the same argument returns instantly from the cache. Since there are only ( n + 1 ) unique inputs, the total work is ( O(n) ).</p> Greedy vs. Optimal: When Does Greedy Fail? <p>Suppose you have coin denominations of [25, 15, 1] and need to make change for 30 cents.</p> <p>(a) What solution does the greedy algorithm produce? How many coins?</p> <p>(b) What is the optimal (fewest coins) solution?</p> <p>(c) Why does the greedy approach work for standard US coins [25, 10, 5, 1] but fail for [25, 15, 1]?</p> <p>Answer:</p> <p>(a) Greedy picks the largest coin first: 25, then five 1s = [25, 1, 1, 1, 1, 1]. That's 6 coins.</p> <p>(b) The optimal solution is [15, 15] \u2014 just 2 coins.</p> <p>(c) The greedy algorithm works for US coins because of a special mathematical property: each coin denomination is at least twice the next smaller one, so you never need to \"un-pick\" a large coin. With [25, 15, 1], picking 25 first blocks you from using two 15s. The greedy approach fails when a locally optimal choice prevents the globally optimal solution. For arbitrary coin sets, you need dynamic programming (a topic for a future course!) to guarantee the best answer.</p>"},{"location":"chapters/20-advanced-python/","title":"Advanced Python Features","text":""},{"location":"chapters/20-advanced-python/#advanced-python-features","title":"Advanced Python Features","text":""},{"location":"chapters/20-advanced-python/#summary","title":"Summary","text":"<p>This chapter introduces advanced Python language features for experienced students ready to deepen their skills. Students will learn about generators and the yield statement, decorators and closures, variable-length arguments (args/*kwargs), type hints and annotations, dataclasses, enums, and regular expressions. The chapter also covers key standard library modules including collections (Counter, OrderedDict, DefaultDict, namedtuple), itertools, and functools, along with best practices for writing professional Python code.</p>"},{"location":"chapters/20-advanced-python/#concepts-covered","title":"Concepts Covered","text":"<p>This chapter covers the following 24 concepts from the learning graph:</p> <ol> <li>Generators</li> <li>Yield Statement</li> <li>Generator Expressions</li> <li>Decorators</li> <li>Closures</li> <li>Args and Kwargs</li> <li>Unpacking Operators</li> <li>Walrus Operator</li> <li>Type Hints</li> <li>Type Annotations</li> <li>Dataclasses</li> <li>Enum Type</li> <li>Regular Expressions</li> <li>Collections Module</li> <li>Itertools Module</li> <li>Functools Module</li> <li>List vs Generator Memory</li> <li>Comprehension Patterns</li> <li>Context Manager Protocol</li> <li>Python Best Practices</li> <li>Named Tuples</li> <li>OrderedDict</li> <li>DefaultDict</li> <li>Counter Class</li> </ol>"},{"location":"chapters/20-advanced-python/#prerequisites","title":"Prerequisites","text":"<p>This chapter builds on concepts from:</p> <ul> <li>Chapter 2: Python Fundamentals</li> <li>Chapter 4: Control Flow</li> <li>Chapter 6: Functions and Modular Design</li> <li>Chapter 7: Higher-Order Functions and Recursion</li> <li>Chapter 8: Lists</li> <li>Chapter 10: Tuples and Sets</li> <li>Chapter 11: Dictionaries</li> <li>Chapter 12: Classes and Objects</li> <li>Chapter 13: Inheritance and Polymorphism</li> <li>Chapter 16: Software Engineering Practices</li> </ul> <p>Monty says: Let's code this!</p> <p> Welcome to the final chapter, coders! You've built an incredible foundation over the last 19 chapters. Now it's time to level up and explore the advanced features that make Python one of the most beloved languages on the planet. Think of this chapter as unlocking the secret menu -- the powerful tools that experienced Python developers reach for every day. Let's do this!</p>"},{"location":"chapters/20-advanced-python/#generators-the-lazy-geniuses","title":"Generators: The Lazy Geniuses","text":"<p>Imagine you work in a warehouse full of one million packages. If someone asks for all of them, you could load every single package onto a truck at once. But that truck would be enormous, and it would take forever to load. Wouldn't it be smarter to put packages on a conveyor belt and deliver them one at a time? That's exactly the difference between a list and a generator.</p> <p>A generator is a special kind of function that produces values one at a time instead of building an entire list in memory. It's like a conveyor belt that manufactures items on demand rather than a warehouse that stores everything upfront. This \"lazy\" approach is incredibly memory-efficient.</p>"},{"location":"chapters/20-advanced-python/#the-yield-statement","title":"The Yield Statement","text":"<p>Normal functions use <code>return</code> to send back a value and then they're done -- the function is finished. A generator function uses the yield statement instead. When a generator hits <code>yield</code>, it pauses execution, hands you the value, and waits. The next time you ask for a value, it picks up right where it left off.</p> <pre><code>def countdown(n):\n    \"\"\"A generator that counts down from n to 1.\"\"\"\n    while n &gt; 0:\n        yield n\n        n -= 1\n\n# Using the generator\nfor number in countdown(5):\n    print(number)\n# Output: 5, 4, 3, 2, 1\n</code></pre> <p>Notice that <code>countdown</code> uses <code>yield</code> instead of <code>return</code>. Each time the <code>for</code> loop asks for the next value, the generator wakes up, runs until it hits <code>yield</code> again, and hands over the next number. It's like a storyteller who pauses after each chapter and waits for you to say \"keep going.\"</p>"},{"location":"chapters/20-advanced-python/#generator-expressions","title":"Generator Expressions","text":"<p>Just like list comprehensions give you a shortcut for building lists, generator expressions give you a shortcut for building generators. The syntax looks almost identical -- just swap the square brackets <code>[]</code> for parentheses <code>()</code>.</p> <pre><code># List comprehension -- builds the entire list in memory\nsquares_list = [x ** 2 for x in range(1_000_000)]\n\n# Generator expression -- produces values one at a time\nsquares_gen = (x ** 2 for x in range(1_000_000))\n</code></pre> <p>The list version creates a million numbers right away and stores them all. The generator version creates them one at a time as you iterate over it. For large datasets, the difference in memory usage is massive.</p>"},{"location":"chapters/20-advanced-python/#list-vs-generator-memory","title":"List vs Generator Memory","text":"<p>Let's make the list vs generator memory trade-off crystal clear.</p> Feature List Generator Memory usage Stores ALL items at once Stores ONE item at a time Speed to start Slow (must build entire list) Instant (produces on demand) Reusable? Yes, iterate as many times as you want No, once exhausted it's done Random access? Yes (<code>my_list[42]</code>) No (must iterate sequentially) Best for Small data, repeated access Large data, single pass <p>Think of it this way: a list is like a printed book you can flip to any page, while a generator is like a live podcast -- you listen in order, and once it's played, it's gone.</p>"},{"location":"chapters/20-advanced-python/#diagram-generator-vs-list-memory","title":"Diagram: Generator vs List Memory","text":"Generator vs List Memory MicroSim <p>Type: microsim sim-id: generator-vs-list-memory Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: compare, explain</p> <p>Learning Objective: Students will be able to compare memory usage between lists and generators by observing a visual representation of how each stores data.</p> <p>Purpose: An animated side-by-side comparison that shows a list filling up a memory block all at once versus a generator producing and releasing one item at a time.</p> <p>Layout: - Left panel: \"List\" label with a large memory block that fills with colored squares as items are created - Right panel: \"Generator\" label with a single-slot conveyor belt that produces, delivers, and discards one item at a time - Bottom: Memory usage bar chart showing the stark difference</p> <p>Interactive controls: - \"Generate Items\" button that produces 20 items and shows both approaches simultaneously - Speed slider to control animation pace - \"Reset\" button to clear and start over - Counter showing current memory usage for each approach</p> <p>Visual style: Clean blocks, green for active items, gray for empty slots, red warning glow when list memory gets large Responsive: Canvas adjusts to window width</p> <p>Instructional Rationale: Visual comparison of memory allocation makes the abstract concept of lazy evaluation concrete. Students see the list panel filling up while the generator panel stays lean, reinforcing why generators are preferred for large datasets.</p>"},{"location":"chapters/20-advanced-python/#comprehension-patterns","title":"Comprehension Patterns","text":"<p>You've used list comprehensions before. Now let's look at all the comprehension patterns Python offers. They're one of Python's most elegant features -- compact, readable ways to transform data.</p> <pre><code># List comprehension\nevens = [x for x in range(20) if x % 2 == 0]\n\n# Dictionary comprehension\nword_lengths = {word: len(word) for word in [\"python\", \"is\", \"fun\"]}\n\n# Set comprehension\nunique_remainders = {x % 3 for x in range(10)}\n\n# Generator expression (not stored, iterated lazily)\ntotal = sum(x ** 2 for x in range(100))\n</code></pre> <p>The pattern is always the same: <code>expression for variable in iterable if condition</code>. Once you master this pattern, you can express in one line what used to take four or five.</p> <p>Monty says: You've got this!</p> <p> Here's a good rule of thumb: if a comprehension fits on one line and is easy to read, use it. If it needs two or three lines or makes your eyes cross, stick with a regular <code>for</code> loop. Readability always wins!</p>"},{"location":"chapters/20-advanced-python/#decorators-gift-wrapping-your-functions","title":"Decorators: Gift-Wrapping Your Functions","text":"<p>Imagine you have a birthday present (your function). A decorator is like wrapping that present in fancy gift wrap. The present inside is the same, but now it has something extra on the outside -- maybe a bow, a tag, or sparkly paper. In Python, a decorator wraps a function with extra behavior without changing the function itself.</p>"},{"location":"chapters/20-advanced-python/#closures","title":"Closures","text":"<p>Before we dive into decorators, we need to understand closures. A closure is a function that \"remembers\" values from the outer function that created it, even after that outer function has finished running. It's like a note tucked inside an envelope -- the envelope (outer function) may be sealed and mailed, but the note (inner function) still carries the message.</p> <pre><code>def make_multiplier(factor):\n    \"\"\"Returns a function that multiplies by the given factor.\"\"\"\n    def multiplier(x):\n        return x * factor  # 'factor' is remembered from the outer scope\n    return multiplier\n\ndouble = make_multiplier(2)\ntriple = make_multiplier(3)\n\nprint(double(5))   # 10\nprint(triple(5))   # 15\n</code></pre> <p>The inner <code>multiplier</code> function \"closes over\" the <code>factor</code> variable. Even though <code>make_multiplier</code> has finished, <code>double</code> remembers that <code>factor</code> is 2.</p>"},{"location":"chapters/20-advanced-python/#writing-decorators","title":"Writing Decorators","text":"<p>Now for the main event. A decorator is a function that takes another function as input, wraps it with extra behavior, and returns the wrapped version.</p> <pre><code>def log_calls(func):\n    \"\"\"A decorator that prints when a function is called.\"\"\"\n    def wrapper(*args, **kwargs):\n        print(f\"Calling {func.__name__}...\")\n        result = func(*args, **kwargs)\n        print(f\"{func.__name__} finished!\")\n        return result\n    return wrapper\n\n@log_calls\ndef greet(name):\n    print(f\"Hello, {name}!\")\n\ngreet(\"Monty\")\n# Output:\n# Calling greet...\n# Hello, Monty!\n# greet finished!\n</code></pre> <p>The <code>@log_calls</code> line is syntactic sugar. It's the same as writing <code>greet = log_calls(greet)</code>. The decorator wraps <code>greet</code> with logging behavior without touching the original function's code.</p>"},{"location":"chapters/20-advanced-python/#diagram-how-decorators-work","title":"Diagram: How Decorators Work","text":"How Decorators Work MicroSim <p>Type: microsim sim-id: decorator-flow Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: explain, trace</p> <p>Learning Objective: Students will be able to trace how a decorator wraps a function by watching an animated flow diagram of the decoration process.</p> <p>Purpose: Visual step-through showing how a decorator function receives an original function, creates a wrapper, and returns the wrapper as the new version.</p> <p>Layout: - Three boxes arranged left to right: \"Original Function\", \"Decorator\", \"Wrapped Function\" - Arrows showing the flow: original enters decorator, wrapper comes out - Below: a \"Call the function\" button that animates execution flowing through the wrapper, into the original, and back out</p> <p>Interactive controls: - \"Step Through\" button to advance the decoration process one stage at a time - \"Call Function\" button to animate a function call flowing through the wrapper - \"Reset\" button</p> <p>Visual elements: - Gift wrapping animation: the original function box gets visually \"wrapped\" with a colored border (the decorator layer) - Code snippets appear beside each box showing the relevant Python code - Execution trace highlights each line as it runs</p> <p>Instructional Rationale: The gift-wrapping metaphor becomes concrete when students watch the original function get visually wrapped. Step-through execution demystifies what <code>@decorator</code> actually does under the hood.</p>"},{"location":"chapters/20-advanced-python/#args-kwargs-and-unpacking","title":"Args, Kwargs, and Unpacking","text":"<p>Sometimes you don't know in advance how many arguments a function will receive. That's where args and kwargs come in.</p>"},{"location":"chapters/20-advanced-python/#args-variable-positional-arguments","title":"*args: Variable Positional Arguments","text":"<p>The <code>*args</code> syntax lets a function accept any number of positional arguments. They arrive as a tuple.</p> <pre><code>def add_all(*args):\n    \"\"\"Add up any number of values.\"\"\"\n    return sum(args)\n\nprint(add_all(1, 2, 3))        # 6\nprint(add_all(10, 20, 30, 40)) # 100\n</code></pre>"},{"location":"chapters/20-advanced-python/#kwargs-variable-keyword-arguments","title":"**kwargs: Variable Keyword Arguments","text":"<p>The <code>**kwargs</code> syntax lets a function accept any number of keyword arguments. They arrive as a dictionary.</p> <pre><code>def build_profile(**kwargs):\n    \"\"\"Build a user profile from keyword arguments.\"\"\"\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\nbuild_profile(name=\"Ada\", age=17, language=\"Python\")\n# Output:\n# name: Ada\n# age: 17\n# language: Python\n</code></pre>"},{"location":"chapters/20-advanced-python/#unpacking-operators","title":"Unpacking Operators","text":"<p>The unpacking operators <code>*</code> and <code>**</code> aren't just for function definitions -- you can also use them to unpack collections when calling functions or building new collections.</p> <pre><code># Unpack a list into function arguments\nnumbers = [1, 2, 3]\nprint(*numbers)  # Same as print(1, 2, 3)\n\n# Merge two dictionaries\ndefaults = {\"color\": \"blue\", \"size\": \"medium\"}\noverrides = {\"size\": \"large\", \"weight\": \"heavy\"}\ncombined = {**defaults, **overrides}\n# {'color': 'blue', 'size': 'large', 'weight': 'heavy'}\n\n# Unpack into variables\nfirst, *rest = [1, 2, 3, 4, 5]\n# first = 1, rest = [2, 3, 4, 5]\n</code></pre> <p>That last trick -- <code>first, *rest = ...</code> -- is called starred assignment, and it's surprisingly handy.</p>"},{"location":"chapters/20-advanced-python/#the-walrus-operator","title":"The Walrus Operator","text":"<p>The walrus operator (<code>:=</code>) is one of Python's newest features (added in Python 3.8). It lets you assign a value to a variable as part of an expression. It's called the walrus operator because <code>:=</code> looks like a walrus face turned sideways (the colon is the eyes, the equals sign is the tusks).</p> <pre><code># Without walrus operator\nline = input(\"Enter something: \")\nwhile line != \"quit\":\n    print(f\"You said: {line}\")\n    line = input(\"Enter something: \")\n\n# With walrus operator -- cleaner!\nwhile (line := input(\"Enter something: \")) != \"quit\":\n    print(f\"You said: {line}\")\n</code></pre> <p>Here's another great use -- filtering with a computation you don't want to repeat:</p> <pre><code>results = []\nfor text in [\"hello\", \"hi\", \"hey there\", \"greetings fellow human\"]:\n    if (n := len(text)) &gt; 3:\n        results.append((text, n))\n# [('hello', 5), ('hey there', 9), ('greetings fellow human', 22)]\n</code></pre> <p>Without the walrus, you'd have to call <code>len(text)</code> twice or use a separate variable line. The walrus keeps things tight.</p>"},{"location":"chapters/20-advanced-python/#type-hints-and-annotations","title":"Type Hints and Annotations","text":"<p>As your programs grow, it gets harder to remember what types of values each function expects. Type hints are optional labels you add to your code to document what types your variables and function parameters should be.</p> <pre><code>def calculate_gpa(grades: list[float], credits: list[int]) -&gt; float:\n    \"\"\"Calculate weighted GPA.\"\"\"\n    total_points = sum(g * c for g, c in zip(grades, credits))\n    total_credits = sum(credits)\n    return total_points / total_credits\n</code></pre> <p>The <code>: list[float]</code> and <code>-&gt; float</code> parts are type hints. They tell anyone reading the code: \"this function takes a list of floats and a list of ints, and returns a float.\"</p> <p>Type annotations are the broader term for adding type information anywhere in your code -- not just function signatures.</p> <pre><code># Variable annotations\nname: str = \"Monty\"\nage: int = 16\ngpa: float = 3.85\nis_enrolled: bool = True\ncourses: list[str] = [\"CS\", \"Math\", \"English\"]\n</code></pre> <p>Type hints don't change how your code runs. Python won't throw an error if you pass the wrong type. But they make your code self-documenting, and tools like <code>mypy</code> can check them for you before your code runs.</p> <p>Monty says: Let's debug this together!</p> <p> Type hints are like road signs -- they don't force you to drive a certain way, but they sure help you avoid wrong turns! Start adding them to your function signatures, and you'll catch bugs before they happen.</p>"},{"location":"chapters/20-advanced-python/#dataclasses-classes-without-the-boilerplate","title":"Dataclasses: Classes Without the Boilerplate","text":"<p>Remember writing classes in Chapter 12? You had to write <code>__init__</code>, maybe <code>__repr__</code>, maybe <code>__eq__</code> -- a lot of repetitive code just to hold some data. Dataclasses do all that for you automatically.</p> <pre><code>from dataclasses import dataclass\n\n@dataclass\nclass Student:\n    name: str\n    grade: int\n    gpa: float\n    honor_roll: bool = False  # default value\n\n# That's it! Python auto-generates __init__, __repr__, and __eq__\nada = Student(\"Ada\", 10, 3.9, True)\nprint(ada)  # Student(name='Ada', grade=10, gpa=3.9, honor_roll=True)\n\n# Equality works automatically\nada2 = Student(\"Ada\", 10, 3.9, True)\nprint(ada == ada2)  # True\n</code></pre> <p>Without <code>@dataclass</code>, you'd need to write about 15 lines of boilerplate code. With it, you need four. Dataclasses are perfect for any class whose main job is to hold data.</p>"},{"location":"chapters/20-advanced-python/#the-enum-type","title":"The Enum Type","text":"<p>Sometimes you have a fixed set of choices -- like compass directions, days of the week, or game difficulty levels. The enum type lets you define these as a named set of constants.</p> <pre><code>from enum import Enum\n\nclass Difficulty(Enum):\n    EASY = 1\n    MEDIUM = 2\n    HARD = 3\n    NIGHTMARE = 4\n\n# Using the enum\ncurrent = Difficulty.HARD\nprint(current)        # Difficulty.HARD\nprint(current.name)   # HARD\nprint(current.value)  # 3\n\n# Enums work great in if/match statements\nif current == Difficulty.NIGHTMARE:\n    print(\"Good luck!\")\n</code></pre> <p>Why not just use strings like <code>\"hard\"</code> or numbers like <code>3</code>? Because typos happen. If you write <code>\"hrad\"</code> by mistake, Python won't complain -- it's a valid string. But <code>Difficulty.HRAD</code> will throw an error immediately. Enums catch mistakes early.</p>"},{"location":"chapters/20-advanced-python/#regular-expressions-pattern-matching-for-text","title":"Regular Expressions: Pattern Matching for Text","text":"<p>Regular expressions (often called \"regex\") are a powerful mini-language for searching, matching, and manipulating text patterns. They're like wildcards on steroids. Python's <code>re</code> module gives you full regex support.</p> <pre><code>import re\n\n# Find all email addresses in a text\ntext = \"Contact ada@example.com or monty@python.org for info\"\nemails = re.findall(r'[\\w.]+@[\\w.]+\\.\\w+', text)\nprint(emails)  # ['ada@example.com', 'monty@python.org']\n\n# Check if a string matches a pattern\nphone = \"555-123-4567\"\nif re.match(r'\\d{3}-\\d{3}-\\d{4}', phone):\n    print(\"Valid phone number!\")\n</code></pre> <p>Here's a cheat sheet of the most common regex patterns:</p> Pattern Matches Example <code>\\d</code> Any digit (0-9) <code>\\d{3}</code> matches \"123\" <code>\\w</code> Any word character (letter, digit, underscore) <code>\\w+</code> matches \"hello_42\" <code>\\s</code> Any whitespace (space, tab, newline) <code>\\s+</code> matches \"   \" <code>.</code> Any character except newline <code>a.c</code> matches \"abc\", \"a1c\" <code>*</code> Zero or more of the previous <code>ab*c</code> matches \"ac\", \"abc\", \"abbc\" <code>+</code> One or more of the previous <code>ab+c</code> matches \"abc\" but not \"ac\" <code>?</code> Zero or one of the previous <code>colou?r</code> matches \"color\" and \"colour\" <code>^</code> Start of string <code>^Hello</code> matches \"Hello world\" <code>$</code> End of string <code>world$</code> matches \"Hello world\" <code>[abc]</code> Any character in the set <code>[aeiou]</code> matches any vowel <code>(...)</code> Capture group <code>(\\d{3})-(\\d{4})</code> captures area code and number <code>{n}</code> Exactly n of the previous <code>\\d{4}</code> matches \"2026\" <code>{n,m}</code> Between n and m of the previous <code>\\w{3,5}</code> matches 3- to 5-character words <p>Common <code>re</code> module functions:</p> Function Purpose Example <code>re.match()</code> Match at the start of a string <code>re.match(r'\\d+', '42abc')</code> <code>re.search()</code> Find the first match anywhere <code>re.search(r'\\d+', 'abc42def')</code> <code>re.findall()</code> Find all matches <code>re.findall(r'\\d+', 'a1b2c3')</code> returns <code>['1','2','3']</code> <code>re.sub()</code> Search and replace <code>re.sub(r'\\d', '#', 'abc123')</code> returns <code>'abc###'</code> <code>re.split()</code> Split on a pattern <code>re.split(r'[,;]', 'a,b;c')</code> returns <code>['a','b','c']</code>"},{"location":"chapters/20-advanced-python/#diagram-regex-pattern-tester","title":"Diagram: Regex Pattern Tester","text":"Regex Pattern Tester MicroSim <p>Type: microsim sim-id: regex-pattern-tester Library: p5.js Status: Specified</p> <p>Bloom Level: Apply (L3) Bloom Verb: apply, test</p> <p>Learning Objective: Students will be able to write and test simple regular expressions by entering patterns and seeing matches highlighted in real time.</p> <p>Purpose: An interactive regex testing tool where students type a pattern and test text, with matches highlighted immediately.</p> <p>Layout: - Top: Input field for the regex pattern with common pattern buttons (\\d, \\w, \\s, ., +, *, etc.) - Middle: Large text area where students type or paste test text - Bottom: Results panel showing all matches highlighted in the test text, plus a list of captured groups</p> <p>Interactive controls: - Pattern input field with real-time matching - Preset pattern buttons that insert common patterns - \"Try Example\" buttons with pre-loaded patterns and texts (email finder, phone number validator, etc.) - Match counter showing number of matches found</p> <p>Visual style: Matches highlighted in yellow within the text area; invalid patterns shown with red border and error message Responsive: Full-width layout adjusting to window size</p> <p>Instructional Rationale: Immediate visual feedback on pattern matching lets students experiment freely and build intuition for regex syntax. Pre-loaded examples scaffold learning by showing practical use cases before students construct their own patterns.</p>"},{"location":"chapters/20-advanced-python/#the-collections-module","title":"The Collections Module","text":"<p>Python's built-in <code>dict</code>, <code>list</code>, and <code>tuple</code> types are great, but sometimes you need specialized data structures. The collections module offers souped-up versions for common patterns.</p>"},{"location":"chapters/20-advanced-python/#counter-class","title":"Counter Class","text":"<p>The Counter class counts how many times each item appears in a collection. It's perfect for frequency analysis.</p> <pre><code>from collections import Counter\n\n# Count word frequencies\nwords = [\"python\", \"is\", \"fun\", \"python\", \"is\", \"great\", \"python\"]\nword_counts = Counter(words)\nprint(word_counts)\n# Counter({'python': 3, 'is': 2, 'fun': 1, 'great': 1})\n\n# Most common items\nprint(word_counts.most_common(2))\n# [('python', 3), ('is', 2)]\n\n# Count characters in a string\nchar_counts = Counter(\"mississippi\")\nprint(char_counts)\n# Counter({'s': 4, 'i': 4, 'p': 2, 'm': 1})\n</code></pre>"},{"location":"chapters/20-advanced-python/#defaultdict","title":"DefaultDict","text":"<p>A DefaultDict is like a regular dictionary, but it never throws a <code>KeyError</code>. When you access a key that doesn't exist, it automatically creates a default value.</p> <pre><code>from collections import defaultdict\n\n# Group students by grade level\nstudents = [(\"Ada\", 10), (\"Bob\", 11), (\"Cat\", 10), (\"Dan\", 11), (\"Eve\", 10)]\n\nby_grade = defaultdict(list)\nfor name, grade in students:\n    by_grade[grade].append(name)\n\nprint(by_grade)\n# defaultdict(&lt;class 'list'&gt;, {10: ['Ada', 'Cat', 'Eve'], 11: ['Bob', 'Dan']})\n</code></pre> <p>Without <code>defaultdict</code>, you'd need to check if each key exists before appending. With it, the dictionary creates an empty list automatically for new keys.</p>"},{"location":"chapters/20-advanced-python/#ordereddict","title":"OrderedDict","text":"<p>An OrderedDict remembers the order items were inserted. In modern Python (3.7+), regular dictionaries also maintain insertion order, but <code>OrderedDict</code> still has a useful trick: it supports <code>move_to_end()</code> and order-sensitive equality comparison.</p> <pre><code>from collections import OrderedDict\n\nrankings = OrderedDict()\nrankings[\"gold\"] = \"Ada\"\nrankings[\"silver\"] = \"Bob\"\nrankings[\"bronze\"] = \"Cat\"\n\n# Move an item to the end\nrankings.move_to_end(\"gold\")\nprint(list(rankings.keys()))  # ['silver', 'bronze', 'gold']\n\n# Two OrderedDicts with different order are NOT equal\na = OrderedDict([(\"x\", 1), (\"y\", 2)])\nb = OrderedDict([(\"y\", 2), (\"x\", 1)])\nprint(a == b)  # False (regular dicts would say True)\n</code></pre>"},{"location":"chapters/20-advanced-python/#named-tuples","title":"Named Tuples","text":"<p>Named tuples are tuples where each position has a name. They're like lightweight classes for storing structured data.</p> <pre><code>from collections import namedtuple\n\nPoint = namedtuple(\"Point\", [\"x\", \"y\"])\np = Point(3, 7)\n\n# Access by name (much clearer than p[0])\nprint(p.x)  # 3\nprint(p.y)  # 7\n\n# They're still tuples -- immutable and iterable\nprint(p[0])      # 3\nx, y = p         # Unpacking works\nprint(f\"({x}, {y})\")  # (3, 7)\n</code></pre> <p>Named tuples are perfect for returning multiple values from a function when you want the caller to access fields by name rather than by position.</p>"},{"location":"chapters/20-advanced-python/#diagram-collections-module-overview","title":"Diagram: Collections Module Overview","text":"Collections Module Overview MicroSim <p>Type: infographic sim-id: collections-overview Library: p5.js Status: Specified</p> <p>Bloom Level: Remember (L1) Bloom Verb: identify, describe</p> <p>Learning Objective: Students will be able to identify the four main collections module classes (Counter, defaultdict, OrderedDict, namedtuple) and describe when to use each one.</p> <p>Purpose: An interactive card-based overview where students can click on each collections class to see its definition, use case, and a short code example.</p> <p>Layout: - Four large cards arranged in a 2x2 grid: Counter, defaultdict, OrderedDict, namedtuple - Each card shows the class name, a one-line description, and an icon - Clicking a card expands it to show a code example and a \"when to use this\" tip</p> <p>Interactive controls: - Click any card to expand/collapse its detail view - \"Show All\" button to expand all cards - \"Quiz Me\" button that shows a use case description and asks the student to pick the right class</p> <p>Visual style: Colorful cards with rounded corners; Counter is orange, defaultdict is blue, OrderedDict is green, namedtuple is purple Responsive: Cards stack vertically on narrow screens</p> <p>Instructional Rationale: Card-based exploration lets students self-pace through the four classes. The \"Quiz Me\" mode reinforces understanding by requiring students to match use cases to tools, building the judgment needed to select the right collection for a task.</p>"},{"location":"chapters/20-advanced-python/#the-itertools-module","title":"The Itertools Module","text":"<p>The itertools module is a toolbox of fast, memory-efficient functions for working with iterators. It's like a Swiss Army knife for looping patterns.</p> <pre><code>import itertools\n\n# chain: connect multiple iterables end-to-end\ncombined = list(itertools.chain([1, 2], [3, 4], [5, 6]))\n# [1, 2, 3, 4, 5, 6]\n\n# combinations: all possible pairs (order doesn't matter)\nteams = list(itertools.combinations([\"Ada\", \"Bob\", \"Cat\"], 2))\n# [('Ada', 'Bob'), ('Ada', 'Cat'), ('Bob', 'Cat')]\n\n# permutations: all possible arrangements (order matters)\norders = list(itertools.permutations([\"A\", \"B\", \"C\"], 2))\n# [('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('C', 'A'), ('C', 'B')]\n\n# product: Cartesian product (all combos of two lists)\ngrid = list(itertools.product([\"X\", \"O\"], repeat=2))\n# [('X', 'X'), ('X', 'O'), ('O', 'X'), ('O', 'O')]\n\n# islice: slice an iterator without loading it all into memory\nfirst_five = list(itertools.islice(range(1_000_000), 5))\n# [0, 1, 2, 3, 4]\n\n# groupby: group consecutive items by a key\ndata = [(\"A\", 1), (\"A\", 2), (\"B\", 3), (\"B\", 4)]\nfor key, group in itertools.groupby(data, key=lambda x: x[0]):\n    print(key, list(group))\n# A [('A', 1), ('A', 2)]\n# B [('B', 3), ('B', 4)]\n</code></pre> <p>The beauty of <code>itertools</code> is that these functions return iterators, not lists. They produce values lazily, just like generators -- perfect for handling large datasets.</p>"},{"location":"chapters/20-advanced-python/#the-functools-module","title":"The Functools Module","text":"<p>The functools module provides tools for working with functions as first-class objects. Two of the most useful are <code>lru_cache</code> and <code>reduce</code>.</p> <pre><code>from functools import lru_cache, reduce\n\n# lru_cache: automatically cache function results\n@lru_cache(maxsize=128)\ndef fibonacci(n):\n    if n &lt; 2:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)\n\nprint(fibonacci(50))  # Instant! Without caching, this would take forever\n\n# reduce: combine all items into a single value\nnumbers = [1, 2, 3, 4, 5]\nproduct = reduce(lambda a, b: a * b, numbers)\nprint(product)  # 120 (1 * 2 * 3 * 4 * 5)\n</code></pre> <p>The <code>@lru_cache</code> decorator is pure magic for recursive functions. It remembers previous results so the same computation never runs twice. Remember how slow recursive Fibonacci was in Chapter 7? With <code>lru_cache</code>, it's instant.</p> <p>Monty says: You've got this!</p> <p> Don't worry if some of these modules feel overwhelming right now. You don't need to memorize every function. The real skill is knowing these tools exist so you can look them up when you need them. Professional developers check the docs all the time!</p>"},{"location":"chapters/20-advanced-python/#context-manager-protocol","title":"Context Manager Protocol","text":"<p>You've used <code>with open(...)</code> to read files. But have you wondered how it works under the hood? The context manager protocol is the mechanism that makes <code>with</code> statements work. A context manager guarantees that setup and cleanup code runs, even if an error occurs.</p> <pre><code># You've seen this pattern:\nwith open(\"data.txt\", \"r\") as f:\n    content = f.read()\n# File is automatically closed, even if an error happened\n\n# You can write your own context managers:\nclass Timer:\n    def __enter__(self):\n        import time\n        self.start = time.time()\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        import time\n        elapsed = time.time() - self.start\n        print(f\"Elapsed: {elapsed:.4f} seconds\")\n\nwith Timer():\n    total = sum(range(1_000_000))\n# Output: Elapsed: 0.0312 seconds\n</code></pre> <p>The <code>__enter__</code> method runs at the start of the <code>with</code> block, and <code>__exit__</code> runs at the end -- no matter what. There's also a simpler way to create context managers using <code>contextlib</code>:</p> <pre><code>from contextlib import contextmanager\n\n@contextmanager\ndef timer():\n    import time\n    start = time.time()\n    yield  # This is where the 'with' block runs\n    elapsed = time.time() - start\n    print(f\"Elapsed: {elapsed:.4f} seconds\")\n\nwith timer():\n    total = sum(range(1_000_000))\n</code></pre> <p>Notice the <code>yield</code> in the middle? The code before <code>yield</code> is the setup, and the code after <code>yield</code> is the cleanup. The <code>@contextmanager</code> decorator turns a generator function into a context manager.</p>"},{"location":"chapters/20-advanced-python/#diagram-context-manager-flow","title":"Diagram: Context Manager Flow","text":"Context Manager Flow MicroSim <p>Type: microsim sim-id: context-manager-flow Library: p5.js Status: Specified</p> <p>Bloom Level: Understand (L2) Bloom Verb: explain, trace</p> <p>Learning Objective: Students will be able to trace the execution flow of a context manager, identifying when enter and exit are called.</p> <p>Purpose: An animated flowchart showing how a <code>with</code> statement triggers enter, runs the body, and then exit -- including the error path.</p> <p>Layout: - Vertical flowchart with three main boxes: \"Enter (enter)\", \"Body (your code)\", \"Exit (exit)\" - A branching path from \"Body\" showing both the success path and the error path - Both paths converge at \"exit\" to show that cleanup always runs</p> <p>Interactive controls: - \"Normal Flow\" button: animate the success path - \"Error Flow\" button: animate what happens when the body raises an exception - \"Step Through\" button for manual advancement - Reset button</p> <p>Visual elements: - Green glow for successful execution path - Red glow for error path - Both paths arriving at exit to emphasize guaranteed cleanup - Code snippets alongside each step</p> <p>Instructional Rationale: Tracing the execution flow through both success and error paths demonstrates why context managers are valuable -- they guarantee cleanup. The error path visualization is particularly important for understanding the protocol's purpose.</p>"},{"location":"chapters/20-advanced-python/#python-best-practices","title":"Python Best Practices","text":"<p>Now that you've seen all these advanced features, let's talk about Python best practices -- the habits that separate good code from great code.</p> <p>1. Follow PEP 8. PEP 8 is Python's official style guide. Use 4-space indentation, <code>snake_case</code> for variables and functions, <code>PascalCase</code> for classes, and <code>UPPER_SNAKE_CASE</code> for constants.</p> <p>2. Use type hints. They make your code self-documenting and help catch bugs early.</p> <p>3. Prefer generators for large data. If you're processing millions of items, don't load them all into memory. Use generators or generator expressions.</p> <p>4. Use dataclasses for data containers. If a class is just holding data, use <code>@dataclass</code> instead of writing boilerplate.</p> <p>5. Use context managers for resources. Files, database connections, network sockets -- anything that needs cleanup should use <code>with</code>.</p> <p>6. Write docstrings. Every function, class, and module should have a docstring explaining what it does.</p> <pre><code>def calculate_average(scores: list[float]) -&gt; float:\n    \"\"\"Calculate the arithmetic mean of a list of scores.\n\n    Args:\n        scores: A non-empty list of numeric scores.\n\n    Returns:\n        The average score as a float.\n\n    Raises:\n        ValueError: If the scores list is empty.\n    \"\"\"\n    if not scores:\n        raise ValueError(\"Cannot average an empty list\")\n    return sum(scores) / len(scores)\n</code></pre> <p>7. Keep functions small. If a function doesn't fit on your screen, it's probably doing too much. Break it up.</p> <p>8. Use meaningful names. <code>student_count</code> beats <code>sc</code>. <code>calculate_gpa</code> beats <code>calc</code>. Future-you will thank present-you.</p>"},{"location":"chapters/20-advanced-python/#diagram-python-best-practices-checklist","title":"Diagram: Python Best Practices Checklist","text":"Python Best Practices Checklist MicroSim <p>Type: infographic sim-id: python-best-practices Library: p5.js Status: Specified</p> <p>Bloom Level: Evaluate (L5) Bloom Verb: assess, critique</p> <p>Learning Objective: Students will be able to evaluate Python code snippets against best practices and identify areas for improvement.</p> <p>Purpose: An interactive checklist where students review code snippets and check off which best practices each snippet follows or violates.</p> <p>Layout: - Left panel: A code snippet display area showing Python code - Right panel: A checklist of 8 best practices with checkboxes - Bottom: \"Check Answers\" button and score display</p> <p>Interactive controls: - \"Next Snippet\" button to cycle through 5 different code examples - Checkboxes for each best practice (follows/violates) - \"Check Answers\" button to reveal which practices the code follows or breaks - Score tracker across all snippets</p> <p>Code snippets include: 1. A well-written function with type hints, docstring, and good names 2. A function with no type hints, single-letter variables, and no docstring 3. A class that should be a dataclass 4. Code that loads a huge file into a list instead of using a generator 5. Code that manually manages file closing instead of using <code>with</code></p> <p>Instructional Rationale: Evaluating code against a checklist builds the critical assessment skills that distinguish intermediate from advanced programmers. Seeing both good and bad examples helps students internalize the practices rather than just memorizing rules.</p>"},{"location":"chapters/20-advanced-python/#putting-it-all-together","title":"Putting It All Together","text":"<p>Let's see how these advanced features combine in a realistic example. Here's a program that analyzes a text file and reports word frequency statistics, using generators, type hints, dataclasses, Counter, and context managers all in one place:</p> <pre><code>from dataclasses import dataclass\nfrom collections import Counter\nfrom typing import Generator\nimport re\n\n@dataclass\nclass TextStats:\n    \"\"\"Statistics for a text analysis.\"\"\"\n    total_words: int\n    unique_words: int\n    most_common: list[tuple[str, int]]\n    average_word_length: float\n\ndef clean_words(text: str) -&gt; Generator[str, None, None]:\n    \"\"\"Yield cleaned, lowercase words from text.\"\"\"\n    for word in re.findall(r'[a-zA-Z]+', text):\n        yield word.lower()\n\ndef analyze_text(filename: str, top_n: int = 5) -&gt; TextStats:\n    \"\"\"Analyze word frequency in a text file.\"\"\"\n    with open(filename, \"r\") as f:\n        words = list(clean_words(f.read()))\n\n    counts = Counter(words)\n    avg_length = sum(len(w) for w in words) / len(words) if words else 0\n\n    return TextStats(\n        total_words=len(words),\n        unique_words=len(counts),\n        most_common=counts.most_common(top_n),\n        average_word_length=round(avg_length, 2)\n    )\n\nstats = analyze_text(\"my_essay.txt\")\nprint(stats)\n</code></pre> <p>Look at how cleanly these features work together. The <code>@dataclass</code> eliminates boilerplate. The generator <code>clean_words</code> processes text lazily. Type hints document every function. The <code>Counter</code> handles frequency counting in one line. And the <code>with</code> statement ensures the file gets closed.</p> <p>Monty says: You've got this!</p> <p> You did it, coder! You just conquered the most advanced chapter in the entire course. These features -- generators, decorators, type hints, dataclasses, regex, and the standard library modules -- are the tools that professional Python developers use every day. You're not just learning Python anymore. You're writing Pythonic code. That's something to celebrate!</p>"},{"location":"chapters/20-advanced-python/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Generators produce values lazily, one at a time, using the yield statement. Generator expressions use parentheses instead of brackets for a compact syntax.</li> <li>Decorators wrap functions with extra behavior using the <code>@decorator</code> syntax. They rely on closures -- inner functions that remember outer variables.</li> <li>Args and kwargs (<code>*args</code>, <code>**kwargs</code>) let functions accept variable numbers of arguments. The unpacking operators <code>*</code> and <code>**</code> can also unpack collections.</li> <li>The walrus operator (<code>:=</code>) assigns and evaluates in a single expression.</li> <li>Type hints and type annotations document expected types without changing runtime behavior.</li> <li>Dataclasses auto-generate <code>__init__</code>, <code>__repr__</code>, and <code>__eq__</code> for data-holding classes.</li> <li>The enum type defines named constants for fixed sets of choices.</li> <li>Regular expressions provide powerful pattern matching for text processing.</li> <li>The collections module offers Counter, DefaultDict, OrderedDict, and named tuples for specialized data handling.</li> <li>The itertools module provides memory-efficient looping tools; the functools module offers function utilities like caching.</li> <li>List vs generator memory: lists store everything; generators produce on demand.</li> <li>Comprehension patterns work for lists, dicts, sets, and generators.</li> <li>The context manager protocol (<code>__enter__</code>/<code>__exit__</code>) guarantees cleanup in <code>with</code> statements.</li> <li>Python best practices include PEP 8 style, type hints, docstrings, and choosing the right tool for the job.</li> </ul> Check Your Understanding: What's the difference between <code>yield</code> and <code>return</code>? <p>The <code>return</code> statement sends back a value and terminates the function permanently. The <code>yield</code> statement sends back a value and pauses the function, allowing it to resume from where it left off the next time a value is requested. Functions that use <code>yield</code> are called generators, and they produce values lazily rather than all at once.</p> Check Your Understanding: When would you use a <code>defaultdict</code> instead of a regular <code>dict</code>? <p>Use a <code>defaultdict</code> when you want to automatically create a default value for missing keys instead of getting a <code>KeyError</code>. For example, if you're grouping items into lists by category, <code>defaultdict(list)</code> automatically creates an empty list the first time you access a new key, so you can just <code>append</code> without checking if the key exists first.</p> Check Your Understanding: What does the <code>@lru_cache</code> decorator do, and why is it useful for recursive functions? <p>The <code>@lru_cache</code> decorator (from <code>functools</code>) automatically caches the results of function calls. When the function is called with arguments it has seen before, it returns the cached result instead of recomputing it. This is especially powerful for recursive functions like Fibonacci, where the same sub-problems are solved many times. Without caching, <code>fibonacci(50)</code> would take an impractical amount of time. With <code>@lru_cache</code>, each unique call is computed only once, making it nearly instant.</p>"},{"location":"learning-graph/","title":"Introduction","text":""},{"location":"learning-graph/#learning-graph-for-ap-computer-science-python-version","title":"Learning Graph for AP Computer Science (Python Version)","text":"<p>This section contains the learning graph for this textbook.  A learning graph is a graph of concepts used in this textbook.  Each concept is represented by a node in a network graph.  Concepts are connected by directed edges that indicate what concepts each node depends on before that concept is understood by the student.</p> <p>A learning graph is the foundational data structure for intelligent textbooks that can recommend learning paths. A learning graph is like a roadmap of concepts to help students arrive at their learning goals.</p> <p>At the left of the learning graph are prerequisite or foundational concepts.  They have no outbound edges.  They only have inbound edges for other concepts that depend on understanding these foundational prerequisite concepts.  At the far right we have the most advanced concepts in the course.  To master these concepts you must understand all the concepts that they point to.</p> <p>Here are other files used by the learning graph.</p>"},{"location":"learning-graph/#course-description","title":"Course Description","text":"<p>We use the Course Description as the source document for the concepts that are included in this course. The course description uses the 2001 Bloom taxonomy to order learning objectives.</p>"},{"location":"learning-graph/#list-of-concepts","title":"List of Concepts","text":"<p>We use generative AI to convert the course description into a Concept List. Each concept is in the form of a short Title Case label with most labels under 32 characters long.</p>"},{"location":"learning-graph/#concept-dependency-list","title":"Concept Dependency List","text":"<p>We next use generative AI to create a Directed Acyclic Graph (DAG).  DAGs do not have cycles where concepts depend on themselves.  We provide the DAG in two formats.  One is a CSV file and the other format is a JSON file that uses the vis-network JavaScript library format.  The vis-network format uses <code>nodes</code>, <code>edges</code> and <code>metadata</code> elements with edges containing <code>from</code> and <code>to</code> properties.  This makes it easy for you to view and edit the learning graph using an editor built with the vis-network tools.</p>"},{"location":"learning-graph/#analysis-documentation","title":"Analysis &amp; Documentation","text":""},{"location":"learning-graph/#course-description-quality-assessment","title":"Course Description Quality Assessment","text":"<p>This report rates the overall quality of the course description for the purpose of generating a learning graph.</p> <ul> <li>Course description fields and content depth analysis</li> <li>Validates course description has sufficient depth for generating 400 concepts</li> <li>Compares course description against similar courses</li> <li>Identifies content gaps and strengths</li> <li>Suggests areas of improvement</li> </ul> <p>View the Course Description Quality Assessment</p>"},{"location":"learning-graph/#learning-graph-quality-validation","title":"Learning Graph Quality Validation","text":"<p>This report gives you an overall assessment of the quality of the learning graph. It uses graph algorithms to look for specific quality patterns in the graph.</p> <ul> <li>Graph structure validation - all concepts are connected</li> <li>DAG validation (no cycles detected)</li> <li>Foundational concepts: 1 entry point (Computer Science)</li> <li>Indegree distribution analysis</li> <li>Longest dependency chains</li> <li>Connectivity: 100% of nodes connected to the main cluster</li> </ul> <p>View the Learning Graph Quality Validation</p>"},{"location":"learning-graph/#concept-taxonomy","title":"Concept Taxonomy","text":"<p>In order to see patterns in the learning graph, it is useful to assign colors to each concept based on the concept type.  We use generative AI to create 15 categories for our concepts and then place each concept into a single primary classifier.</p> <ul> <li>A concept classifier taxonomy with 15 categories</li> <li>Category organization - foundational elements first, advanced Python last</li> <li>Balanced categories (2% - 20% each)</li> <li>All categories under 30% threshold</li> <li>Pedagogical flow recommendations</li> <li>Clear 3-5 letter abbreviations for use in CSV file</li> </ul> <p>View the Concept Taxonomy</p>"},{"location":"learning-graph/#taxonomy-distribution","title":"Taxonomy Distribution","text":"<p>This report shows how many concepts fit into each category of the taxonomy. Our goal is a somewhat balanced taxonomy where each category holds an equal number of concepts.  We also don't want any category to contain over 30% of our concepts.</p> <ul> <li>Statistical breakdown</li> <li>Detailed concept listing by category</li> <li>Visual distribution table</li> <li>Balance verification</li> </ul> <p>View the Taxonomy Distribution Report</p>"},{"location":"learning-graph/book-metrics/","title":"Book Metrics","text":""},{"location":"learning-graph/book-metrics/#book-metrics","title":"Book Metrics","text":"<p>Generated by: Book Metrics Python Program v0.05 Generated on: February 12, 2026 at 06:41 AM</p> <p>This file contains overall metrics for the intelligent textbook.</p> <p>Note: Student-facing content metrics exclude <code>prompts/</code> and <code>learning-graph/</code> directories. Chapter-only metrics show what students see in the main chapters.</p>"},{"location":"learning-graph/book-metrics/#overall-metrics","title":"Overall Metrics","text":"Metric Name Value Link Notes Chapters 20 Chapters Number of chapter directories Concepts 400 Concept List Concepts from learning graph Glossary Terms 400 Glossary Defined terms FAQs 45 FAQ Frequently asked questions Quiz Questions 0 - Questions across all chapters MicroSims 30 Simulations Interactive MicroSims"},{"location":"learning-graph/book-metrics/#student-facing-content-metrics","title":"Student-Facing Content Metrics","text":"<p>Excludes administrative directories (<code>prompts/</code>, <code>learning-graph/</code>).</p> Metric Name All Content Chapters Only Notes Diagrams 119 119 H4 headers starting with '#### Diagram:' Equations 5 5 LaTeX expressions (inline and display) Total Words 115,774 97,194 Words in markdown files Links 382 197 Hyperlinks in markdown format Equivalent Pages 507 433 Estimated pages (250 words/page + visuals)"},{"location":"learning-graph/book-metrics/#metrics-explanation","title":"Metrics Explanation","text":""},{"location":"learning-graph/book-metrics/#structural-metrics","title":"Structural Metrics","text":"<ul> <li>Chapters: Count of chapter directories containing index.md files</li> <li>Concepts: Number of rows in learning-graph.csv</li> <li>Glossary Terms: H4 headers in glossary.md</li> <li>FAQs: H3 headers in faq.md</li> <li>Quiz Questions: H4 headers with numbered questions (e.g., '#### 1.') or H2 headers in quiz.md files</li> <li>MicroSims: Directories in docs/sims/ with index.md files</li> </ul>"},{"location":"learning-graph/book-metrics/#content-metrics","title":"Content Metrics","text":"<ul> <li>Diagrams: H4 headers starting with '#### Diagram:'</li> <li>Equations: LaTeX expressions using $ and $$ delimiters</li> <li>Total Words: All words in markdown files (excluding code blocks and URLs)</li> <li>Links: Markdown-formatted links <code>[text](url)</code></li> <li>Equivalent Pages: Based on 250 words/page + 0.25 page/diagram + 0.5 page/MicroSim</li> </ul>"},{"location":"learning-graph/book-metrics/#column-explanations","title":"Column Explanations","text":"<ul> <li>All Content: Includes all student-facing content (chapters, glossary, FAQ, sims, etc.) but excludes administrative directories</li> <li>Chapters Only: Aggregated from chapter directories only - represents the core textbook content students read</li> </ul> <p>Excluded Directories: <code>prompts/</code>, <code>learning-graph/</code> (administrative content not visible to students)</p>"},{"location":"learning-graph/chapter-metrics/","title":"Chapter Metrics","text":""},{"location":"learning-graph/chapter-metrics/#chapter-metrics","title":"Chapter Metrics","text":"<p>Generated by: Book Metrics Python Program v0.05 Generated on: February 12, 2026 at 06:41 AM</p> <p>This file contains chapter-by-chapter metrics for student-facing content.</p> Chapter Name Sections Diagrams Equations Words Links 1 Introduction to Computer Science 27 5 0 5,925 6 2 Python Fundamentals 37 6 1 4,935 6 3 Boolean Logic and Comparisons 20 6 0 4,954 7 4 Control Flow 28 6 0 5,133 8 5 Working with Strings 33 6 0 5,108 9 6 Functions and Modular Design 25 6 0 5,117 10 7 Higher-Order Functions and Recursion 27 6 1 5,466 10 8 Lists 24 6 0 4,385 9 9 Advanced List Operations 27 6 0 4,354 9 10 Tuples and Sets 21 6 0 4,500 10 11 Dictionaries 27 6 0 4,177 11 12 Classes and Objects 24 6 0 4,616 9 13 Inheritance and Polymorphism 23 6 0 4,270 9 14 Errors and Exceptions 21 6 2 4,836 11 15 File Input and Output 22 6 0 4,978 11 16 Software Engineering Practices 34 6 0 5,045 11 17 Testing and Debugging 24 6 0 5,605 12 18 Searching and Sorting 26 6 0 5,567 12 19 Algorithm Analysis and Problem Solving 23 6 0 3,802 12 20 Advanced Python Features 31 6 1 4,421 15"},{"location":"learning-graph/chapter-metrics/#metrics-explanation","title":"Metrics Explanation","text":"<ul> <li>Chapter: Chapter number (leading zeros removed)</li> <li>Name: Chapter title from index.md</li> <li>Sections: Count of H2 and H3 headers in chapter markdown files</li> <li>Diagrams: Count of H4 headers starting with '#### Diagram:'</li> <li>Equations: LaTeX expressions using $ and $$ delimiters</li> <li>Words: Word count across all markdown files in the chapter</li> <li>Links: Markdown-formatted links <code>[text](url)</code></li> </ul>"},{"location":"learning-graph/concept-list/","title":"Concept Enumeration","text":""},{"location":"learning-graph/concept-list/#concept-list","title":"Concept List","text":"<p>The following is a numbered list of concepts for the AP Computer Science (Python Version) course. Each concept is a short Title Case label (max 32 characters) that represents a distinct learning objective or knowledge unit.</p>"},{"location":"learning-graph/concept-list/#foundational-concepts-1-20","title":"Foundational Concepts (1-20)","text":"<ol> <li>Computer Science</li> <li>Computational Thinking</li> <li>Algorithms</li> <li>Abstraction</li> <li>Decomposition</li> <li>Pattern Recognition</li> <li>Stepwise Refinement</li> <li>Problem Solving</li> <li>Binary Number System</li> <li>Bits and Bytes</li> <li>Character Encoding</li> <li>ASCII and Unicode</li> <li>Computer Hardware</li> <li>CPU and Memory</li> <li>Input and Output Devices</li> <li>Operating Systems</li> <li>Programming Languages</li> <li>Compiled vs Interpreted</li> <li>Python Language</li> <li>Python Interpreter</li> </ol>"},{"location":"learning-graph/concept-list/#python-basics-21-50","title":"Python Basics (21-50)","text":"<ol> <li>Python REPL</li> <li>Python Scripts</li> <li>Comments in Code</li> <li>Variables</li> <li>Variable Assignment</li> <li>Variable Naming Rules</li> <li>Data Types</li> <li>Integer Type</li> <li>Float Type</li> <li>Boolean Type</li> <li>String Type</li> <li>Type Function</li> <li>Type Conversion</li> <li>Implicit Type Conversion</li> <li>Explicit Type Casting</li> <li>Arithmetic Operators</li> <li>Integer Division</li> <li>Modulo Operator</li> <li>Operator Precedence</li> <li>String Concatenation</li> <li>String Repetition</li> <li>F-String Formatting</li> <li>Print Function</li> <li>Input Function</li> <li>Multiple Assignment</li> <li>Constants Convention</li> <li>Augmented Assignment</li> <li>Expressions</li> <li>Statements</li> <li>Code Readability</li> </ol>"},{"location":"learning-graph/concept-list/#boolean-logic-and-comparisons-51-65","title":"Boolean Logic and Comparisons (51-65)","text":"<ol> <li>Boolean Expressions</li> <li>Comparison Operators</li> <li>Equal and Not Equal</li> <li>Greater and Less Than</li> <li>Logical Operators</li> <li>And Operator</li> <li>Or Operator</li> <li>Not Operator</li> <li>Short-Circuit Evaluation</li> <li>Truthiness and Falsiness</li> <li>Boolean Conversion</li> <li>Chained Comparisons</li> <li>Order of Operations</li> <li>De Morgan's Laws</li> <li>Truth Tables</li> </ol>"},{"location":"learning-graph/concept-list/#control-flow-66-90","title":"Control Flow (66-90)","text":"<ol> <li>Control Flow</li> <li>Sequential Execution</li> <li>Conditional Statements</li> <li>If Statement</li> <li>If-Else Statement</li> <li>Elif Statement</li> <li>Nested Conditionals</li> <li>Ternary Expression</li> <li>Match Statement</li> <li>Loops</li> <li>For Loop</li> <li>While Loop</li> <li>Range Function</li> <li>Loop Variable</li> <li>Loop Body</li> <li>Infinite Loops</li> <li>Break Statement</li> <li>Continue Statement</li> <li>Nested Loops</li> <li>Loop Patterns</li> <li>Accumulator Pattern</li> <li>Counter Pattern</li> <li>Sentinel Value Pattern</li> <li>Flag Variable Pattern</li> <li>Loop Else Clause</li> </ol>"},{"location":"learning-graph/concept-list/#strings-91-115","title":"Strings (91-115)","text":"<ol> <li>String Basics</li> <li>String Indexing</li> <li>Negative Indexing</li> <li>String Slicing</li> <li>Slice Notation</li> <li>String Immutability</li> <li>String Length</li> <li>String Methods</li> <li>Upper and Lower Methods</li> <li>Strip Method</li> <li>Split Method</li> <li>Join Method</li> <li>Find and Replace Methods</li> <li>Startswith and Endswith</li> <li>String Iteration</li> <li>String Comparison</li> <li>Escape Characters</li> <li>Raw Strings</li> <li>Multiline Strings</li> <li>String Formatting</li> <li>Format Method</li> <li>String Validation Methods</li> <li>In Operator for Strings</li> <li>Character Methods</li> <li>String Reversal</li> </ol>"},{"location":"learning-graph/concept-list/#functions-116-150","title":"Functions (116-150)","text":"<ol> <li>Functions</li> <li>Function Definition</li> <li>Function Call</li> <li>Parameters</li> <li>Arguments</li> <li>Return Statement</li> <li>Return Values</li> <li>None Type</li> <li>Default Parameters</li> <li>Keyword Arguments</li> <li>Positional Arguments</li> <li>Multiple Return Values</li> <li>Variable Scope</li> <li>Local Variables</li> <li>Global Variables</li> <li>Global Keyword</li> <li>Docstrings</li> <li>Function Documentation</li> <li>Helper Functions</li> <li>Main Function Pattern</li> <li>Name Equals Main</li> <li>Lambda Functions</li> <li>Higher-Order Functions</li> <li>Map Function</li> <li>Filter Function</li> <li>Reduce Function</li> <li>Function Composition</li> <li>Recursion</li> <li>Base Case</li> <li>Recursive Case</li> <li>Recursive Call Stack</li> <li>Stack Overflow</li> <li>Recursion vs Iteration</li> <li>Recursive Patterns</li> <li>Memoization</li> </ol>"},{"location":"learning-graph/concept-list/#lists-151-185","title":"Lists (151-185)","text":"<ol> <li>Lists</li> <li>List Creation</li> <li>List Indexing</li> <li>List Slicing</li> <li>List Mutability</li> <li>List Methods</li> <li>Append Method</li> <li>Insert Method</li> <li>Remove Method</li> <li>Pop Method</li> <li>Sort Method</li> <li>Reverse Method</li> <li>List Comprehension</li> <li>Nested Lists</li> <li>List of Lists</li> <li>List Traversal</li> <li>For Loop with Lists</li> <li>Enumerate Function</li> <li>List Unpacking</li> <li>Zip Function</li> <li>List Copying</li> <li>Shallow Copy</li> <li>Deep Copy</li> <li>List Concatenation</li> <li>List Repetition</li> <li>In Operator for Lists</li> <li>Index Method</li> <li>Count Method</li> <li>Min Max Sum Functions</li> <li>Len Function for Lists</li> <li>Sorted Function</li> <li>List as Stack</li> <li>List as Queue</li> <li>List Aliasing</li> <li>Identity vs Equality</li> </ol>"},{"location":"learning-graph/concept-list/#tuples-and-sets-186-205","title":"Tuples and Sets (186-205)","text":"<ol> <li>Tuples</li> <li>Tuple Creation</li> <li>Tuple Immutability</li> <li>Tuple Packing</li> <li>Tuple Unpacking</li> <li>Named Tuples</li> <li>Tuple Methods</li> <li>Tuples as Keys</li> <li>Tuples vs Lists</li> <li>Sets</li> <li>Set Creation</li> <li>Set Operations</li> <li>Set Union</li> <li>Set Intersection</li> <li>Set Difference</li> <li>Set Symmetric Difference</li> <li>Set Methods</li> <li>Membership Testing</li> <li>Frozenset</li> <li>Removing Duplicates</li> </ol>"},{"location":"learning-graph/concept-list/#dictionaries-206-230","title":"Dictionaries (206-230)","text":"<ol> <li>Dictionaries</li> <li>Dictionary Creation</li> <li>Key-Value Pairs</li> <li>Dictionary Access</li> <li>Dictionary Methods</li> <li>Get Method</li> <li>Keys Method</li> <li>Values Method</li> <li>Items Method</li> <li>Dictionary Iteration</li> <li>Dictionary Comprehension</li> <li>Nested Dictionaries</li> <li>Default Values</li> <li>Update Method</li> <li>Pop Method for Dicts</li> <li>Dictionary Merging</li> <li>Counting with Dicts</li> <li>Grouping with Dicts</li> <li>Dictionary as Cache</li> <li>Hashable Keys</li> <li>Dict vs List Lookup</li> <li>JSON and Dictionaries</li> <li>OrderedDict</li> <li>DefaultDict</li> <li>Counter Class</li> </ol>"},{"location":"learning-graph/concept-list/#object-oriented-programming-231-275","title":"Object-Oriented Programming (231-275)","text":"<ol> <li>Object-Oriented Programming</li> <li>Classes</li> <li>Objects</li> <li>Class Definition</li> <li>Class Instantiation</li> <li>Instance Attributes</li> <li>Class Attributes</li> <li>The Self Parameter</li> <li>Init Method</li> <li>Constructor</li> <li>Methods</li> <li>Instance Methods</li> <li>Str Method</li> <li>Repr Method</li> <li>Encapsulation</li> <li>Private Attributes</li> <li>Getter Methods</li> <li>Setter Methods</li> <li>Property Decorator</li> <li>Class Methods</li> <li>Static Methods</li> <li>Composition</li> <li>Has-A Relationship</li> <li>Inheritance</li> <li>Is-A Relationship</li> <li>Parent Class</li> <li>Child Class</li> <li>Super Function</li> <li>Method Overriding</li> <li>Polymorphism</li> <li>Duck Typing</li> <li>Abstract Classes</li> <li>Multiple Inheritance</li> <li>Method Resolution Order</li> <li>Operator Overloading</li> <li>Eq and Lt Methods</li> <li>Add and Mul Methods</li> <li>Iterable Protocol</li> <li>Iterator Protocol</li> <li>Dunder Methods</li> <li>Object Identity</li> <li>Object Comparison</li> <li>Class Hierarchies</li> <li>UML Class Diagrams</li> <li>Design Patterns Intro</li> </ol>"},{"location":"learning-graph/concept-list/#file-io-276-290","title":"File I/O (276-290)","text":"<ol> <li>File Input Output</li> <li>Opening Files</li> <li>File Modes</li> <li>Read Method</li> <li>Readline Method</li> <li>Readlines Method</li> <li>Write Method</li> <li>Writelines Method</li> <li>With Statement</li> <li>Context Managers</li> <li>File Paths</li> <li>CSV Files</li> <li>JSON Files</li> <li>File Exceptions</li> <li>Text vs Binary Files</li> </ol>"},{"location":"learning-graph/concept-list/#error-handling-291-305","title":"Error Handling (291-305)","text":"<ol> <li>Errors and Exceptions</li> <li>Syntax Errors</li> <li>Runtime Errors</li> <li>Logic Errors</li> <li>Exception Types</li> <li>TypeError</li> <li>ValueError</li> <li>IndexError</li> <li>KeyError</li> <li>Try-Except Block</li> <li>Multiple Except Blocks</li> <li>Finally Block</li> <li>Raising Exceptions</li> <li>Custom Exceptions</li> <li>Assertions</li> </ol>"},{"location":"learning-graph/concept-list/#testing-and-debugging-306-325","title":"Testing and Debugging (306-325)","text":"<ol> <li>Testing</li> <li>Manual Testing</li> <li>Unit Testing</li> <li>Test Cases</li> <li>Assert Statements</li> <li>Unittest Module</li> <li>Test Functions</li> <li>Edge Cases</li> <li>Boundary Testing</li> <li>Test-Driven Development</li> <li>Debugging</li> <li>Print Debugging</li> <li>Debugger Tools</li> <li>Breakpoints</li> <li>Step Through Code</li> <li>Code Tracing</li> <li>Rubber Duck Debugging</li> <li>Defensive Programming</li> <li>Input Validation</li> <li>Code Review</li> </ol>"},{"location":"learning-graph/concept-list/#algorithms-and-analysis-326-360","title":"Algorithms and Analysis (326-360)","text":"<ol> <li>Algorithm Design</li> <li>Pseudocode</li> <li>Flowcharts</li> <li>Linear Search</li> <li>Binary Search</li> <li>Search Comparison</li> <li>Selection Sort</li> <li>Insertion Sort</li> <li>Merge Sort</li> <li>Merge Sort Recursion</li> <li>Sorting Comparison</li> <li>Stable vs Unstable Sort</li> <li>Algorithm Correctness</li> <li>Loop Invariants</li> <li>Big-O Notation</li> <li>Time Complexity</li> <li>Space Complexity</li> <li>Constant Time O(1)</li> <li>Linear Time O(n)</li> <li>Quadratic Time O(n^2)</li> <li>Logarithmic Time O(log n)</li> <li>Linearithmic Time</li> <li>Best Average Worst Case</li> <li>Empirical Analysis</li> <li>Counting Operations</li> <li>Brute Force Approach</li> <li>Divide and Conquer</li> <li>Greedy Algorithms</li> <li>Algorithm Tradeoffs</li> <li>Efficiency vs Readability</li> <li>Two Pointer Technique</li> <li>Sliding Window Pattern</li> <li>Frequency Counter Pattern</li> <li>Recursion in Algorithms</li> <li>Algorithm Visualization</li> </ol>"},{"location":"learning-graph/concept-list/#software-engineering-361-380","title":"Software Engineering (361-380)","text":"<ol> <li>Software Development</li> <li>Program Planning</li> <li>Requirements Analysis</li> <li>Modular Design</li> <li>Code Organization</li> <li>Import Statements</li> <li>Python Modules</li> <li>Python Packages</li> <li>Pip Package Manager</li> <li>Virtual Environments</li> <li>Version Control Intro</li> <li>Git Basics</li> <li>Code Style</li> <li>PEP 8 Guidelines</li> <li>Linting Tools</li> <li>Refactoring</li> <li>DRY Principle</li> <li>KISS Principle</li> <li>Code Comments</li> <li>Documentation</li> </ol>"},{"location":"learning-graph/concept-list/#advanced-python-concepts-381-400","title":"Advanced Python Concepts (381-400)","text":"<ol> <li>Generators</li> <li>Yield Statement</li> <li>Generator Expressions</li> <li>Decorators</li> <li>Closures</li> <li>Args and Kwargs</li> <li>Unpacking Operators</li> <li>Walrus Operator</li> <li>Type Hints</li> <li>Type Annotations</li> <li>Dataclasses</li> <li>Enum Type</li> <li>Regular Expressions</li> <li>Collections Module</li> <li>Itertools Module</li> <li>Functools Module</li> <li>List vs Generator Memory</li> <li>Comprehension Patterns</li> <li>Context Manager Protocol</li> <li>Python Best Practices</li> </ol>"},{"location":"learning-graph/concept-taxonomy/","title":"Concept Taxonomy","text":""},{"location":"learning-graph/concept-taxonomy/#concept-taxonomy","title":"Concept Taxonomy","text":"<p>This document defines the categorical taxonomy used to organize the 400 concepts in the AP Computer Science (Python Version) learning graph. Each category has a 3-5 letter abbreviation (TaxonomyID) used in the CSV and JSON files.</p>"},{"location":"learning-graph/concept-taxonomy/#taxonomy-categories","title":"Taxonomy Categories","text":""},{"location":"learning-graph/concept-taxonomy/#1-foundation-concepts-found","title":"1. Foundation Concepts (FOUND)","text":"<p>TaxonomyID: FOUND</p> <p>Prerequisite concepts that provide the foundational knowledge needed before programming begins. Includes computational thinking, hardware basics, number systems, and general computer science principles.</p> <p>Concept range: 1-20 (approximately)</p>"},{"location":"learning-graph/concept-taxonomy/#2-python-basics-pybasic","title":"2. Python Basics (PYBASIC)","text":"<p>TaxonomyID: PYBASIC</p> <p>Core Python language fundamentals including variables, data types, operators, input/output, and basic expressions. The building blocks for all Python programming.</p> <p>Concept range: 21-50 (approximately)</p>"},{"location":"learning-graph/concept-taxonomy/#3-boolean-logic-bool","title":"3. Boolean Logic (BOOL)","text":"<p>TaxonomyID: BOOL</p> <p>Boolean expressions, comparison and logical operators, truth tables, and evaluation rules. Essential for conditional programming and control flow.</p> <p>Concept range: 51-65 (approximately)</p>"},{"location":"learning-graph/concept-taxonomy/#4-control-flow-ctrl","title":"4. Control Flow (CTRL)","text":"<p>TaxonomyID: CTRL</p> <p>Conditional statements, loops, iteration patterns, and program flow control. The mechanisms that direct program execution order.</p> <p>Concept range: 66-90 (approximately)</p>"},{"location":"learning-graph/concept-taxonomy/#5-strings-str","title":"5. Strings (STR)","text":"<p>TaxonomyID: STR</p> <p>String data type operations including indexing, slicing, methods, formatting, and iteration. Working with text data in Python.</p> <p>Concept range: 91-115 (approximately)</p>"},{"location":"learning-graph/concept-taxonomy/#6-functions-func","title":"6. Functions (FUNC)","text":"<p>TaxonomyID: FUNC</p> <p>Function definition, parameters, return values, scope, documentation, higher-order functions, and lambda expressions. Modular program design.</p> <p>Concept range: 116-142 (approximately)</p>"},{"location":"learning-graph/concept-taxonomy/#7-recursion-rec","title":"7. Recursion (REC)","text":"<p>TaxonomyID: REC</p> <p>Recursive thinking, base cases, recursive cases, call stacks, and comparison with iterative approaches. A fundamental algorithmic technique.</p> <p>Concept range: 143-150 (approximately)</p>"},{"location":"learning-graph/concept-taxonomy/#8-data-structures-data","title":"8. Data Structures (DATA)","text":"<p>TaxonomyID: DATA</p> <p>Lists, tuples, sets, and dictionaries - Python's built-in collection types. Includes creation, manipulation, methods, comprehensions, and nested structures.</p> <p>Concept range: 151-230 (approximately)</p>"},{"location":"learning-graph/concept-taxonomy/#9-object-oriented-programming-oop","title":"9. Object-Oriented Programming (OOP)","text":"<p>TaxonomyID: OOP</p> <p>Classes, objects, inheritance, polymorphism, encapsulation, composition, and design patterns. The object-oriented paradigm in Python.</p> <p>Concept range: 231-275 (approximately)</p>"},{"location":"learning-graph/concept-taxonomy/#10-file-io-fileio","title":"10. File I/O (FILEIO)","text":"<p>TaxonomyID: FILEIO</p> <p>Reading from and writing to files, file modes, context managers, and working with CSV and JSON data formats.</p> <p>Concept range: 276-290 (approximately)</p>"},{"location":"learning-graph/concept-taxonomy/#11-error-handling-err","title":"11. Error Handling (ERR)","text":"<p>TaxonomyID: ERR</p> <p>Exceptions, error types, try-except blocks, raising exceptions, and defensive programming techniques.</p> <p>Concept range: 291-305 (approximately)</p>"},{"location":"learning-graph/concept-taxonomy/#12-testing-and-debugging-test","title":"12. Testing and Debugging (TEST)","text":"<p>TaxonomyID: TEST</p> <p>Unit testing, test cases, debugging strategies, code tracing, and quality assurance practices for software development.</p> <p>Concept range: 306-325 (approximately)</p>"},{"location":"learning-graph/concept-taxonomy/#13-algorithms-algo","title":"13. Algorithms (ALGO)","text":"<p>TaxonomyID: ALGO</p> <p>Algorithm design, searching, sorting, complexity analysis (Big-O), and algorithmic problem-solving strategies.</p> <p>Concept range: 326-360 (approximately)</p>"},{"location":"learning-graph/concept-taxonomy/#14-software-engineering-seng","title":"14. Software Engineering (SENG)","text":"<p>TaxonomyID: SENG</p> <p>Software development practices, code organization, modules, packages, version control, style guides, and documentation.</p> <p>Concept range: 361-380 (approximately)</p>"},{"location":"learning-graph/concept-taxonomy/#15-advanced-python-advpy","title":"15. Advanced Python (ADVPY)","text":"<p>TaxonomyID: ADVPY</p> <p>Advanced language features including generators, decorators, type hints, dataclasses, and standard library modules for experienced students.</p> <p>Concept range: 381-400 (approximately)</p>"},{"location":"learning-graph/concept-taxonomy/#summary-table","title":"Summary Table","text":"Category TaxonomyID Description Approx. Count Foundation Concepts FOUND CS fundamentals, hardware, number systems 20 Python Basics PYBASIC Variables, types, operators, I/O 30 Boolean Logic BOOL Boolean expressions, logical operators 15 Control Flow CTRL Conditionals, loops, patterns 25 Strings STR String operations and methods 25 Functions FUNC Function design and higher-order functions 27 Recursion REC Recursive algorithms and patterns 8 Data Structures DATA Lists, tuples, sets, dictionaries 80 Object-Oriented Programming OOP Classes, inheritance, polymorphism 45 File I/O FILEIO File operations and data formats 15 Error Handling ERR Exceptions and error management 15 Testing and Debugging TEST Testing, debugging, code quality 20 Algorithms ALGO Searching, sorting, Big-O analysis 35 Software Engineering SENG Development practices and tools 20 Advanced Python ADVPY Generators, decorators, type hints 20 Total 400"},{"location":"learning-graph/course-description-assessment/","title":"Course Description Assessment","text":""},{"location":"learning-graph/course-description-assessment/#course-description-quality-assessment","title":"Course Description Quality Assessment","text":""},{"location":"learning-graph/course-description-assessment/#overview","title":"Overview","text":"<p>Course Title: AP Computer Science (Python Version) Assessment Date: 2026-02-11 Quality Score: 100/100</p>"},{"location":"learning-graph/course-description-assessment/#scoring-breakdown","title":"Scoring Breakdown","text":"Element Points Max Assessment Title 5 5 \"AP Computer Science (Python Version)\" - clear and descriptive Target Audience 5 5 Specific: grades 10-12, STEM students, university prep Prerequisites 5 5 Listed: Algebra I, logical reasoning, computer literacy Main Topics Covered 10 10 10 detailed topic sections with sub-topics Topics Excluded 5 5 Clear list of 10 excluded topics Learning Outcomes Header 5 5 \"Students will be able to:\" present for all levels Remember Level 10 10 4 specific, actionable outcomes Understand Level 10 10 5 specific, actionable outcomes Apply Level 10 10 5 specific, actionable outcomes Analyze Level 10 10 5 specific, actionable outcomes Evaluate Level 10 10 5 specific, actionable outcomes Create Level 10 10 5 specific, actionable outcomes Descriptive Context 5 5 College-level alignment context included Total 100 100"},{"location":"learning-graph/course-description-assessment/#strengths","title":"Strengths","text":"<ul> <li>Comprehensive Bloom's Taxonomy coverage: All six levels (Remember through Create) have 4-5 specific, actionable outcomes each</li> <li>Clear audience specification: Well-defined target audience with specific grade levels and interests</li> <li>Thorough topic coverage: 10 major topic areas with detailed sub-topics provide excellent granularity</li> <li>Clear boundaries: Topics NOT covered section sets clear expectations</li> <li>College alignment context: Helps students understand the rigor and purpose of the course</li> <li>Estimated concept yield: 200+ concepts can easily be derived from this description</li> </ul>"},{"location":"learning-graph/course-description-assessment/#concept-estimation","title":"Concept Estimation","text":"<p>Based on the depth and breadth of topics covered:</p> <ul> <li>Computational Thinking: ~15 concepts</li> <li>Python Fundamentals: ~25 concepts</li> <li>Control Structures: ~20 concepts</li> <li>Functions and Modular Design: ~20 concepts</li> <li>Data Structures: ~25 concepts</li> <li>Object-Oriented Programming: ~30 concepts</li> <li>Algorithms: ~20 concepts</li> <li>Recursion: ~15 concepts</li> <li>File I/O: ~10 concepts</li> <li>Testing and Debugging: ~15 concepts</li> <li>Cross-cutting concepts (software engineering, best practices): ~5 concepts</li> </ul> <p>Total estimated: ~200 concepts - excellent alignment with target</p>"},{"location":"learning-graph/course-description-assessment/#comparison-with-similar-courses","title":"Comparison with Similar Courses","text":"<p>This course description is comparable to or exceeds the quality of typical AP CS A course descriptions. The Python-specific focus and detailed Bloom's Taxonomy outcomes are particularly strong.</p>"},{"location":"learning-graph/course-description-assessment/#recommendation","title":"Recommendation","text":"<p>Proceed with learning graph generation. This course description is excellent and provides more than sufficient content for generating 200 high-quality concepts.</p>"},{"location":"learning-graph/diagram-details/","title":"Diagram Details","text":""},{"location":"learning-graph/diagram-details/#diagram-and-microsim-details","title":"Diagram and MicroSim Details","text":"<p>Total Visual Elements: 104 Diagrams: 2 MicroSims: 102</p>"},{"location":"learning-graph/diagram-details/#chapter-1-intro-to-computer-science","title":"Chapter 1: Intro To Computer Science","text":"<p>Total elements: 5</p>"},{"location":"learning-graph/diagram-details/#ascii-character-map","title":"ASCII Character Map","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 2</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to look up the ASCII numeric value for common characters and recognize the pattern of how letters and digits are organized in th...</li> </ul>"},{"location":"learning-graph/diagram-details/#binary-number-explorer","title":"Binary Number Explorer","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 12</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to convert between binary and decimal representations by toggling individual bits and observing the resulting decimal value....</li> </ul>"},{"location":"learning-graph/diagram-details/#compiled-vs-interpreted-languages","title":"Compiled vs. Interpreted Languages","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 6</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to compare compiled and interpreted language execution models by stepping through a visual side-by-side demonstration of how sou...</li> </ul>"},{"location":"learning-graph/diagram-details/#computational-thinking-pillars","title":"Computational Thinking Pillars","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 3</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to identify and explain the four pillars of computational thinking (decomposition, pattern recognition, abstraction, algorithms)...</li> </ul>"},{"location":"learning-graph/diagram-details/#inside-a-computer","title":"Inside a Computer","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 6</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to identify the main hardware components of a computer (CPU, RAM, storage, input devices, output devices) and describe the role ...</li> </ul>"},{"location":"learning-graph/diagram-details/#chapter-2-python-fundamentals","title":"Chapter 2: Python Fundamentals","text":"<p>Total elements: 6</p>"},{"location":"learning-graph/diagram-details/#arithmetic-operators-explorer","title":"Arithmetic Operators Explorer","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 8</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to apply Python's seven arithmetic operators to compute correct results, with special attention to integer division and modulo....</li> </ul>"},{"location":"learning-graph/diagram-details/#code-readability-comparison","title":"Code Readability Comparison","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 6</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to evaluate Python code for readability and identify specific improvements (naming, spacing, comments, structure)....</li> </ul>"},{"location":"learning-graph/diagram-details/#expressions-vs-statements","title":"Expressions vs. Statements","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 2</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to classify Python code fragments as expressions (produce a value) or statements (perform an action) and explain the difference....</li> </ul>"},{"location":"learning-graph/diagram-details/#python-data-types-overview","title":"Python Data Types Overview","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 2</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to identify the four fundamental Python data types (int, float, bool, str) and classify example values into the correct type....</li> </ul>"},{"location":"learning-graph/diagram-details/#python-repl-vs-scripts","title":"Python REPL vs. Scripts","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 5</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to distinguish between interactive REPL mode and script mode, understanding when to use each approach....</li> </ul>"},{"location":"learning-graph/diagram-details/#string-operations-playground","title":"String Operations Playground","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 11</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to construct string expressions using concatenation, repetition, and f-string formatting, and predict the output of string opera...</li> </ul>"},{"location":"learning-graph/diagram-details/#chapter-3-boolean-logic","title":"Chapter 3: Boolean Logic","text":"<p>Total elements: 6</p>"},{"location":"learning-graph/diagram-details/#comparison-operator-explorer","title":"Comparison Operator Explorer","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 14</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to predict and verify the result of comparison expressions by selecting operators and values, then checking the Boolean output....</li> </ul>"},{"location":"learning-graph/diagram-details/#de-morgans-laws-visualizer","title":"De Morgan's Laws Visualizer","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 11</li> <li>Difficulty: Very Hard</li> <li>Learning Objective: Students will be able to apply De Morgan's Laws to transform Boolean expressions and verify equivalence using side-by-side truth tables....</li> </ul>"},{"location":"learning-graph/diagram-details/#interactive-truth-table-builder","title":"Interactive Truth Table Builder","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 10</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to construct truth tables for compound Boolean expressions and evaluate whether two expressions are logically equivalent....</li> </ul>"},{"location":"learning-graph/diagram-details/#logical-operator-venn-diagrams","title":"Logical Operator Venn Diagrams","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 5</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to visualize the behavior of <code>and</code>, <code>or</code>, and <code>not</code> operators using Venn diagrams and predict the result of combined Boolean exp...</li> </ul>"},{"location":"learning-graph/diagram-details/#order-of-operations-visualizer","title":"Order of Operations Visualizer","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 10</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to trace the step-by-step evaluation of complex Boolean expressions by applying the correct order of operations....</li> </ul>"},{"location":"learning-graph/diagram-details/#truthiness-tester","title":"Truthiness Tester","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 4</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to classify Python values as truthy or falsy and predict the result of <code>bool()</code> conversion....</li> </ul>"},{"location":"learning-graph/diagram-details/#chapter-4-control-flow","title":"Chapter 4: Control Flow","text":"<p>Total elements: 6</p>"},{"location":"learning-graph/diagram-details/#break-vs-continue-visualizer","title":"Break vs Continue Visualizer","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 5</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to distinguish between break and continue by tracing the execution of loops that use each statement and predicting the output....</li> </ul>"},{"location":"learning-graph/diagram-details/#control-flow-patterns","title":"Control Flow Patterns","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 8</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to identify and distinguish the three fundamental control flow patterns (sequential, selection, iteration) and trace the path of...</li> </ul>"},{"location":"learning-graph/diagram-details/#if-elif-else-flowchart","title":"If-Elif-Else Flowchart","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 6</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to trace the execution path through an if-elif-else chain by entering a test value and observing which branch is taken....</li> </ul>"},{"location":"learning-graph/diagram-details/#loop-patterns-comparison","title":"Loop Patterns Comparison","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 5</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to identify which loop pattern (accumulator, counter, sentinel, flag) is being used in a given code example and explain why that...</li> </ul>"},{"location":"learning-graph/diagram-details/#nested-loop-grid-visualizer","title":"Nested Loop Grid Visualizer","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 8</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to trace the execution order of nested loops by watching a cell-by-cell animation across a grid and predicting which cell is fil...</li> </ul>"},{"location":"learning-graph/diagram-details/#range-function-explorer","title":"Range Function Explorer","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 8</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to predict the output of the range() function with various start, stop, and step arguments by adjusting sliders and observing th...</li> </ul>"},{"location":"learning-graph/diagram-details/#chapter-5-working-with-strings","title":"Chapter 5: Working With Strings","text":"<p>Total elements: 6</p>"},{"location":"learning-graph/diagram-details/#palindrome-checker","title":"Palindrome Checker","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 2</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to apply string reversal and cleaning techniques to determine whether a given string is a palindrome, and trace through the comp...</li> </ul>"},{"location":"learning-graph/diagram-details/#split-and-join-visualizer","title":"Split and Join Visualizer","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 11</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to explain how <code>split()</code> breaks a string into a list and how <code>join()</code> reassembles a list into a string, and predict the output f...</li> </ul>"},{"location":"learning-graph/diagram-details/#string-formatting-comparison","title":"String Formatting Comparison","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 5</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to construct formatted strings using f-strings and the <code>.format()</code> method, and choose the appropriate formatting approach for a ...</li> </ul>"},{"location":"learning-graph/diagram-details/#string-indexing-visualizer","title":"String Indexing Visualizer","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 7</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to determine the character at any given index (positive or negative) within a string....</li> </ul>"},{"location":"learning-graph/diagram-details/#string-methods-explorer","title":"String Methods Explorer","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 14</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to apply common string methods to a given input string, predict the output before seeing it, and explain what each method does....</li> </ul>"},{"location":"learning-graph/diagram-details/#string-slicing-playground","title":"String Slicing Playground","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 16</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to use slice notation to extract substrings, predict the result of a slice expression, and experiment with start, stop, and step...</li> </ul>"},{"location":"learning-graph/diagram-details/#chapter-6-functions-and-modular-design","title":"Chapter 6: Functions And Modular Design","text":"<p>Total elements: 6</p>"},{"location":"learning-graph/diagram-details/#arguments-vs-parameters","title":"Arguments vs Parameters","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 1</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to distinguish between parameters (in the definition) and arguments (in the call), and between positional, keyword, and default ...</li> </ul>"},{"location":"learning-graph/diagram-details/#function-anatomy","title":"Function Anatomy","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 4</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to identify the parts of a Python function definition \u2014 the <code>def</code> keyword, function name, parameters, colon, body, and return st...</li> </ul>"},{"location":"learning-graph/diagram-details/#function-call-flow","title":"Function Call Flow","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 10</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to trace the flow of execution when a function is called, including how arguments are passed, how the function body runs, and ho...</li> </ul>"},{"location":"learning-graph/diagram-details/#function-pattern-gallery","title":"Function Pattern Gallery","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 2</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to recognize and apply common function patterns (input validation, multiple returns, result accumulation, function composition) ...</li> </ul>"},{"location":"learning-graph/diagram-details/#modular-design-builder","title":"Modular Design Builder","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 9</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to break a monolithic program into modular functions by identifying logical units of work and creating appropriate function boun...</li> </ul>"},{"location":"learning-graph/diagram-details/#variable-scope-visualizer","title":"Variable Scope Visualizer","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 11</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to predict the value of variables at different points in a program by understanding the rules of local and global variable scope...</li> </ul>"},{"location":"learning-graph/diagram-details/#chapter-7-higher-order-functions-and-recursion","title":"Chapter 7: Higher Order Functions And Recursion","text":"<p>Total elements: 6</p>"},{"location":"learning-graph/diagram-details/#factorial-recursion-tree","title":"Factorial Recursion Tree","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 10</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to trace through recursive factorial calls, identify the base case and recursive case, and explain how the return values cascade...</li> </ul>"},{"location":"learning-graph/diagram-details/#fibonacci-tree-visualization","title":"Fibonacci Tree Visualization","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 13</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to trace Fibonacci recursion, identify redundant calculations in tree recursion, and compare the number of function calls for di...</li> </ul>"},{"location":"learning-graph/diagram-details/#higher-order-functions-flow","title":"Higher-Order Functions Flow","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 6</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to explain what makes a function \"higher-order\" and classify examples as higher-order or regular functions....</li> </ul>"},{"location":"learning-graph/diagram-details/#map-filter-reduce-pipeline","title":"Map Filter Reduce Pipeline","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 12</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to chain map, filter, and reduce operations on a list and predict the output at each stage....</li> </ul>"},{"location":"learning-graph/diagram-details/#recursion-vs-iteration-side-by-side","title":"Recursion vs Iteration Side-by-Side","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 19</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to compare recursive and iterative implementations of the same algorithm side by side, tracking execution steps, memory usage, a...</li> </ul>"},{"location":"learning-graph/diagram-details/#recursive-call-stack-visualizer","title":"Recursive Call Stack Visualizer","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 24</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to trace the call stack during recursive execution, identify when frames are pushed and popped, and determine the value of local...</li> </ul>"},{"location":"learning-graph/diagram-details/#chapter-8-lists","title":"Chapter 8: Lists","text":"<p>Total elements: 6</p>"},{"location":"learning-graph/diagram-details/#list-creation-visualizer","title":"List Creation Visualizer","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 5</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to create Python lists and visualize how items are stored in indexed positions....</li> </ul>"},{"location":"learning-graph/diagram-details/#list-indexing-and-slicing-explorer","title":"List Indexing and Slicing Explorer","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 4</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to use positive and negative indices to access specific list items and apply slice notation to extract sublists....</li> </ul>"},{"location":"learning-graph/diagram-details/#list-methods-playground","title":"List Methods Playground","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 8</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to apply common list methods (append, insert, remove, pop, sort, reverse) and predict the resulting list state....</li> </ul>"},{"location":"learning-graph/diagram-details/#list-traversal-animator","title":"List Traversal Animator","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 15</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to trace the execution of a for loop over a list and predict the output for each iteration....</li> </ul>"},{"location":"learning-graph/diagram-details/#nested-list-grid-visualizer","title":"Nested List Grid Visualizer","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 6</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to access elements in nested lists using double-index notation and interpret a list of lists as a 2D grid....</li> </ul>"},{"location":"learning-graph/diagram-details/#zip-function-visualizer","title":"Zip Function Visualizer","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 7</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to use the zip function to combine multiple lists element by element and predict the output of zip operations....</li> </ul>"},{"location":"learning-graph/diagram-details/#chapter-9-advanced-list-operations","title":"Chapter 9: Advanced List Operations","text":"<p>Total elements: 6</p>"},{"location":"learning-graph/diagram-details/#list-aliasing-visualizer","title":"List Aliasing Visualizer","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 7</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to explain the difference between creating an alias and creating an independent copy by observing how variable names point to ob...</li> </ul>"},{"location":"learning-graph/diagram-details/#list-operations-cheat-sheet","title":"List Operations Cheat Sheet","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 3</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to quickly recall the syntax and purpose of all advanced list operations covered in this chapter....</li> </ul>"},{"location":"learning-graph/diagram-details/#list-statistics-dashboard","title":"List Statistics Dashboard","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 6</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to use len, min, max, and sum to compute basic statistics on a list of numbers and interpret the results visually....</li> </ul>"},{"location":"learning-graph/diagram-details/#queue-simulator","title":"Queue Simulator","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 8</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to demonstrate FIFO (First In, First Out) behavior by enqueuing and dequeuing items and contrast it with stack (LIFO) behavior....</li> </ul>"},{"location":"learning-graph/diagram-details/#shallow-vs-deep-copy-visualizer","title":"Shallow vs Deep Copy Visualizer","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 9</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to distinguish between shallow and deep copying by observing how changes to nested elements propagate (or don't) in each type of...</li> </ul>"},{"location":"learning-graph/diagram-details/#stack-simulator","title":"Stack Simulator","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 10</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to demonstrate LIFO (Last In, First Out) behavior by pushing and popping items on a visual stack and predicting the next item to...</li> </ul>"},{"location":"learning-graph/diagram-details/#chapter-10-tuples-and-sets","title":"Chapter 10: Tuples And Sets","text":"<p>Total elements: 6</p>"},{"location":"learning-graph/diagram-details/#python-collections-overview","title":"Python Collections Overview","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 1</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to classify Python's four core collection types (list, tuple, set, frozenset) by their properties and select the appropriate typ...</li> </ul>"},{"location":"learning-graph/diagram-details/#removing-duplicates-visualizer","title":"Removing Duplicates Visualizer","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 9</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to use a set to remove duplicate values from a list by stepping through the conversion process and observing how duplicates are ...</li> </ul>"},{"location":"learning-graph/diagram-details/#tuple-and-set-concept-map","title":"Tuple and Set Concept Map","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 0</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to summarize the relationships between tuples, sets, frozensets, and lists by exploring a concept map that connects their shared...</li> </ul>"},{"location":"learning-graph/diagram-details/#tuple-vs-list-mutability","title":"Tuple vs List Mutability","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 5</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to explain the difference between mutable lists and immutable tuples by observing how modification operations succeed on lists b...</li> </ul>"},{"location":"learning-graph/diagram-details/#tuples-vs-lists-comparison","title":"Tuples vs Lists Comparison","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 2</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to choose between tuples and lists for a given scenario by comparing their properties and trade-offs....</li> </ul>"},{"location":"learning-graph/diagram-details/#venn-diagram-set-operations","title":"Venn Diagram Set Operations","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 4</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to compute union, intersection, difference, and symmetric difference of two sets by interacting with a Venn diagram and seeing t...</li> </ul>"},{"location":"learning-graph/diagram-details/#chapter-11-dictionaries","title":"Chapter 11: Dictionaries","text":"<p>Total elements: 6</p>"},{"location":"learning-graph/diagram-details/#counting-and-grouping-patterns","title":"Counting and Grouping Patterns","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 12</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to implement counting and grouping patterns by watching how a dictionary builds up step by step as data is processed....</li> </ul>"},{"location":"learning-graph/diagram-details/#dict-vs-list-lookup-performance","title":"Dict vs List Lookup Performance","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 5</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to compare the lookup performance of lists vs dictionaries and explain why dictionaries are faster for membership testing....</li> </ul>"},{"location":"learning-graph/diagram-details/#dictionary-iteration-flowchart","title":"Dictionary Iteration Flowchart","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 5</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to trace through different dictionary iteration patterns (keys, values, items) and predict the output at each step....</li> </ul>"},{"location":"learning-graph/diagram-details/#dictionary-structure-visualizer","title":"Dictionary Structure Visualizer","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 4</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to visualize how a Python dictionary stores key-value pairs and understand the mapping relationship between keys and values....</li> </ul>"},{"location":"learning-graph/diagram-details/#dictionary-use-cases-infographic","title":"Dictionary Use Cases Infographic","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 0</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to identify common real-world scenarios where dictionaries are the appropriate data structure and explain why....</li> </ul>"},{"location":"learning-graph/diagram-details/#nested-dictionary-explorer","title":"Nested Dictionary Explorer","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 7</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to navigate through nested dictionaries by clicking through levels of keys and constructing the bracket-chain notation needed to...</li> </ul>"},{"location":"learning-graph/diagram-details/#chapter-12-classes-and-objects","title":"Chapter 12: Classes And Objects","text":"<p>Total elements: 6</p>"},{"location":"learning-graph/diagram-details/#class-vs-object-visual","title":"Class vs. Object Visual","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 1</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to distinguish between a class (blueprint/template) and an object (instance) by seeing a visual analogy of a cookie cutter produ...</li> </ul>"},{"location":"learning-graph/diagram-details/#dog-class-complete-structure","title":"Dog Class Complete Structure","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 2</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to read a class diagram showing the structure of a Python class, identifying its attributes and methods....</li> </ul>"},{"location":"learning-graph/diagram-details/#encapsulation-bank-vault-analogy","title":"Encapsulation Bank Vault Analogy","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 0</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to explain how encapsulation protects an object's internal data by restricting direct access and using getter/setter methods as ...</li> </ul>"},{"location":"learning-graph/diagram-details/#instance-vs-class-attributes","title":"Instance vs. Class Attributes","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 1</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to differentiate between instance attributes (unique per object) and class attributes (shared across all objects) by viewing a m...</li> </ul>"},{"location":"learning-graph/diagram-details/#oop-benefits-concept-map","title":"OOP Benefits Concept Map","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 0</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to summarize the key benefits of OOP (organization, reusability, encapsulation, real-world modeling, teamwork) and explain why O...</li> </ul>"},{"location":"learning-graph/diagram-details/#object-interaction-playground","title":"Object Interaction Playground","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 4</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to create Dog objects, call methods, and observe results in an interactive playground that demonstrates class instantiation, met...</li> </ul>"},{"location":"learning-graph/diagram-details/#chapter-13-inheritance-and-polymorphism","title":"Chapter 13: Inheritance And Polymorphism","text":"<p>Total elements: 6</p>"},{"location":"learning-graph/diagram-details/#animal-class-hierarchy","title":"Animal Class Hierarchy","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 4</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to trace inheritance relationships in a class hierarchy and identify which attributes and methods each class inherits versus def...</li> </ul>"},{"location":"learning-graph/diagram-details/#dunder-methods-cheat-sheet","title":"Dunder Methods Cheat Sheet","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 2</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to identify common dunder methods, the operators they map to, and the purpose of each....</li> </ul>"},{"location":"learning-graph/diagram-details/#music-library-class-diagram","title":"Music Library Class Diagram","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 0</li> <li>Difficulty: Easy</li> <li>Learning Objective: Students will be able to analyze a multi-class system and identify inheritance, composition, abstract methods, operator overloading, and the iterator ...</li> </ul>"},{"location":"learning-graph/diagram-details/#polymorphism-playground","title":"Polymorphism Playground","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 12</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to demonstrate polymorphism by selecting different animal types, calling the same method on each, and observing different behavi...</li> </ul>"},{"location":"learning-graph/diagram-details/#shape-hierarchy-with-abstract-base-class","title":"Shape Hierarchy with Abstract Base Class","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 3</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to identify abstract classes and understand why they cannot be instantiated directly, by interacting with a visual hierarchy tha...</li> </ul>"},{"location":"learning-graph/diagram-details/#uml-class-diagram-builder","title":"UML Class Diagram Builder","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 7</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to read and construct UML class diagrams that show inheritance and composition relationships between classes....</li> </ul>"},{"location":"learning-graph/diagram-details/#chapter-14-errors-and-exceptions","title":"Chapter 14: Errors And Exceptions","text":"<p>Total elements: 3</p>"},{"location":"learning-graph/diagram-details/#error-type-identifier","title":"Error Type Identifier","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 2</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to compare and contrast syntax errors, runtime errors, and logic errors by identifying when each occurs, how Python reports them...</li> </ul>"},{"location":"learning-graph/diagram-details/#python-exception-hierarchy","title":"Python Exception Hierarchy","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 11</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to construct try-except blocks by dragging code statements into the correct positions within a try-except structure....</li> </ul>"},{"location":"learning-graph/diagram-details/#try-except-finally-flow-chart","title":"Try-Except-Finally Flow Chart","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 10</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to predict the output of Python code containing try-except-else-finally blocks with various exception scenarios by tracing throu...</li> </ul>"},{"location":"learning-graph/diagram-details/#chapter-15-file-input-and-output","title":"Chapter 15: File Input And Output","text":"<p>Total elements: 6</p>"},{"location":"learning-graph/diagram-details/#csv-file-structure","title":"CSV File Structure","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 8</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to interpret the structure of a CSV file by mapping raw comma-separated text to a table representation and back....</li> </ul>"},{"location":"learning-graph/diagram-details/#file-format-decision-tree","title":"File Format Decision Tree","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 2</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to choose the appropriate file format (plain text, CSV, or JSON) for a given data storage scenario and justify their choice....</li> </ul>"},{"location":"learning-graph/diagram-details/#file-io-flow","title":"File I/O Flow","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 5</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to describe the sequence of operations in a file I/O workflow: open, read/write, and close....</li> </ul>"},{"location":"learning-graph/diagram-details/#json-to-dictionary-mapping","title":"JSON to Dictionary Mapping","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 6</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to convert between JSON text and Python dictionary representations by editing one view and seeing the other update automatically...</li> </ul>"},{"location":"learning-graph/diagram-details/#read-methods-comparison","title":"Read Methods Comparison","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 7</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to compare the behavior of <code>read()</code>, <code>readline()</code>, and <code>readlines()</code> and predict the output of each method for a given file....</li> </ul>"},{"location":"learning-graph/diagram-details/#with-statement-vs-manual-close","title":"With Statement vs Manual Close","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 6</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to explain why the <code>with</code> statement is safer than manual <code>open()</code>/<code>close()</code> by observing what happens when an error occurs durin...</li> </ul>"},{"location":"learning-graph/diagram-details/#chapter-16-software-engineering","title":"Chapter 16: Software Engineering","text":"<p>Total elements: 3</p>"},{"location":"learning-graph/diagram-details/#comment-quality-checker","title":"Comment Quality Checker","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 7</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to predict which code blocks execute when a Python file is run directly versus when it is imported as a module....</li> </ul>"},{"location":"learning-graph/diagram-details/#git-workflow-visualizer","title":"Git Workflow Visualizer","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 2</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to identify code that violates the DRY principle and explain how to refactor it using functions....</li> </ul>"},{"location":"learning-graph/diagram-details/#software-development-lifecycle","title":"Software Development Lifecycle","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 4</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to distinguish between Python modules and packages, and explain how import statements connect them....</li> </ul>"},{"location":"learning-graph/diagram-details/#chapter-17-testing-and-debugging","title":"Chapter 17: Testing And Debugging","text":"<p>Total elements: 3</p>"},{"location":"learning-graph/diagram-details/#tdd-cycle","title":"TDD Cycle","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 9</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to use breakpoints and step-through controls to trace the execution of a Python function and identify where a bug occurs....</li> </ul>"},{"location":"learning-graph/diagram-details/#unit-test-runner","title":"Unit Test Runner","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 4</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to identify boundary values for a given function specification and predict whether each test input will pass or fail....</li> </ul>"},{"location":"learning-graph/diagram-details/#which-debugging-strategy-should-you-use","title":"Which Debugging Strategy Should You Use?","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 12</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to write and test input validation rules for common data types (age, email, password) and predict which inputs will pass or fail...</li> </ul>"},{"location":"learning-graph/diagram-details/#chapter-18-searching-and-sorting","title":"Chapter 18: Searching And Sorting","text":"<p>Total elements: 3</p>"},{"location":"learning-graph/diagram-details/#big-o-growth-rate-chart","title":"Big-O Growth Rate Chart","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 2</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to select an appropriate search or sort algorithm for a given scenario and justify their choice based on input characteristics a...</li> </ul>"},{"location":"learning-graph/diagram-details/#binary-search-step-by-step","title":"Binary Search Step-by-Step","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 8</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to compare the performance of selection sort, insertion sort, and merge sort by watching them sort identical arrays side by side...</li> </ul>"},{"location":"learning-graph/diagram-details/#linear-search-flowchart","title":"Linear Search Flowchart","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 10</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to execute a linear search on a given array by stepping through the algorithm and predicting whether each element matches the ta...</li> </ul>"},{"location":"learning-graph/diagram-details/#chapter-19-algorithm-analysis","title":"Chapter 19: Algorithm Analysis","text":"<p>Total elements: 3</p>"},{"location":"learning-graph/diagram-details/#chapters19-algorithm-analysisindexmddiagram-","title":"[<code>](../chapters/19-algorithm-analysis/index.md#diagram-</code>)","text":"<ul> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 0</li> <li>Difficulty: Medium</li> </ul>"},{"location":"learning-graph/diagram-details/#complexity-class-name-example-operations-for-n-1000","title":"| Complexity Class | Name | Example | Operations for ( n = 1{,}000 ) |","text":"<ul> <li>Type: Diagram</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 0</li> <li>Difficulty: Easy</li> </ul>"},{"location":"learning-graph/diagram-details/#strategy-approach-when-to-use-guarantee","title":"| Strategy | Approach | When to Use | Guarantee |","text":"<ul> <li>Type: Diagram</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 0</li> <li>Difficulty: Easy</li> </ul>"},{"location":"learning-graph/diagram-details/#chapter-20-advanced-python","title":"Chapter 20: Advanced Python","text":"<p>Total elements: 6</p>"},{"location":"learning-graph/diagram-details/#collections-module-overview","title":"Collections Module Overview","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 3</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to identify the four main collections module classes (Counter, defaultdict, OrderedDict, namedtuple) and describe when to use ea...</li> </ul>"},{"location":"learning-graph/diagram-details/#context-manager-flow","title":"Context Manager Flow","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 5</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to trace the execution flow of a context manager, identifying when enter and exit are called....</li> </ul>"},{"location":"learning-graph/diagram-details/#generator-vs-list-memory","title":"Generator vs List Memory","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 9</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to compare memory usage between lists and generators by observing a visual representation of how each stores data....</li> </ul>"},{"location":"learning-graph/diagram-details/#how-decorators-work","title":"How Decorators Work","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 5</li> <li>Difficulty: Medium</li> <li>Learning Objective: Students will be able to trace how a decorator wraps a function by watching an animated flow diagram of the decoration process....</li> </ul>"},{"location":"learning-graph/diagram-details/#python-best-practices-checklist","title":"Python Best Practices Checklist","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 8</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to evaluate Python code snippets against best practices and identify areas for improvement....</li> </ul>"},{"location":"learning-graph/diagram-details/#regex-pattern-tester","title":"Regex Pattern Tester","text":"<ul> <li>Status: Specified</li> <li>Type: Microsim</li> <li>Bloom's Taxonomy: Not specified</li> <li>UI Elements: 7</li> <li>Difficulty: Hard</li> <li>Learning Objective: Students will be able to write and test simple regular expressions by entering patterns and seeing matches highlighted in real time....</li> </ul>"},{"location":"learning-graph/diagram-table/","title":"Diagram Table","text":""},{"location":"learning-graph/diagram-table/#diagram-and-microsim-table","title":"Diagram and MicroSim Table","text":"<p>Total Visual Elements: 104 Diagrams: 2 MicroSims: 102</p>"},{"location":"learning-graph/diagram-table/#summary-by-difficulty","title":"Summary by Difficulty","text":"<ul> <li>Easy: 3</li> <li>Medium: 49</li> <li>Hard: 51</li> <li>Very Hard: 1</li> </ul>"},{"location":"learning-graph/diagram-table/#all-visual-elements","title":"All Visual Elements","text":"Chapter Element Title Status Type Bloom Levels UI Elements Difficulty Recommended MicroSims 1 ASCII Character Map Specified Microsim Not specified 2 Medium 1 Binary Number Explorer Specified Microsim Not specified 12 Hard 1 Compiled vs. Interpreted Languages Specified Microsim Not specified 6 Hard 1 Computational Thinking Pillars Specified Microsim Not specified 3 Medium 1 Inside a Computer Specified Microsim Not specified 6 Medium 2 Arithmetic Operators Explorer Specified Microsim Not specified 8 Hard 2 Code Readability Comparison Specified Microsim Not specified 6 Hard 2 Expressions vs. Statements Specified Microsim Not specified 2 Medium 2 Python Data Types Overview Specified Microsim Not specified 2 Medium 2 Python REPL vs. Scripts Specified Microsim Not specified 5 Hard 2 String Operations Playground Specified Microsim Not specified 11 Hard 3 Comparison Operator Explorer Specified Microsim Not specified 14 Hard 3 De Morgan's Laws Visualizer Specified Microsim Not specified 11 Very Hard 3 Interactive Truth Table Builder Specified Microsim Not specified 10 Medium 3 Logical Operator Venn Diagrams Specified Microsim Not specified 5 Medium 3 Order of Operations Visualizer Specified Microsim Not specified 10 Hard 3 Truthiness Tester Specified Microsim Not specified 4 Medium 4 Break vs Continue Visualizer Specified Microsim Not specified 5 Hard 4 Control Flow Patterns Specified Microsim Not specified 8 Hard 4 If-Elif-Else Flowchart Specified Microsim Not specified 6 Medium 4 Loop Patterns Comparison Specified Microsim Not specified 5 Hard 4 Nested Loop Grid Visualizer Specified Microsim Not specified 8 Hard 4 Range Function Explorer Specified Microsim Not specified 8 Hard 5 Palindrome Checker Specified Microsim Not specified 2 Medium 5 Split and Join Visualizer Specified Microsim Not specified 11 Hard 5 String Formatting Comparison Specified Microsim Not specified 5 Hard 5 String Indexing Visualizer Specified Microsim Not specified 7 Hard 5 String Methods Explorer Specified Microsim Not specified 14 Hard 5 String Slicing Playground Specified Microsim Not specified 16 Hard 6 Arguments vs Parameters Specified Microsim Not specified 1 Hard 6 Function Anatomy Specified Microsim Not specified 4 Medium 6 Function Call Flow Specified Microsim Not specified 10 Hard 6 Function Pattern Gallery Specified Microsim Not specified 2 Medium 6 Modular Design Builder Specified Microsim Not specified 9 Hard 6 Variable Scope Visualizer Specified Microsim Not specified 11 Hard 7 Factorial Recursion Tree Specified Microsim Not specified 10 Hard 7 Fibonacci Tree Visualization Specified Microsim Not specified 13 Hard 7 Higher-Order Functions Flow Specified Microsim Not specified 6 Medium 7 Map Filter Reduce Pipeline Specified Microsim Not specified 12 Hard 7 Recursion vs Iteration Side-by-Side Specified Microsim Not specified 19 Hard 7 Recursive Call Stack Visualizer Specified Microsim Not specified 24 Hard 8 List Creation Visualizer Specified Microsim Not specified 5 Medium 8 List Indexing and Slicing Explorer Specified Microsim Not specified 4 Medium 8 List Methods Playground Specified Microsim Not specified 8 Hard 8 List Traversal Animator Specified Microsim Not specified 15 Hard 8 Nested List Grid Visualizer Specified Microsim Not specified 6 Medium 8 Zip Function Visualizer Specified Microsim Not specified 7 Hard 9 List Aliasing Visualizer Specified Microsim Not specified 7 Hard 9 List Operations Cheat Sheet Specified Microsim Not specified 3 Medium 9 List Statistics Dashboard Specified Microsim Not specified 6 Hard 9 Queue Simulator Specified Microsim Not specified 8 Hard 9 Shallow vs Deep Copy Visualizer Specified Microsim Not specified 9 Hard 9 Stack Simulator Specified Microsim Not specified 10 Medium 10 Python Collections Overview Specified Microsim Not specified 1 Medium 10 Removing Duplicates Visualizer Specified Microsim Not specified 9 Hard 10 Tuple and Set Concept Map Specified Microsim Not specified 0 Medium 10 Tuple vs List Mutability Specified Microsim Not specified 5 Hard 10 Tuples vs Lists Comparison Specified Microsim Not specified 2 Hard 10 Venn Diagram Set Operations Specified Microsim Not specified 4 Medium 11 Counting and Grouping Patterns Specified Microsim Not specified 12 Hard 11 Dict vs List Lookup Performance Specified Microsim Not specified 5 Hard 11 Dictionary Iteration Flowchart Specified Microsim Not specified 5 Medium 11 Dictionary Structure Visualizer Specified Microsim Not specified 4 Medium 11 Dictionary Use Cases Infographic Specified Microsim Not specified 0 Medium 11 Nested Dictionary Explorer Specified Microsim Not specified 7 Medium 12 Class vs. Object Visual Specified Microsim Not specified 1 Medium 12 Dog Class Complete Structure Specified Microsim Not specified 2 Medium 12 Encapsulation Bank Vault Analogy Specified Microsim Not specified 0 Medium 12 Instance vs. Class Attributes Specified Microsim Not specified 1 Medium 12 OOP Benefits Concept Map Specified Microsim Not specified 0 Medium 12 Object Interaction Playground Specified Microsim Not specified 4 Medium 13 Animal Class Hierarchy Specified Microsim Not specified 4 Medium 13 Dunder Methods Cheat Sheet Specified Microsim Not specified 2 Medium 13 Music Library Class Diagram Specified Microsim Not specified 0 Easy 13 Polymorphism Playground Specified Microsim Not specified 12 Medium 13 Shape Hierarchy with Abstract Base Class Specified Microsim Not specified 3 Medium 13 UML Class Diagram Builder Specified Microsim Not specified 7 Hard 14 Error Type Identifier Specified Microsim Not specified 2 Hard 14 Python Exception Hierarchy Specified Microsim Not specified 11 Medium 14 Try-Except-Finally Flow Chart Specified Microsim Not specified 10 Hard 15 CSV File Structure Specified Microsim Not specified 8 Hard 15 File Format Decision Tree Specified Microsim Not specified 2 Medium 15 File I/O Flow Specified Microsim Not specified 5 Medium 15 JSON to Dictionary Mapping Specified Microsim Not specified 6 Medium 15 Read Methods Comparison Specified Microsim Not specified 7 Hard 15 With Statement vs Manual Close Specified Microsim Not specified 6 Medium 16 Comment Quality Checker Specified Microsim Not specified 7 Hard 16 Git Workflow Visualizer Specified Microsim Not specified 2 Hard 16 Software Development Lifecycle Specified Microsim Not specified 4 Medium 17 TDD Cycle Specified Microsim Not specified 9 Medium 17 Unit Test Runner Specified Microsim Not specified 4 Medium 17 Which Debugging Strategy Should You Use? Specified Microsim Not specified 12 Medium 18 Big-O Growth Rate Chart Specified Microsim Not specified 2 Medium 18 Binary Search Step-by-Step Specified Microsim Not specified 8 Hard 18 Linear Search Flowchart Specified Microsim Not specified 10 Hard 19 [<code>](../chapters/19-algorithm-analysis/index.md#diagram-</code>) Microsim Not specified 0 Medium 19 [ Complexity Class Name Example Operations for ( n = 1{,}000 ) ](../chapters/19-algorithm-analysis/index.md#diagram- -complexity-class- 19 [ Strategy Approach When to Use Guarantee ](../chapters/19-algorithm-analysis/index.md#diagram- -strategy- 20 Collections Module Overview Specified Microsim Not specified 3 Medium 20 Context Manager Flow Specified Microsim Not specified 5 Medium 20 Generator vs List Memory Specified Microsim Not specified 9 Hard 20 How Decorators Work Specified Microsim Not specified 5 Medium 20 Python Best Practices Checklist Specified Microsim Not specified 8 Hard 20 Regex Pattern Tester Specified Microsim Not specified 7 Hard"},{"location":"learning-graph/faq-coverage-gaps/","title":"FAQ Coverage Gaps","text":""},{"location":"learning-graph/faq-coverage-gaps/#faq-coverage-gaps","title":"FAQ Coverage Gaps","text":"<p>Concepts from the learning graph not currently covered in the FAQ.</p>"},{"location":"learning-graph/faq-coverage-gaps/#critical-gaps-high-priority","title":"Critical Gaps (High Priority)","text":"<ol> <li>Time Complexity</li> <li>Centrality: High (12 dependent concepts)</li> <li>Suggested Question: \"What is Time Complexity and why is it important?\"</li> <li>File Input Output</li> <li>Centrality: High (7 dependent concepts)</li> <li>Suggested Question: \"What is File Input Output and why is it important?\"</li> <li>Python Modules</li> <li>Centrality: High (7 dependent concepts)</li> <li>Suggested Question: \"What is Python Modules and why is it important?\"</li> <li>Class Definition</li> <li>Centrality: High (5 dependent concepts)</li> <li>Suggested Question: \"What is Class Definition and why is it important?\"</li> <li>Dunder Methods</li> <li>Centrality: High (5 dependent concepts)</li> <li>Suggested Question: \"What is Dunder Methods and why is it important?\"</li> <li>Exception Types</li> <li>Centrality: High (5 dependent concepts)</li> <li>Suggested Question: \"What is Exception Types and why is it important?\"</li> <li>Unit Testing</li> <li>Centrality: High (5 dependent concepts)</li> <li>Suggested Question: \"What is Unit Testing and why is it important?\"</li> <li>Opening Files</li> <li>Centrality: High (4 dependent concepts)</li> <li>Suggested Question: \"What is Opening Files and why is it important?\"</li> <li>Try-Except Block</li> <li>Centrality: High (4 dependent concepts)</li> <li>Suggested Question: \"What is Try-Except Block and why is it important?\"</li> <li>Merge Sort</li> <li>Centrality: High (4 dependent concepts)</li> <li>Suggested Question: \"What is Merge Sort and why is it important?\"</li> <li>Collections Module</li> <li>Centrality: High (4 dependent concepts)</li> <li>Suggested Question: \"What is Collections Module and why is it important?\"</li> <li>Child Class</li> <li>Centrality: High (3 dependent concepts)</li> <li>Suggested Question: \"What is Child Class and why is it important?\"</li> <li>Modular Design</li> <li>Centrality: High (3 dependent concepts)</li> <li>Suggested Question: \"What is Modular Design and why is it important?\"</li> <li>Generators</li> <li>Centrality: High (3 dependent concepts)</li> <li>Suggested Question: \"What is Generators and why is it important?\"</li> </ol>"},{"location":"learning-graph/faq-coverage-gaps/#medium-priority-gaps","title":"Medium Priority Gaps","text":"<ol> <li>Private Attributes</li> <li>Centrality: Medium (2 dependent concepts)</li> <li>Operator Overloading</li> <li>Centrality: Medium (2 dependent concepts)</li> <li>Iterator Protocol</li> <li>Centrality: Medium (2 dependent concepts)</li> <li>Read Method</li> <li>Centrality: Medium (2 dependent concepts)</li> <li>Debugger Tools</li> <li>Centrality: Medium (2 dependent concepts)</li> <li>Selection Sort</li> <li>Centrality: Medium (2 dependent concepts)</li> <li>Insertion Sort</li> <li>Centrality: Medium (2 dependent concepts)</li> <li>Space Complexity</li> <li>Centrality: Medium (2 dependent concepts)</li> <li>Software Development</li> <li>Centrality: Medium (2 dependent concepts)</li> <li>Code Organization</li> <li>Centrality: Medium (2 dependent concepts)</li> <li>PEP 8 Guidelines</li> <li>Centrality: Medium (2 dependent concepts)</li> <li>Class Instantiation</li> <li>Centrality: Medium (1 dependent concepts)</li> <li>Instance Attributes</li> <li>Centrality: Medium (1 dependent concepts)</li> <li>Class Attributes</li> <li>Centrality: Medium (1 dependent concepts)</li> <li>The Self Parameter</li> <li>Centrality: Medium (1 dependent concepts)</li> <li>Init Method</li> <li>Centrality: Medium (1 dependent concepts)</li> <li>Getter Methods</li> <li>Centrality: Medium (1 dependent concepts)</li> <li>Setter Methods</li> <li>Centrality: Medium (1 dependent concepts)</li> <li>Parent Class</li> <li>Centrality: Medium (1 dependent concepts)</li> <li>Method Overriding</li> <li>Centrality: Medium (1 dependent concepts)</li> <li>Multiple Inheritance</li> <li>Centrality: Medium (1 dependent concepts)</li> <li>Eq and Lt Methods</li> <li>Centrality: Medium (1 dependent concepts)</li> <li>Iterable Protocol</li> <li>Centrality: Medium (1 dependent concepts)</li> <li>Write Method</li> <li>Centrality: Medium (1 dependent concepts)</li> <li>JSON Files</li> <li>Centrality: Medium (1 dependent concepts)</li> </ol>"},{"location":"learning-graph/faq-coverage-gaps/#low-priority-gaps","title":"Low Priority Gaps","text":"<ol> <li>Counter Class</li> <li>Centrality: Low (leaf or niche concept)</li> <li>Constructor</li> <li>Centrality: Low (leaf or niche concept)</li> <li>Instance Methods</li> <li>Centrality: Low (leaf or niche concept)</li> <li>Str Method</li> <li>Centrality: Low (leaf or niche concept)</li> <li>Repr Method</li> <li>Centrality: Low (leaf or niche concept)</li> <li>Property Decorator</li> <li>Centrality: Low (leaf or niche concept)</li> <li>Class Methods</li> <li>Centrality: Low (leaf or niche concept)</li> <li>Static Methods</li> <li>Centrality: Low (leaf or niche concept)</li> <li>Has-A Relationship</li> <li>Centrality: Low (leaf or niche concept)</li> <li>Is-A Relationship</li> <li>Centrality: Low (leaf or niche concept)</li> <li>Super Function</li> <li>Centrality: Low (leaf or niche concept)</li> <li>Duck Typing</li> <li>Centrality: Low (leaf or niche concept)</li> <li>Abstract Classes</li> <li>Centrality: Low (leaf or niche concept)</li> <li>Method Resolution Order</li> <li>Centrality: Low (leaf or niche concept)</li> <li>Add and Mul Methods</li> <li>Centrality: Low (leaf or niche concept)</li> <li>Object Identity</li> <li>Centrality: Low (leaf or niche concept)</li> <li>Object Comparison</li> <li>Centrality: Low (leaf or niche concept)</li> <li>Class Hierarchies</li> <li>Centrality: Low (leaf or niche concept)</li> <li>UML Class Diagrams</li> <li>Centrality: Low (leaf or niche concept)</li> <li>Design Patterns Intro</li> <li>Centrality: Low (leaf or niche concept)</li> <li>File Modes</li> <li>Centrality: Low (leaf or niche concept)</li> <li>Readline Method</li> <li>Centrality: Low (leaf or niche concept)</li> <li>Readlines Method</li> <li>Centrality: Low (leaf or niche concept)</li> <li>Writelines Method</li> <li>Centrality: Low (leaf or niche concept)</li> <li>With Statement</li> <li>Centrality: Low (leaf or niche concept)</li> </ol>"},{"location":"learning-graph/faq-coverage-gaps/#recommendations","title":"Recommendations","text":"<ol> <li>Add questions for all critical gaps (14 concepts).</li> <li>Add medium-priority coverage next (25 concepts).</li> <li>Leave low-priority concepts for iterative FAQ updates (25 concepts).</li> </ol>"},{"location":"learning-graph/faq-quality-report/","title":"FAQ Quality Report","text":""},{"location":"learning-graph/faq-quality-report/#faq-quality-report","title":"FAQ Quality Report","text":"<p>Generated: 2026-02-11</p>"},{"location":"learning-graph/faq-quality-report/#overall-statistics","title":"Overall Statistics","text":"<ul> <li>Total Questions: 45</li> <li>Overall Quality Score: 83/100</li> <li>Content Completeness Score: 95/100</li> <li>Concept Coverage: 63.2% (253/400 concepts)</li> </ul>"},{"location":"learning-graph/faq-quality-report/#category-breakdown","title":"Category Breakdown","text":""},{"location":"learning-graph/faq-quality-report/#getting-started","title":"Getting Started","text":"<ul> <li>Questions: 8</li> <li>Avg Word Count: 69</li> </ul>"},{"location":"learning-graph/faq-quality-report/#core-concept","title":"Core Concept","text":"<ul> <li>Questions: 10</li> <li>Avg Word Count: 72.6</li> </ul>"},{"location":"learning-graph/faq-quality-report/#technical-detail","title":"Technical Detail","text":"<ul> <li>Questions: 10</li> <li>Avg Word Count: 117.8</li> </ul>"},{"location":"learning-graph/faq-quality-report/#common-challenges","title":"Common Challenges","text":"<ul> <li>Questions: 6</li> <li>Avg Word Count: 70.3</li> </ul>"},{"location":"learning-graph/faq-quality-report/#best-practice","title":"Best Practice","text":"<ul> <li>Questions: 6</li> <li>Avg Word Count: 70.7</li> </ul>"},{"location":"learning-graph/faq-quality-report/#advanced-topics","title":"Advanced Topics","text":"<ul> <li>Questions: 5</li> <li>Avg Word Count: 72.4</li> </ul>"},{"location":"learning-graph/faq-quality-report/#blooms-taxonomy-distribution","title":"Bloom's Taxonomy Distribution","text":"Level Actual Target Deviation Remember 22.2% 20% 2.2% Understand 31.1% 30% 1.1% Apply 22.2% 25% -2.8% Analyze 17.8% 15% 2.8% Evaluate 4.4% 7% -2.6% Create 2.2% 3% -0.8% <p>Bloom Distribution Score: 20/25</p>"},{"location":"learning-graph/faq-quality-report/#answer-quality-analysis","title":"Answer Quality Analysis","text":"<ul> <li>Examples: 37/45 (82.2%)</li> <li>Answers With Source Links: 45/45 (100.0%)</li> <li>Average Length: 81.4 words</li> <li>Duplicate Questions: 0 detected</li> <li>Anchor Links: 0 detected</li> </ul> <p>Answer Quality Score: 23/25</p>"},{"location":"learning-graph/faq-quality-report/#organization-quality","title":"Organization Quality","text":"<ul> <li>Logical categorization: Yes</li> <li>Progressive difficulty: Yes</li> <li>No duplicates: Yes</li> <li>Clear questions: Yes</li> </ul> <p>Organization Score: 20/20</p>"},{"location":"learning-graph/faq-quality-report/#overall-quality-score-83100","title":"Overall Quality Score: 83/100","text":"<ul> <li>Coverage: 20/30</li> <li>Bloom Distribution: 20/25</li> <li>Answer Quality: 23/25</li> <li>Organization: 20/20</li> </ul>"},{"location":"learning-graph/faq-quality-report/#recommendations","title":"Recommendations","text":""},{"location":"learning-graph/faq-quality-report/#high-priority","title":"High Priority","text":"<ol> <li>Add FAQ entries for the top uncovered high-centrality concepts (14 identified).</li> <li>Expand advanced answers with more scenario-based examples.</li> </ol>"},{"location":"learning-graph/faq-quality-report/#medium-priority","title":"Medium Priority","text":"<ol> <li>Increase cross-linking among related chapters.</li> <li>Add more troubleshooting questions for runtime and data issues.</li> </ol>"},{"location":"learning-graph/faq-quality-report/#low-priority","title":"Low Priority","text":"<ol> <li>Add enrichment entries for niche advanced Python topics.</li> </ol>"},{"location":"learning-graph/glossary-quality-report/","title":"Glossary Quality Report","text":""},{"location":"learning-graph/glossary-quality-report/#glossary-quality-report","title":"Glossary Quality Report","text":""},{"location":"learning-graph/glossary-quality-report/#iso-11179-compliance-metrics","title":"ISO 11179 Compliance Metrics","text":"Term Precision Conciseness Distinctiveness Non-circularity Total Abstract Classes 25 10 23 25 83 Abstraction 25 15 23 25 88 Accumulator Pattern 25 10 23 25 83 Add and Mul Methods 25 10 23 25 83 Algorithm Correctness 25 10 23 25 83 Algorithm Design 25 10 23 25 83 Algorithm Tradeoffs 25 10 23 25 83 Algorithm Visualization 25 10 23 25 83 Algorithms 25 15 23 25 88 And Operator 25 10 23 25 83 Append Method 25 10 23 25 83 Args and Kwargs 25 10 23 25 83 Arguments 25 10 23 25 83 Arithmetic Operators 25 10 23 25 83 ASCII and Unicode 25 15 23 25 88 Assert Statements 25 10 23 25 83 Assertions 25 10 23 25 83 Augmented Assignment 25 10 23 25 83 Base Case 25 10 23 25 83 Best Average Worst Case 25 10 23 25 83 Big-O Notation 25 10 23 25 83 Binary Number System 25 15 23 25 88 Binary Search 25 10 23 25 83 Bits and Bytes 25 25 23 25 98 Boolean Conversion 25 10 23 25 83 Boolean Expressions 25 10 23 25 83 Boolean Type 25 10 23 25 83 Boundary Testing 25 10 23 25 83 Break Statement 25 10 23 25 83 Breakpoints 25 10 23 25 83 Brute Force Approach 25 10 23 25 83 Chained Comparisons 25 10 23 25 83 Character Encoding 25 15 23 25 88 Character Methods 25 10 23 25 83 Child Class 25 10 23 25 83 Class Attributes 25 10 23 25 83 Class Definition 25 10 23 25 83 Class Hierarchies 25 10 23 25 83 Class Instantiation 25 10 23 25 83 Class Methods 25 10 23 25 83 Classes 25 10 23 25 83 Closures 25 10 23 25 83 Code Comments 25 10 23 25 83 Code Organization 25 10 23 25 83 Code Readability 25 15 23 25 88 Code Review 25 10 23 25 83 Code Style 25 10 23 25 83 Code Tracing 25 10 23 25 83 Collections Module 25 10 23 25 83 Comments in Code 25 10 23 25 83 Comparison Operators 25 10 23 25 83 Compiled vs Interpreted 25 25 23 25 98 Composition 25 10 23 25 83 Comprehension Patterns 25 10 23 25 83 Computational Thinking 25 25 23 25 98 Computer Hardware 25 15 23 25 88 Computer Science 25 25 23 25 98 Conditional Statements 25 10 23 25 83 Constant Time O(1) 25 10 23 25 83 Constants Convention 25 10 23 25 83 Constructor 25 10 23 25 83 Context Manager Protocol 25 10 23 25 83 Context Managers 25 10 23 25 83 Continue Statement 25 10 23 25 83 Control Flow 25 10 23 25 83 Count Method 25 10 23 25 83 Counter Class 25 10 23 25 83 Counter Pattern 25 10 23 25 83 Counting Operations 25 10 23 25 83 Counting with Dicts 25 10 23 25 83 CPU and Memory 25 10 23 25 83 CSV Files 25 10 23 25 83 Custom Exceptions 25 10 23 25 83 Data Types 25 10 23 25 83 Dataclasses 25 10 23 25 83 De Morgan's Laws 25 10 23 25 83 Debugger Tools 25 10 23 25 83 Debugging 25 10 23 25 83 Decomposition 25 10 23 25 83 Decorators 25 10 23 25 83 Deep Copy 25 10 23 25 83 Default Parameters 25 10 23 25 83 Default Values 25 10 23 25 83 DefaultDict 25 10 23 25 83 Defensive Programming 25 10 23 25 83 Design Patterns Intro 25 10 23 25 83 Dict vs List Lookup 25 10 23 25 83 Dictionaries 25 10 23 25 83 Dictionary Access 25 15 23 25 88 Dictionary as Cache 25 10 23 25 83 Dictionary Comprehension 25 10 23 25 83 Dictionary Creation 25 15 23 25 88 Dictionary Iteration 25 10 23 25 83 Dictionary Merging 25 10 23 25 83 Dictionary Methods 25 10 23 25 83 Divide and Conquer 25 10 23 25 83 Docstrings 25 10 23 25 83 Documentation 25 10 23 25 83 DRY Principle 25 10 23 25 83 Duck Typing 25 15 23 25 88 Dunder Methods 25 10 23 25 83 Edge Cases 25 10 23 25 83 Efficiency vs Readability 25 10 23 25 83 Elif Statement 25 10 23 25 83 Empirical Analysis 25 10 23 25 83 Encapsulation 25 15 23 25 88 Enum Type 25 10 23 25 83 Enumerate Function 25 10 23 25 83 Eq and Lt Methods 25 10 23 25 83 Equal and Not Equal 25 10 23 25 83 Errors and Exceptions 25 15 23 25 88 Escape Characters 25 15 23 25 88 Exception Types 25 10 23 25 83 Explicit Type Casting 25 15 23 25 88 Expressions 25 10 23 25 83 F-String Formatting 25 10 23 25 83 File Exceptions 25 10 23 25 83 File Input Output 25 10 23 25 83 File Modes 25 10 23 25 83 File Paths 25 10 23 25 83 Filter Function 25 10 23 25 83 Finally Block 25 10 23 25 83 Find and Replace Methods 25 10 23 25 83 Flag Variable Pattern 25 15 23 25 88 Float Type 25 10 23 25 83 Flowcharts 25 10 23 25 83 For Loop 25 15 23 25 88 For Loop with Lists 25 15 23 25 88 Format Method 25 10 23 25 83 Frequency Counter Pattern 25 10 23 25 83 Frozenset 25 15 23 25 88 Function Call 25 10 23 25 83 Function Composition 25 10 23 25 83 Function Definition 25 10 23 25 83 Function Documentation 25 10 23 25 83 Functions 25 10 23 25 83 Functools Module 25 10 23 25 83 Generator Expressions 25 10 23 25 83 Generators 25 10 23 25 83 Get Method 25 15 23 25 88 Getter Methods 25 10 23 25 83 Git Basics 25 10 23 25 83 Global Keyword 25 10 23 25 83 Global Variables 25 10 23 25 83 Greater and Less Than 25 10 23 25 83 Greedy Algorithms 25 10 23 25 83 Grouping with Dicts 25 10 23 25 83 Has-A Relationship 25 10 23 25 83 Hashable Keys 25 10 23 25 83 Helper Functions 25 10 23 25 83 Higher-Order Functions 25 10 23 25 83 Identity vs Equality 25 15 23 25 88 If Statement 25 10 23 25 83 If-Else Statement 25 10 23 25 83 Implicit Type Conversion 25 10 23 25 83 Import Statements 25 10 23 25 83 In Operator for Lists 25 10 23 25 83 In Operator for Strings 25 10 23 25 83 Index Method 25 10 23 25 83 IndexError 25 15 23 25 88 Infinite Loops 25 10 23 25 83 Inheritance 25 15 23 25 88 Init Method 25 10 23 25 83 Input and Output Devices 25 15 23 25 88 Input Function 25 15 23 25 88 Input Validation 25 10 23 25 83 Insert Method 25 10 23 25 83 Insertion Sort 25 10 23 25 83 Instance Attributes 25 10 23 25 83 Instance Methods 25 10 23 25 83 Integer Division 25 10 23 25 83 Integer Type 25 10 23 25 83 Is-A Relationship 25 10 23 25 83 Items Method 25 10 23 25 83 Iterable Protocol 25 10 23 25 83 Iterator Protocol 25 10 23 25 83 Itertools Module 25 10 23 25 83 Join Method 25 15 23 25 88 JSON and Dictionaries 25 10 23 25 83 JSON Files 25 10 23 25 83 Key-Value Pairs 25 10 23 25 83 KeyError 25 15 23 25 88 Keys Method 25 10 23 25 83 Keyword Arguments 25 10 23 25 83 KISS Principle 25 10 23 25 83 Lambda Functions 25 10 23 25 83 Len Function for Lists 25 10 23 25 83 Linear Search 25 10 23 25 83 Linear Time O(n) 25 10 23 25 83 Linearithmic Time 25 10 23 25 83 Linting Tools 25 10 23 25 83 List Aliasing 25 15 23 25 88 List as Queue 25 15 23 25 88 List as Stack 25 10 23 25 83 List Comprehension 25 10 23 25 83 List Concatenation 25 15 23 25 88 List Copying 25 15 23 25 88 List Creation 25 15 23 25 88 List Indexing 25 15 23 25 88 List Methods 25 10 23 25 83 List Mutability 25 10 23 25 83 List of Lists 25 15 23 25 88 List Repetition 25 15 23 25 88 List Slicing 25 15 23 25 88 List Traversal 25 15 23 25 88 List Unpacking 25 15 23 25 88 List vs Generator Memory 25 10 23 25 83 Lists 25 10 23 25 83 Local Variables 25 10 23 25 83 Logarithmic Time O(log n) 25 10 23 25 83 Logic Errors 25 10 23 25 83 Logical Operators 25 10 23 25 83 Loop Body 25 10 23 25 83 Loop Else Clause 25 10 23 25 83 Loop Invariants 25 10 23 25 83 Loop Patterns 25 15 23 25 88 Loop Variable 25 10 23 25 83 Loops 25 15 23 25 88 Main Function Pattern 25 10 23 25 83 Manual Testing 25 10 23 25 83 Map Function 25 10 23 25 83 Match Statement 25 10 23 25 83 Membership Testing 25 15 23 25 88 Memoization 25 10 23 25 83 Merge Sort 25 10 23 25 83 Merge Sort Recursion 25 10 23 25 83 Method Overriding 25 10 23 25 83 Method Resolution Order 25 10 23 25 83 Methods 25 10 23 25 83 Min Max Sum Functions 25 10 23 25 83 Modular Design 25 10 23 25 83 Modulo Operator 25 10 23 25 83 Multiline Strings 25 15 23 25 88 Multiple Assignment 25 10 23 25 83 Multiple Except Blocks 25 10 23 25 83 Multiple Inheritance 25 10 23 25 83 Multiple Return Values 25 10 23 25 83 Name Equals Main 25 15 23 25 88 Named Tuples 25 10 23 25 83 Negative Indexing 25 15 23 25 88 Nested Conditionals 25 10 23 25 83 Nested Dictionaries 25 10 23 25 83 Nested Lists 25 10 23 25 83 Nested Loops 25 15 23 25 88 None Type 25 15 23 25 88 Not Operator 25 10 23 25 83 Object Comparison 25 10 23 25 83 Object Identity 25 10 23 25 83 Object-Oriented Programming 25 10 23 25 83 Objects 25 10 23 25 83 Opening Files 25 10 23 25 83 Operating Systems 25 10 23 25 83 Operator Overloading 25 10 23 25 83 Operator Precedence 25 10 23 25 83 Or Operator 25 10 23 25 83 Order of Operations 25 10 23 25 83 OrderedDict 25 15 23 25 88 Parameters 25 10 23 25 83 Parent Class 25 10 23 25 83 Pattern Recognition 25 10 23 25 83 PEP 8 Guidelines 25 10 23 25 83 Pip Package Manager 25 10 23 25 83 Polymorphism 25 10 23 25 83 Pop Method 25 10 23 25 83 Pop Method for Dicts 25 15 23 25 88 Positional Arguments 25 10 23 25 83 Print Debugging 25 10 23 25 83 Print Function 25 10 23 25 83 Private Attributes 25 10 23 25 83 Problem Solving 25 15 23 25 88 Program Planning 25 10 23 25 83 Programming Languages 25 15 23 25 88 Property Decorator 25 10 23 25 83 Pseudocode 25 10 23 25 83 Python Best Practices 25 10 23 25 83 Python Interpreter 25 15 23 25 88 Python Language 25 10 23 25 83 Python Modules 25 10 23 25 83 Python Packages 25 10 23 25 83 Python REPL 25 15 23 25 88 Python Scripts 25 10 23 25 83 Quadratic Time O(n^2) 25 10 23 25 83 Raising Exceptions 25 10 23 25 83 Range Function 25 10 23 25 83 Raw Strings 25 15 23 25 88 Read Method 25 10 23 25 83 Readline Method 25 10 23 25 83 Readlines Method 25 10 23 25 83 Recursion 25 25 23 25 98 Recursion in Algorithms 25 10 23 25 83 Recursion vs Iteration 25 10 23 25 83 Recursive Call Stack 25 10 23 25 83 Recursive Case 25 10 23 25 83 Recursive Patterns 25 10 23 25 83 Reduce Function 25 10 23 25 83 Refactoring 25 10 23 25 83 Regular Expressions 25 10 23 25 83 Remove Method 25 10 23 25 83 Removing Duplicates 25 15 23 25 88 Repr Method 25 10 23 25 83 Requirements Analysis 25 10 23 25 83 Return Statement 25 10 23 25 83 Return Values 25 10 23 25 83 Reverse Method 25 10 23 25 83 Rubber Duck Debugging 25 10 23 25 83 Runtime Errors 25 10 23 25 83 Search Comparison 25 10 23 25 83 Selection Sort 25 10 23 25 83 Sentinel Value Pattern 25 15 23 25 88 Sequential Execution 25 10 23 25 83 Set Creation 25 15 23 25 88 Set Difference 25 15 23 25 88 Set Intersection 25 15 23 25 88 Set Methods 25 10 23 25 83 Set Operations 25 10 23 25 83 Set Symmetric Difference 25 15 23 25 88 Set Union 25 15 23 25 88 Sets 25 10 23 25 83 Setter Methods 25 10 23 25 83 Shallow Copy 25 10 23 25 83 Short-Circuit Evaluation 25 15 23 25 88 Slice Notation 25 15 23 25 88 Sliding Window Pattern 25 10 23 25 83 Software Development 25 10 23 25 83 Sort Method 25 10 23 25 83 Sorted Function 25 10 23 25 83 Sorting Comparison 25 10 23 25 83 Space Complexity 25 10 23 25 83 Split Method 25 15 23 25 88 Stable vs Unstable Sort 25 10 23 25 83 Stack Overflow 25 10 23 25 83 Startswith and Endswith 25 15 23 25 88 Statements 25 10 23 25 83 Static Methods 25 10 23 25 83 Step Through Code 25 10 23 25 83 Stepwise Refinement 25 15 23 25 88 Str Method 25 10 23 25 83 String Basics 25 15 23 25 88 String Comparison 25 15 23 25 88 String Concatenation 25 10 23 25 83 String Formatting 25 10 23 25 83 String Immutability 25 10 23 25 83 String Indexing 25 15 23 25 88 String Iteration 25 15 23 25 88 String Length 25 15 23 25 88 String Methods 25 10 23 25 83 String Repetition 25 10 23 25 83 String Reversal 25 15 23 25 88 String Slicing 25 15 23 25 88 String Type 25 10 23 25 83 String Validation Methods 25 10 23 25 83 Strip Method 25 15 23 25 88 Super Function 25 10 23 25 83 Syntax Errors 25 10 23 25 83 Ternary Expression 25 10 23 25 83 Test Cases 25 10 23 25 83 Test Functions 25 10 23 25 83 Test-Driven Development 25 10 23 25 83 Testing 25 10 23 25 83 Text vs Binary Files 25 10 23 25 83 The Self Parameter 25 10 23 25 83 Time Complexity 25 10 23 25 83 Truth Tables 25 10 23 25 83 Truthiness and Falsiness 25 10 23 25 83 Try-Except Block 25 10 23 25 83 Tuple Creation 25 15 23 25 88 Tuple Immutability 25 10 23 25 83 Tuple Methods 25 10 23 25 83 Tuple Packing 25 10 23 25 83 Tuple Unpacking 25 10 23 25 83 Tuples 25 10 23 25 83 Tuples as Keys 25 10 23 25 83 Tuples vs Lists 25 10 23 25 83 Two Pointer Technique 25 10 23 25 83 Type Annotations 25 10 23 25 83 Type Conversion 25 10 23 25 83 Type Function 25 10 23 25 83 Type Hints 25 10 23 25 83 TypeError 25 15 23 25 88 UML Class Diagrams 25 10 23 25 83 Unit Testing 25 10 23 25 83 Unittest Module 25 10 23 25 83 Unpacking Operators 25 10 23 25 83 Update Method 25 10 23 25 83 Upper and Lower Methods 25 10 23 25 83 ValueError 25 15 23 25 88 Values Method 25 10 23 25 83 Variable Assignment 25 10 23 25 83 Variable Naming Rules 25 10 23 25 83 Variable Scope 25 10 23 25 83 Variables 25 10 23 25 83 Version Control Intro 25 10 23 25 83 Virtual Environments 25 10 23 25 83 Walrus Operator 25 10 23 25 83 While Loop 25 15 23 25 88 With Statement 25 10 23 25 83 Write Method 25 10 23 25 83 Writelines Method 25 10 23 25 83 Yield Statement 25 10 23 25 83 Zip Function 25 10 23 25 83"},{"location":"learning-graph/glossary-quality-report/#overall-quality-metrics","title":"Overall Quality Metrics","text":"<p>Average definition length: 12.2 words Definitions meeting all 4 criteria: 1.2% Circular definitions found: 0 Example coverage: 78.8% Cross-references: 19 total, 0 broken</p>"},{"location":"learning-graph/glossary-quality-report/#readability","title":"Readability","text":"<p>Flesch-Kincaid grade level: 10.3 Appropriate for target audience: Yes</p>"},{"location":"learning-graph/glossary-quality-report/#recommendations","title":"Recommendations","text":"<p>No definitions scored below 70/100. No circular definitions detected. Concepts needing examples: - Abstract Classes - Abstraction - Add and Mul Methods - Algorithms - ASCII and Unicode - Binary Number System - Bits and Bytes - Character Encoding - Child Class - Class Attributes - Class Definition - Class Hierarchies - Class Instantiation - Class Methods - Classes - Code Comments - Code Organization - Code Style - Compiled vs Interpreted - Composition - Computational Thinking - Computer Hardware - Computer Science - Constructor - CPU and Memory - Decomposition - Design Patterns Intro - Documentation - DRY Principle - Duck Typing - Dunder Methods - Encapsulation - Eq and Lt Methods - Getter Methods - Git Basics - Has-A Relationship - Import Statements - Inheritance - Init Method - Input and Output Devices - Instance Attributes - Instance Methods - Is-A Relationship - Iterable Protocol - Iterator Protocol - KISS Principle - Linting Tools - Method Overriding - Method Resolution Order - Methods - ... and 35 more No broken cross-references.</p>"},{"location":"learning-graph/linked-in-announcement-full/","title":"Linked in announcement full","text":"<p>Thrilled to share that the Computer Science intelligent textbook for AP-level Python learners is now live!</p> <p>This open (Creative Commons) resource packages a complete year-long experience for grades 10\u201312, blending narrative chapters, learning graphs, taxonomies and concept dependency models, and interactive practice so students can see how each idea builds on the next.  Use it in classrooms for free.  Create a custom version with your school colors in just a few minutes.</p> <p>This release pulls together AI-assisted writing, MkDocs Material publishing, and browser-based MicroSims to turn abstract computing topics into hands-on explorations. Each chapter is grounded in Bloom\u2019s Taxonomy outcomes, backed by a 400-node learning graph, and paired with an ISO 11179 glossary so teachers can trace precisely what each lesson delivers.</p> <p>The new feature of this book is a better focus on using skills to generate our narrative mascot, the friendly python named \"Monty\".  Monty pops up in about six sections of every chapter to give the student encouragement, advice, friendly warnings and congratulations when they finish each chapter. Our Claude Code mascot generation skill creates a detailed style guide that you can review before other agents generate the images and customize the CSS for a character consistent user interface.  This book as variations of our mascot for welcome, thinking, encouragement, tips, friendly warning, and congratulations.</p> <p>By the numbers: \u2022 20 chapters covering everything from Python fundamentals to algorithm analysis and advanced language features \u2022 400 mapped concepts with prerequisite edges plus a 400-term glossary for shared vocabulary \u2022 17 MicroSims that let students manipulate operators, logic, strings, and more directly in the browser \u2022 147,000+ words (~590 printed pages) and 600+ runnable code examples with tracing-friendly formatting \u2022 structured learning checklist items and a detailed Bloom taxonomy learning objectives in our course-description</p> <p>Built with state-of-the-art skills, this project shows how GenAI can accelerate high-quality pedagogically sound curriculum creation while keeping educators in the loop for pedagogy and review.  Note that this is the first time we have blended both Claude Code and Codex skill execution together.  Checkout the log files in the GitHub repo for details.</p> <p>Explore the full textbook: https://dmccreary.github.io/computer-science/</p>"},{"location":"learning-graph/linked-in-announcement-full/#ai-generativeai-claudeai-education-edtech-openeducation-oer-computerscience-apcs-python-interactivetextbook","title":"AI #GenerativeAI #ClaudeAI #Education #EdTech #OpenEducation #OER #ComputerScience #APCS #Python #InteractiveTextbook","text":""},{"location":"learning-graph/linked-in-announcement-full/#microsims-mkdocs-curriculumdesign-stemeducation","title":"MicroSims #MkDocs #CurriculumDesign #STEMeducation","text":""},{"location":"learning-graph/mascot-guide/","title":"Mascot Guide","text":""},{"location":"learning-graph/mascot-guide/#monty-the-python-mascot-guide","title":"Monty the Python - Mascot Guide","text":"<p>Monty is our friendly learning mascot who guides you through this AP Computer Science textbook. Monty is a bright green python snake who loves helping students learn to code!</p>"},{"location":"learning-graph/mascot-guide/#meet-monty","title":"Meet Monty","text":"<p>Name: Monty the Python Species: Python snake Personality: Friendly, encouraging, curious, adventurous, and playful Catchphrases: \"Let's code this!\", \"Let's debug this together!\", \"You've got this!\"</p> <p>Monty wears a gold coding hoodie and headphones, and is always ready to help you tackle the next programming challenge.</p>"},{"location":"learning-graph/mascot-guide/#montys-appearances","title":"Monty's Appearances","text":"<p>Monty shows up in six different ways throughout the textbook:</p>"},{"location":"learning-graph/mascot-guide/#welcome","title":"Welcome","text":"<p>Monty Says: Let's Code This!</p> <p>Welcome to a new chapter! Monty appears at the start of each chapter to introduce what you'll learn and get you excited about the topics ahead.</p>"},{"location":"learning-graph/mascot-guide/#key-insight","title":"Key Insight","text":"<p>Key Insight</p> <p>When there's an important concept to understand, Monty takes a moment to think deeply and share the core idea with you.</p>"},{"location":"learning-graph/mascot-guide/#tip","title":"Tip","text":"<p>Monty's Tip</p> <p>Monty shares helpful tips and shortcuts that make coding easier. These are practical nuggets of wisdom you'll use again and again.</p>"},{"location":"learning-graph/mascot-guide/#warning","title":"Warning","text":"<p>Watch Out!</p> <p>When there's a common mistake or pitfall, Monty warns you before you fall into the trap. Pay attention to these!</p>"},{"location":"learning-graph/mascot-guide/#celebration","title":"Celebration","text":"<p>Great Progress!</p> <p>When you've mastered a topic or completed a major section, Monty celebrates with you. You earned it!</p>"},{"location":"learning-graph/mascot-guide/#encouragement","title":"Encouragement","text":"<p>You've Got This!</p> <p>When the material gets tough, Monty is there to remind you that struggle is normal and you can do it.</p>"},{"location":"learning-graph/mascot-guide/#ai-image-generation-prompts","title":"AI Image Generation Prompts","text":"<p>Use these prompts with your preferred AI image generator (ChatGPT/DALL-E, Midjourney, etc.) to create consistent mascot images.</p>"},{"location":"learning-graph/mascot-guide/#base-character-prompt","title":"Base Character Prompt","text":"<pre><code>Please generate a new png image on a transparent background.\nA friendly cartoon illustration of Monty the Python, a pedagogical mascot\nfor an AP Computer Science textbook. Monty is a bright green python snake\nwith gold accents and a warm, expressive face. Monty wears a small gold\ncoding hoodie and has gold headphones around his neck. Monty has large,\nfriendly eyes with a cheerful expression. The character is small and\ncompact, suitable for icon-sized display.\nStyle: friendly cartoon, rounded shapes, expressive features, clean lines,\nwhite background, suitable for embedding in educational content. No text\nin image.\n</code></pre>"},{"location":"learning-graph/mascot-guide/#pose-variants","title":"Pose Variants","text":"<p>Save each generated image to <code>docs/img/mascot/</code> with the filename shown.</p> <p>1. Welcome Pose \u2192 <code>welcome.png</code></p> <pre><code>Please generate a new png image on a transparent background.\nThe title is \"Monty Welcome\"\nA friendly cartoon illustration of Monty the Python, a pedagogical mascot\nfor an AP Computer Science textbook. Monty is a bright green python snake\nwith gold accents and a warm, expressive face. Monty wears a small gold\ncoding hoodie and has gold headphones around his neck. Monty has large,\nfriendly eyes with a cheerful expression. The character is small and\ncompact, suitable for icon-sized display.\nStyle: friendly cartoon, rounded shapes, expressive features, clean lines,\nwhite background, suitable for embedding in educational content. No text\nin image.\nMonty is waving cheerfully with the tip of his tail, facing the viewer\nwith a warm, welcoming expression. The pose suggests \"welcome\" and\n\"let's get started.\"\n</code></pre> <p>2. Thinking Pose \u2192 <code>thinking.png</code></p> <pre><code>Please generate a new png image on a transparent background.\n\nA friendly cartoon illustration of Monty the Python, a pedagogical mascot\nfor an AP Computer Science textbook. Monty is a bright green python snake\nwith gold accents and a warm, expressive face. Monty wears a small gold\ncoding hoodie and has gold headphones around his neck. Monty has large,\nfriendly eyes with a cheerful expression. The character is small and\ncompact, suitable for icon-sized display.\nStyle: friendly cartoon, rounded shapes, expressive features, clean lines,\nwhite background, suitable for embedding in educational content. No text\nin image.\nMonty has the tip of his tail on his chin in a thoughtful pose, looking\nupward with curiosity. A small lightbulb glows above his head. The pose\nsuggests deep thinking and discovery.\n</code></pre> <p>3. Tip Pose \u2192 <code>tip.png</code></p> <pre><code>Please generate a new png image on a transparent background.\nThis one is called Monty shares a tip.\nA friendly cartoon illustration of Monty the Python, a pedagogical mascot\nfor an AP Computer Science textbook. Monty is a bright green python snake\nwith gold accents and a warm, expressive face. Monty wears a small gold\ncoding hoodie and has gold headphones around his neck. Monty has large,\nfriendly eyes with a cheerful expression. The character is small and\ncompact, suitable for icon-sized display.\nStyle: friendly cartoon, rounded shapes, expressive features, clean lines,\nwhite background, suitable for embedding in educational content. No text\nin image.\nMonty is pointing upward with the tip of his tail as if sharing an\nimportant tip. Expression is helpful and knowing. A small star sparkles\nnear the pointing gesture.\nDo not put any extra padding around the image.\n</code></pre> <p>4. Warning Pose \u2192 <code>warning.png</code></p> <pre><code>Please generate a new png image on a transparent background.\nThe title is \"Monty gives a gentle warning\"\nA friendly cartoon illustration of Monty the Python, a pedagogical mascot\nfor an AP Computer Science textbook. Monty is a bright green python snake\nwith gold accents and a warm, expressive face. Monty wears a small gold\ncoding hoodie and has gold headphones around his neck. Monty has large,\nfriendly eyes with a cheerful expression. The character is small and\ncompact, suitable for icon-sized display.\nStyle: friendly cartoon, rounded shapes, expressive features, clean lines,\nwhite background, suitable for embedding in educational content. No text\nin image.\nMonty holds up the tip of his tail in a gentle \"stop\" or \"be careful\"\ngesture. Expression is concerned but caring. A small exclamation mark\nor caution symbol appears nearby.\n</code></pre> <p>5. Celebration Pose \u2192 <code>celebration.png</code></p> <pre><code>Please generate a new png image on a transparent background.\nThe title is \"Monty Celebrates\"\nA friendly cartoon illustration of Monty the Python, a pedagogical mascot\nfor an AP Computer Science textbook. Monty is a bright green python snake\nwith gold accents and a warm, expressive face. Monty wears a small gold\ncoding hoodie and has gold headphones around his neck. Monty has large,\nfriendly eyes with a cheerful expression. The character is small and\ncompact, suitable for icon-sized display.\nStyle: friendly cartoon, rounded shapes, expressive features, clean lines,\nwhite background, suitable for embedding in educational content. No text\nin image.\nMonty is coiled in a joyful spiral with his tail raised high in\ncelebration. Expression is joyful and proud. Small confetti and stars\nfloat around the character. Remove all the extra space around the image.\n</code></pre> <p>6. Encouraging Pose \u2192 <code>encouraging.png</code></p> <pre><code>Please generate a new png image on a transparent background.\nThe title is \"Monty Encourages\"\nA friendly cartoon illustration of Monty the Python, a pedagogical mascot\nfor an AP Computer Science textbook. Monty is a bright green python snake\nwith gold accents and a warm, expressive face. Monty wears a small gold\ncoding hoodie and has gold headphones around his neck. Monty has large,\nfriendly eyes with a cheerful expression. The character is small and\ncompact, suitable for icon-sized display.\nStyle: friendly cartoon, rounded shapes, expressive features, clean lines,\nwhite background, suitable for embedding in educational content. No text\nin image.\nMonty gives a tail thumbs-up with a reassuring, supportive smile. The\npose radiates confidence and \"you can do it\" energy.\n</code></pre>"},{"location":"learning-graph/mascot-guide/#image-specifications","title":"Image Specifications","text":"<ul> <li>Format: PNG with transparent background (preferred) or white background</li> <li>Generate at: 1024x1024 pixels</li> <li>Display size: 200x200 to 400x400 pixels</li> <li>File size target: Under 100KB per image</li> </ul>"},{"location":"learning-graph/mascot-guide/#usage-in-chapters","title":"Usage in Chapters","text":"<p>Authors use standard admonition syntax with these custom types:</p> <pre><code>!!! mascot-welcome \"Monty Says: Let's Code This!\"\n    Welcome text here...\n\n!!! mascot-thinking \"Key Insight\"\n    Important concept explanation...\n\n!!! mascot-tip \"Monty's Tip\"\n    Helpful tip text...\n\n!!! mascot-warning \"Watch Out!\"\n    Warning about common mistake...\n\n!!! mascot-celebration \"Great Progress!\"\n    Celebration text...\n\n!!! mascot-encourage \"You've Got This!\"\n    Encouraging message...\n</code></pre>"},{"location":"learning-graph/mascot-guide/#placement-rules","title":"Placement Rules","text":"Context Admonition Type Frequency Chapter opening mascot-welcome Every chapter Key concept mascot-thinking 2-3 per chapter Helpful tip mascot-tip As needed Common mistake mascot-warning As needed Section completion mascot-celebration End of major sections Difficult content mascot-encourage Where students struggle <p>Important: Monty should appear no more than 5-6 times per chapter. Don't place mascot admonitions back-to-back.</p>"},{"location":"learning-graph/mascot-guide/#cover-image","title":"Cover Image","text":"<p>Create a wide landscape textbook cover for \u201cComputer Science (with Python)\u201d. High resolution, 1.91:1 aspect ratio for use on open graph social media preview.</p> <p>Layout: left 15% features the mascot Monty the Python; center has the title text \u201cComputer Science (with Python)\u201d in clean, modern lettering; background is a subtle montage/collage of course concepts. </p> <p>Color theme: bright green and gold accents (Monty\u2019s colors), with clean, readable contrast. Mascot: use the provided Monty image as a reference; he is a friendly bright green python wearing a small gold coding hoodie and gold headphones, warm and welcoming expression. </p> <p>Background collage elements (soft, semi\u2011transparent, layered): - code snippets and braces, Python iconography - algorithms (flowchart arrows, binary search tree outlines, sorting bars) - data structures (lists, dictionaries, sets, nodes) - recursion (self\u2011similar spiral or nested call stack blocks) - testing/debugging (magnifying glass, checkmarks, bug icon) - computational thinking (lightbulb, gears) - file I/O (document/page icon, file paths) Keep the collage subtle so the title remains the focal point. </p> <p>Style: clean, modern educational cover; gentle gradients; light background; professional yet friendly. No extra text besides the title.</p>"},{"location":"learning-graph/quality-metrics/","title":"Graph Quality Analysis","text":""},{"location":"learning-graph/quality-metrics/#learning-graph-quality-metrics-report","title":"Learning Graph Quality Metrics Report","text":""},{"location":"learning-graph/quality-metrics/#overview","title":"Overview","text":"<ul> <li>Total Concepts: 400</li> <li>Foundational Concepts (no dependencies): 1</li> <li>Concepts with Dependencies: 399</li> <li>Average Dependencies per Concept: 1.54</li> </ul>"},{"location":"learning-graph/quality-metrics/#graph-structure-validation","title":"Graph Structure Validation","text":"<ul> <li>Valid DAG Structure: \u274c No</li> <li>Self-Dependencies: None detected \u2705</li> <li>Cycles Detected: 0</li> </ul>"},{"location":"learning-graph/quality-metrics/#foundational-concepts","title":"Foundational Concepts","text":"<p>These concepts have no prerequisites:</p> <ul> <li>1: Computer Science</li> </ul>"},{"location":"learning-graph/quality-metrics/#dependency-chain-analysis","title":"Dependency Chain Analysis","text":"<ul> <li>Maximum Dependency Chain Length: 16</li> </ul>"},{"location":"learning-graph/quality-metrics/#longest-learning-path","title":"Longest Learning Path:","text":"<ol> <li>Computer Science (ID: 1)</li> <li>Programming Languages (ID: 17)</li> <li>Compiled vs Interpreted (ID: 18)</li> <li>Python Language (ID: 19)</li> <li>Data Types (ID: 27)</li> <li>Integer Type (ID: 28)</li> <li>Arithmetic Operators (ID: 36)</li> <li>Expressions (ID: 48)</li> <li>Statements (ID: 49)</li> <li>Control Flow (ID: 66)</li> <li>Loops (ID: 75)</li> <li>For Loop (ID: 76)</li> <li>List Traversal (ID: 166)</li> <li>Linear Search (ID: 329)</li> <li>Binary Search (ID: 330)</li> <li>Search Comparison (ID: 331)</li> </ol>"},{"location":"learning-graph/quality-metrics/#orphaned-nodes-analysis","title":"Orphaned Nodes Analysis","text":"<ul> <li>Total Orphaned Nodes: 204</li> </ul> <p>Concepts that are not prerequisites for any other concept:</p> <ul> <li>12: ASCII and Unicode</li> <li>16: Operating Systems</li> <li>21: Python REPL</li> <li>32: Type Function</li> <li>34: Implicit Type Conversion</li> <li>37: Integer Division</li> <li>38: Modulo Operator</li> <li>42: F-String Formatting</li> <li>46: Constants Convention</li> <li>54: Greater and Less Than</li> <li>59: Short-Circuit Evaluation</li> <li>61: Boolean Conversion</li> <li>62: Chained Comparisons</li> <li>63: Order of Operations</li> <li>64: De Morgan's Laws</li> <li>65: Truth Tables</li> <li>67: Sequential Execution</li> <li>72: Nested Conditionals</li> <li>73: Ternary Expression</li> <li>74: Match Statement</li> </ul> <p>...and 184 more</p>"},{"location":"learning-graph/quality-metrics/#connected-components","title":"Connected Components","text":"<ul> <li>Number of Connected Components: 1</li> </ul> <p>\u2705 All concepts are connected in a single graph.</p>"},{"location":"learning-graph/quality-metrics/#indegree-analysis","title":"Indegree Analysis","text":"<p>Top 10 concepts that are prerequisites for the most other concepts:</p> Rank Concept ID Concept Label Indegree 1 151 Lists 29 2 206 Dictionaries 18 3 326 Algorithm Design 16 4 27 Data Types 13 5 76 For Loop 12 6 116 Functions 12 7 341 Time Complexity 12 8 25 Variable Assignment 10 9 91 String Basics 10 10 143 Recursion 10"},{"location":"learning-graph/quality-metrics/#outdegree-distribution","title":"Outdegree Distribution","text":"Dependencies Number of Concepts 0 1 1 211 2 162 3 23 4 3"},{"location":"learning-graph/quality-metrics/#recommendations","title":"Recommendations","text":"<ul> <li>\u26a0\ufe0f Many orphaned nodes (204): Consider if these should be prerequisites for advanced concepts</li> <li>\u2139\ufe0f Long dependency chains (16): Ensure students can follow extended learning paths</li> </ul> <p>Report generated by learning-graph-reports/analyze_graph.py</p>"},{"location":"learning-graph/taxonomy-distribution/","title":"Taxonomy Distribution Report","text":""},{"location":"learning-graph/taxonomy-distribution/#taxonomy-distribution-report","title":"Taxonomy Distribution Report","text":""},{"location":"learning-graph/taxonomy-distribution/#overview","title":"Overview","text":"<ul> <li>Total Concepts: 400</li> <li>Number of Taxonomies: 15</li> <li>Average Concepts per Taxonomy: 26.7</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#distribution-summary","title":"Distribution Summary","text":"Category TaxonomyID Count Percentage Status Data Structures DATA 80 20.0% \u2705 Object-Oriented Programming OOP 45 11.2% \u2705 Algorithms ALGO 35 8.8% \u2705 Python Basics PYBASIC 30 7.5% \u2705 Functions FUNC 27 6.8% \u2705 Control Flow CTRL 25 6.2% \u2705 Strings STR 25 6.2% \u2705 Foundation Concepts FOUND 20 5.0% \u2705 Testing and Debugging TEST 20 5.0% \u2705 Software Engineering SENG 20 5.0% \u2705 Advanced Python ADVPY 20 5.0% \u2705 Boolean Logic BOOL 15 3.8% \u2705 File I/O FILEIO 15 3.8% \u2705 Error Handling ERR 15 3.8% \u2705 Recursion REC 8 2.0% \u2139\ufe0f Under"},{"location":"learning-graph/taxonomy-distribution/#visual-distribution","title":"Visual Distribution","text":"<pre><code>Data Structures           \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  80 ( 20.0%)\nObject-Oriented Programmi \u2588\u2588\u2588\u2588\u2588  45 ( 11.2%)\nAlgorithms                \u2588\u2588\u2588\u2588  35 (  8.8%)\nPython Basics             \u2588\u2588\u2588  30 (  7.5%)\nFunctions                 \u2588\u2588\u2588  27 (  6.8%)\nControl Flow              \u2588\u2588\u2588  25 (  6.2%)\nStrings                   \u2588\u2588\u2588  25 (  6.2%)\nFoundation Concepts       \u2588\u2588  20 (  5.0%)\nTesting and Debugging     \u2588\u2588  20 (  5.0%)\nSoftware Engineering      \u2588\u2588  20 (  5.0%)\nAdvanced Python           \u2588\u2588  20 (  5.0%)\nBoolean Logic             \u2588  15 (  3.8%)\nFile I/O                  \u2588  15 (  3.8%)\nError Handling            \u2588  15 (  3.8%)\nRecursion                 \u2588   8 (  2.0%)\n</code></pre>"},{"location":"learning-graph/taxonomy-distribution/#balance-analysis","title":"Balance Analysis","text":""},{"location":"learning-graph/taxonomy-distribution/#no-over-represented-categories","title":"\u2705 No Over-Represented Categories","text":"<p>All categories are under the 30% threshold. Good balance!</p>"},{"location":"learning-graph/taxonomy-distribution/#i-under-represented-categories-3","title":"\u2139\ufe0f Under-Represented Categories (&lt;3%)","text":"<ul> <li>Recursion (REC): 8 concepts (2.0%)</li> <li>Note: Small categories are acceptable for specialized topics</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#category-details","title":"Category Details","text":""},{"location":"learning-graph/taxonomy-distribution/#data-structures-data","title":"Data Structures (DATA)","text":"<p>Count: 80 concepts (20.0%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Lists</li> </ol> </li> <li> <ol> <li>List Creation</li> </ol> </li> <li> <ol> <li>List Indexing</li> </ol> </li> <li> <ol> <li>List Slicing</li> </ol> </li> <li> <ol> <li>List Mutability</li> </ol> </li> <li> <ol> <li>List Methods</li> </ol> </li> <li> <ol> <li>Append Method</li> </ol> </li> <li> <ol> <li>Insert Method</li> </ol> </li> <li> <ol> <li>Remove Method</li> </ol> </li> <li> <ol> <li>Pop Method</li> </ol> </li> <li> <ol> <li>Sort Method</li> </ol> </li> <li> <ol> <li>Reverse Method</li> </ol> </li> <li> <ol> <li>List Comprehension</li> </ol> </li> <li> <ol> <li>Nested Lists</li> </ol> </li> <li> <ol> <li>List of Lists</li> </ol> </li> <li>...and 65 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#object-oriented-programming-oop","title":"Object-Oriented Programming (OOP)","text":"<p>Count: 45 concepts (11.2%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Object-Oriented Programming</li> </ol> </li> <li> <ol> <li>Classes</li> </ol> </li> <li> <ol> <li>Objects</li> </ol> </li> <li> <ol> <li>Class Definition</li> </ol> </li> <li> <ol> <li>Class Instantiation</li> </ol> </li> <li> <ol> <li>Instance Attributes</li> </ol> </li> <li> <ol> <li>Class Attributes</li> </ol> </li> <li> <ol> <li>The Self Parameter</li> </ol> </li> <li> <ol> <li>Init Method</li> </ol> </li> <li> <ol> <li>Constructor</li> </ol> </li> <li> <ol> <li>Methods</li> </ol> </li> <li> <ol> <li>Instance Methods</li> </ol> </li> <li> <ol> <li>Str Method</li> </ol> </li> <li> <ol> <li>Repr Method</li> </ol> </li> <li> <ol> <li>Encapsulation</li> </ol> </li> <li>...and 30 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#algorithms-algo","title":"Algorithms (ALGO)","text":"<p>Count: 35 concepts (8.8%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Algorithm Design</li> </ol> </li> <li> <ol> <li>Pseudocode</li> </ol> </li> <li> <ol> <li>Flowcharts</li> </ol> </li> <li> <ol> <li>Linear Search</li> </ol> </li> <li> <ol> <li>Binary Search</li> </ol> </li> <li> <ol> <li>Search Comparison</li> </ol> </li> <li> <ol> <li>Selection Sort</li> </ol> </li> <li> <ol> <li>Insertion Sort</li> </ol> </li> <li> <ol> <li>Merge Sort</li> </ol> </li> <li> <ol> <li>Merge Sort Recursion</li> </ol> </li> <li> <ol> <li>Sorting Comparison</li> </ol> </li> <li> <ol> <li>Stable vs Unstable Sort</li> </ol> </li> <li> <ol> <li>Algorithm Correctness</li> </ol> </li> <li> <ol> <li>Loop Invariants</li> </ol> </li> <li> <ol> <li>Big-O Notation</li> </ol> </li> <li>...and 20 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#python-basics-pybasic","title":"Python Basics (PYBASIC)","text":"<p>Count: 30 concepts (7.5%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Python REPL</li> </ol> </li> <li> <ol> <li>Python Scripts</li> </ol> </li> <li> <ol> <li>Comments in Code</li> </ol> </li> <li> <ol> <li>Variables</li> </ol> </li> <li> <ol> <li>Variable Assignment</li> </ol> </li> <li> <ol> <li>Variable Naming Rules</li> </ol> </li> <li> <ol> <li>Data Types</li> </ol> </li> <li> <ol> <li>Integer Type</li> </ol> </li> <li> <ol> <li>Float Type</li> </ol> </li> <li> <ol> <li>Boolean Type</li> </ol> </li> <li> <ol> <li>String Type</li> </ol> </li> <li> <ol> <li>Type Function</li> </ol> </li> <li> <ol> <li>Type Conversion</li> </ol> </li> <li> <ol> <li>Implicit Type Conversion</li> </ol> </li> <li> <ol> <li>Explicit Type Casting</li> </ol> </li> <li>...and 15 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#functions-func","title":"Functions (FUNC)","text":"<p>Count: 27 concepts (6.8%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Functions</li> </ol> </li> <li> <ol> <li>Function Definition</li> </ol> </li> <li> <ol> <li>Function Call</li> </ol> </li> <li> <ol> <li>Parameters</li> </ol> </li> <li> <ol> <li>Arguments</li> </ol> </li> <li> <ol> <li>Return Statement</li> </ol> </li> <li> <ol> <li>Return Values</li> </ol> </li> <li> <ol> <li>None Type</li> </ol> </li> <li> <ol> <li>Default Parameters</li> </ol> </li> <li> <ol> <li>Keyword Arguments</li> </ol> </li> <li> <ol> <li>Positional Arguments</li> </ol> </li> <li> <ol> <li>Multiple Return Values</li> </ol> </li> <li> <ol> <li>Variable Scope</li> </ol> </li> <li> <ol> <li>Local Variables</li> </ol> </li> <li> <ol> <li>Global Variables</li> </ol> </li> <li>...and 12 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#control-flow-ctrl","title":"Control Flow (CTRL)","text":"<p>Count: 25 concepts (6.2%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Control Flow</li> </ol> </li> <li> <ol> <li>Sequential Execution</li> </ol> </li> <li> <ol> <li>Conditional Statements</li> </ol> </li> <li> <ol> <li>If Statement</li> </ol> </li> <li> <ol> <li>If-Else Statement</li> </ol> </li> <li> <ol> <li>Elif Statement</li> </ol> </li> <li> <ol> <li>Nested Conditionals</li> </ol> </li> <li> <ol> <li>Ternary Expression</li> </ol> </li> <li> <ol> <li>Match Statement</li> </ol> </li> <li> <ol> <li>Loops</li> </ol> </li> <li> <ol> <li>For Loop</li> </ol> </li> <li> <ol> <li>While Loop</li> </ol> </li> <li> <ol> <li>Range Function</li> </ol> </li> <li> <ol> <li>Loop Variable</li> </ol> </li> <li> <ol> <li>Loop Body</li> </ol> </li> <li>...and 10 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#strings-str","title":"Strings (STR)","text":"<p>Count: 25 concepts (6.2%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>String Basics</li> </ol> </li> <li> <ol> <li>String Indexing</li> </ol> </li> <li> <ol> <li>Negative Indexing</li> </ol> </li> <li> <ol> <li>String Slicing</li> </ol> </li> <li> <ol> <li>Slice Notation</li> </ol> </li> <li> <ol> <li>String Immutability</li> </ol> </li> <li> <ol> <li>String Length</li> </ol> </li> <li> <ol> <li>String Methods</li> </ol> </li> <li> <ol> <li>Upper and Lower Methods</li> </ol> </li> <li> <ol> <li>Strip Method</li> </ol> </li> <li> <ol> <li>Split Method</li> </ol> </li> <li> <ol> <li>Join Method</li> </ol> </li> <li> <ol> <li>Find and Replace Methods</li> </ol> </li> <li> <ol> <li>Startswith and Endswith</li> </ol> </li> <li> <ol> <li>String Iteration</li> </ol> </li> <li>...and 10 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#foundation-concepts-found","title":"Foundation Concepts (FOUND)","text":"<p>Count: 20 concepts (5.0%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Computer Science</li> </ol> </li> <li> <ol> <li>Computational Thinking</li> </ol> </li> <li> <ol> <li>Algorithms</li> </ol> </li> <li> <ol> <li>Abstraction</li> </ol> </li> <li> <ol> <li>Decomposition</li> </ol> </li> <li> <ol> <li>Pattern Recognition</li> </ol> </li> <li> <ol> <li>Stepwise Refinement</li> </ol> </li> <li> <ol> <li>Problem Solving</li> </ol> </li> <li> <ol> <li>Binary Number System</li> </ol> </li> <li> <ol> <li>Bits and Bytes</li> </ol> </li> <li> <ol> <li>Character Encoding</li> </ol> </li> <li> <ol> <li>ASCII and Unicode</li> </ol> </li> <li> <ol> <li>Computer Hardware</li> </ol> </li> <li> <ol> <li>CPU and Memory</li> </ol> </li> <li> <ol> <li>Input and Output Devices</li> </ol> </li> <li>...and 5 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#testing-and-debugging-test","title":"Testing and Debugging (TEST)","text":"<p>Count: 20 concepts (5.0%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Testing</li> </ol> </li> <li> <ol> <li>Manual Testing</li> </ol> </li> <li> <ol> <li>Unit Testing</li> </ol> </li> <li> <ol> <li>Test Cases</li> </ol> </li> <li> <ol> <li>Assert Statements</li> </ol> </li> <li> <ol> <li>Unittest Module</li> </ol> </li> <li> <ol> <li>Test Functions</li> </ol> </li> <li> <ol> <li>Edge Cases</li> </ol> </li> <li> <ol> <li>Boundary Testing</li> </ol> </li> <li> <ol> <li>Test-Driven Development</li> </ol> </li> <li> <ol> <li>Debugging</li> </ol> </li> <li> <ol> <li>Print Debugging</li> </ol> </li> <li> <ol> <li>Debugger Tools</li> </ol> </li> <li> <ol> <li>Breakpoints</li> </ol> </li> <li> <ol> <li>Step Through Code</li> </ol> </li> <li>...and 5 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#software-engineering-seng","title":"Software Engineering (SENG)","text":"<p>Count: 20 concepts (5.0%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Software Development</li> </ol> </li> <li> <ol> <li>Program Planning</li> </ol> </li> <li> <ol> <li>Requirements Analysis</li> </ol> </li> <li> <ol> <li>Modular Design</li> </ol> </li> <li> <ol> <li>Code Organization</li> </ol> </li> <li> <ol> <li>Import Statements</li> </ol> </li> <li> <ol> <li>Python Modules</li> </ol> </li> <li> <ol> <li>Python Packages</li> </ol> </li> <li> <ol> <li>Pip Package Manager</li> </ol> </li> <li> <ol> <li>Virtual Environments</li> </ol> </li> <li> <ol> <li>Version Control Intro</li> </ol> </li> <li> <ol> <li>Git Basics</li> </ol> </li> <li> <ol> <li>Code Style</li> </ol> </li> <li> <ol> <li>PEP 8 Guidelines</li> </ol> </li> <li> <ol> <li>Linting Tools</li> </ol> </li> <li>...and 5 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#advanced-python-advpy","title":"Advanced Python (ADVPY)","text":"<p>Count: 20 concepts (5.0%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Generators</li> </ol> </li> <li> <ol> <li>Yield Statement</li> </ol> </li> <li> <ol> <li>Generator Expressions</li> </ol> </li> <li> <ol> <li>Decorators</li> </ol> </li> <li> <ol> <li>Closures</li> </ol> </li> <li> <ol> <li>Args and Kwargs</li> </ol> </li> <li> <ol> <li>Unpacking Operators</li> </ol> </li> <li> <ol> <li>Walrus Operator</li> </ol> </li> <li> <ol> <li>Type Hints</li> </ol> </li> <li> <ol> <li>Type Annotations</li> </ol> </li> <li> <ol> <li>Dataclasses</li> </ol> </li> <li> <ol> <li>Enum Type</li> </ol> </li> <li> <ol> <li>Regular Expressions</li> </ol> </li> <li> <ol> <li>Collections Module</li> </ol> </li> <li> <ol> <li>Itertools Module</li> </ol> </li> <li>...and 5 more</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#boolean-logic-bool","title":"Boolean Logic (BOOL)","text":"<p>Count: 15 concepts (3.8%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Boolean Expressions</li> </ol> </li> <li> <ol> <li>Comparison Operators</li> </ol> </li> <li> <ol> <li>Equal and Not Equal</li> </ol> </li> <li> <ol> <li>Greater and Less Than</li> </ol> </li> <li> <ol> <li>Logical Operators</li> </ol> </li> <li> <ol> <li>And Operator</li> </ol> </li> <li> <ol> <li>Or Operator</li> </ol> </li> <li> <ol> <li>Not Operator</li> </ol> </li> <li> <ol> <li>Short-Circuit Evaluation</li> </ol> </li> <li> <ol> <li>Truthiness and Falsiness</li> </ol> </li> <li> <ol> <li>Boolean Conversion</li> </ol> </li> <li> <ol> <li>Chained Comparisons</li> </ol> </li> <li> <ol> <li>Order of Operations</li> </ol> </li> <li> <ol> <li>De Morgan's Laws</li> </ol> </li> <li> <ol> <li>Truth Tables</li> </ol> </li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#file-io-fileio","title":"File I/O (FILEIO)","text":"<p>Count: 15 concepts (3.8%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>File Input Output</li> </ol> </li> <li> <ol> <li>Opening Files</li> </ol> </li> <li> <ol> <li>File Modes</li> </ol> </li> <li> <ol> <li>Read Method</li> </ol> </li> <li> <ol> <li>Readline Method</li> </ol> </li> <li> <ol> <li>Readlines Method</li> </ol> </li> <li> <ol> <li>Write Method</li> </ol> </li> <li> <ol> <li>Writelines Method</li> </ol> </li> <li> <ol> <li>With Statement</li> </ol> </li> <li> <ol> <li>Context Managers</li> </ol> </li> <li> <ol> <li>File Paths</li> </ol> </li> <li> <ol> <li>CSV Files</li> </ol> </li> <li> <ol> <li>JSON Files</li> </ol> </li> <li> <ol> <li>File Exceptions</li> </ol> </li> <li> <ol> <li>Text vs Binary Files</li> </ol> </li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#error-handling-err","title":"Error Handling (ERR)","text":"<p>Count: 15 concepts (3.8%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Errors and Exceptions</li> </ol> </li> <li> <ol> <li>Syntax Errors</li> </ol> </li> <li> <ol> <li>Runtime Errors</li> </ol> </li> <li> <ol> <li>Logic Errors</li> </ol> </li> <li> <ol> <li>Exception Types</li> </ol> </li> <li> <ol> <li>TypeError</li> </ol> </li> <li> <ol> <li>ValueError</li> </ol> </li> <li> <ol> <li>IndexError</li> </ol> </li> <li> <ol> <li>KeyError</li> </ol> </li> <li> <ol> <li>Try-Except Block</li> </ol> </li> <li> <ol> <li>Multiple Except Blocks</li> </ol> </li> <li> <ol> <li>Finally Block</li> </ol> </li> <li> <ol> <li>Raising Exceptions</li> </ol> </li> <li> <ol> <li>Custom Exceptions</li> </ol> </li> <li> <ol> <li>Assertions</li> </ol> </li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#recursion-rec","title":"Recursion (REC)","text":"<p>Count: 8 concepts (2.0%)</p> <p>Concepts:</p> <ul> <li> <ol> <li>Recursion</li> </ol> </li> <li> <ol> <li>Base Case</li> </ol> </li> <li> <ol> <li>Recursive Case</li> </ol> </li> <li> <ol> <li>Recursive Call Stack</li> </ol> </li> <li> <ol> <li>Stack Overflow</li> </ol> </li> <li> <ol> <li>Recursion vs Iteration</li> </ol> </li> <li> <ol> <li>Recursive Patterns</li> </ol> </li> <li> <ol> <li>Memoization</li> </ol> </li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#recommendations","title":"Recommendations","text":"<ul> <li>\u2705 Good balance: Categories are reasonably distributed (spread: 18.0%)</li> <li>\u2705 MISC category minimal: Good categorization specificity</li> </ul>"},{"location":"learning-graph/taxonomy-distribution/#educational-use-recommendations","title":"Educational Use Recommendations","text":"<ul> <li>Use taxonomy categories for color-coding in graph visualizations</li> <li>Design curriculum modules based on taxonomy groupings</li> <li>Create filtered views for focused learning paths</li> <li>Use categories for assessment organization</li> <li>Enable navigation by topic area in interactive tools</li> </ul> <p>Report generated by learning-graph-reports/taxonomy_distribution.py</p>"},{"location":"prompts/faq-generation-codex/","title":"FAQ generation","text":""},{"location":"prompts/faq-generation-codex/#faq-generation","title":"FAQ generation","text":""},{"location":"prompts/generate-course-description/","title":"Course Description","text":"<p>Please generate A full AP Computer Science (Python Version) course description</p>"},{"location":"prompts/microsim-generation/","title":"Microsim generation","text":"<p>Run the /microsim-generator skill on all the #### Diagram elements in @docs/chapters/06-functions-and-modular-design/index.md</p> <p>01-intro-to-computer-science 02-python-fundamentals 03-boolean-logic 04-control-flow 05-working-with-strings 06-functions-and-modular-design 07-higher-order-functions-and-recursion 08-lists 09-advanced-list-operations 10-tuples-and-sets 11-dictionaries 12-classes-and-objects 13-inheritance-and-polymorphism 14-errors-and-exceptions 15-file-input-and-output 16-software-engineering 17-testing-and-debugging 18-searching-and-sorting 19-algorithm-analysis 20-advanced-python</p>"},{"location":"sims/","title":"List of MicroSims","text":""},{"location":"sims/#microsims","title":"MicroSims","text":"<p>Interactive simulations that let you explore computer science concepts by experimenting in real time. Click any card to launch the MicroSim.</p> <p>Total MicroSims: 17 | Chapters covered: 3</p>"},{"location":"sims/#chapter-1-intro-to-computer-science","title":"Chapter 1: Intro to Computer Science","text":"<ul> <li> <p> Inside a Computer</p> <p>Explore the internal components of a computer and how they work together.</p> <p> Launch</p> </li> <li> <p> Binary Number Explorer</p> <p>Convert between binary and decimal and see how computers represent numbers.</p> <p> Launch</p> </li> <li> <p> ASCII Character Map</p> <p>Discover how characters are encoded as numbers using the ASCII standard.</p> <p> Launch</p> </li> <li> <p> Computational Thinking Pillars</p> <p>Visualize the four pillars of computational thinking: decomposition, pattern recognition, abstraction, and algorithms.</p> <p> Launch</p> </li> <li> <p> Compiled vs. Interpreted Languages</p> <p>Compare how compiled and interpreted languages turn source code into running programs.</p> <p> Launch</p> </li> </ul>"},{"location":"sims/#chapter-2-python-fundamentals","title":"Chapter 2: Python Fundamentals","text":"<ul> <li> <p> Arithmetic Operators Explorer</p> <p>Try out Python's arithmetic operators and see results update live.</p> <p> Launch</p> </li> <li> <p> Python Data Types Overview</p> <p>Explore Python's built-in data types and how they behave.</p> <p> Launch</p> </li> <li> <p> Expressions vs. Statements</p> <p>Learn the difference between expressions that produce values and statements that perform actions.</p> <p> Launch</p> </li> <li> <p> Python REPL vs. Scripts</p> <p>Compare interactive REPL mode with running saved Python scripts.</p> <p> Launch</p> </li> <li> <p> String Operations Playground</p> <p>Experiment with slicing, concatenation, and other string operations.</p> <p> Launch</p> </li> <li> <p> Code Readability Comparison</p> <p>See how formatting and naming choices affect how easy code is to read.</p> <p> Launch</p> </li> </ul>"},{"location":"sims/#chapter-3-boolean-logic","title":"Chapter 3: Boolean Logic","text":"<ul> <li> <p> Comparison Operator Explorer</p> <p>Test comparison operators and see how Python evaluates them to True or False.</p> <p> Launch</p> </li> <li> <p> Logical Operator Venn Diagrams</p> <p>Visualize AND, OR, and NOT using interactive Venn diagrams.</p> <p> Launch</p> </li> <li> <p> Interactive Truth Table Builder</p> <p>Build truth tables for Boolean expressions and check your understanding.</p> <p> Launch</p> </li> <li> <p> Order of Operations Visualizer</p> <p>See how Python evaluates Boolean expressions step by step.</p> <p> Launch</p> </li> <li> <p> De Morgan's Laws Visualizer</p> <p>Explore how NOT distributes over AND and OR with De Morgan's Laws.</p> <p> Launch</p> </li> <li> <p> Truthiness Tester</p> <p>Find out which Python values are \"truthy\" and which are \"falsy.\"</p> <p> Launch</p> </li> </ul>"},{"location":"sims/arithmetic-operators/","title":"Arithmetic Operators Explorer","text":""},{"location":"sims/arithmetic-operators/#arithmetic-operators-explorer","title":"Arithmetic Operators Explorer","text":"<p>Run the Arithmetic Operators Explorer MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/arithmetic-operators/#about-this-microsim","title":"About This MicroSim","text":"<p>TODO: Describe what this MicroSim demonstrates.</p>"},{"location":"sims/arithmetic-operators/#how-to-use","title":"How to Use","text":"<p>TODO: Describe how students should interact with this MicroSim.</p>"},{"location":"sims/arithmetic-operators/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"450px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/arithmetic-operators/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/arithmetic-operators/#grade-level","title":"Grade Level","text":"<p>9-12 (High School Geometry)</p>"},{"location":"sims/arithmetic-operators/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/arithmetic-operators/#prerequisites","title":"Prerequisites","text":"<p>TODO: List prerequisites.</p>"},{"location":"sims/arithmetic-operators/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): TODO</li> <li>Guided Practice (5 min): TODO</li> <li>Assessment (5 min): TODO</li> </ol>"},{"location":"sims/arithmetic-operators/#assessment","title":"Assessment","text":"<p>TODO: List assessment criteria.</p>"},{"location":"sims/arithmetic-operators/#references","title":"References","text":"<ol> <li>TODO: Add references.</li> </ol>"},{"location":"sims/ascii-character-map/","title":"ASCII Character Map","text":""},{"location":"sims/ascii-character-map/#ascii-character-map","title":"ASCII Character Map","text":"<p>Run the ASCII Character Map MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/ascii-character-map/#about-this-microsim","title":"About This MicroSim","text":"<p>TODO: Describe what this MicroSim demonstrates.</p>"},{"location":"sims/ascii-character-map/#how-to-use","title":"How to Use","text":"<p>TODO: Describe how students should interact with this MicroSim.</p>"},{"location":"sims/ascii-character-map/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"450px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/ascii-character-map/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/ascii-character-map/#grade-level","title":"Grade Level","text":"<p>9-12 (High School Geometry)</p>"},{"location":"sims/ascii-character-map/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/ascii-character-map/#prerequisites","title":"Prerequisites","text":"<p>TODO: List prerequisites.</p>"},{"location":"sims/ascii-character-map/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): TODO</li> <li>Guided Practice (5 min): TODO</li> <li>Assessment (5 min): TODO</li> </ol>"},{"location":"sims/ascii-character-map/#assessment","title":"Assessment","text":"<p>TODO: List assessment criteria.</p>"},{"location":"sims/ascii-character-map/#references","title":"References","text":"<ol> <li>TODO: Add references.</li> </ol>"},{"location":"sims/binary-number-explorer/","title":"Binary Number Explorer","text":""},{"location":"sims/binary-number-explorer/#binary-number-explorer","title":"Binary Number Explorer","text":"<p>Run the Binary Number Explorer MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/binary-number-explorer/#about-this-microsim","title":"About This MicroSim","text":"<p>TODO: Describe what this MicroSim demonstrates.</p>"},{"location":"sims/binary-number-explorer/#how-to-use","title":"How to Use","text":"<p>TODO: Describe how students should interact with this MicroSim.</p>"},{"location":"sims/binary-number-explorer/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"450px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/binary-number-explorer/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/binary-number-explorer/#grade-level","title":"Grade Level","text":"<p>9-12 (High School Geometry)</p>"},{"location":"sims/binary-number-explorer/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/binary-number-explorer/#prerequisites","title":"Prerequisites","text":"<p>TODO: List prerequisites.</p>"},{"location":"sims/binary-number-explorer/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): TODO</li> <li>Guided Practice (5 min): TODO</li> <li>Assessment (5 min): TODO</li> </ol>"},{"location":"sims/binary-number-explorer/#assessment","title":"Assessment","text":"<p>TODO: List assessment criteria.</p>"},{"location":"sims/binary-number-explorer/#references","title":"References","text":"<ol> <li>TODO: Add references.</li> </ol>"},{"location":"sims/boolean-order-of-ops/","title":"Order of Operations Visualizer","text":""},{"location":"sims/boolean-order-of-ops/#order-of-operations-visualizer","title":"Order of Operations Visualizer","text":"<p>Run the Order of Operations Visualizer MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/boolean-order-of-ops/#about-this-microsim","title":"About This MicroSim","text":"<p>TODO: Describe what this MicroSim demonstrates.</p>"},{"location":"sims/boolean-order-of-ops/#how-to-use","title":"How to Use","text":"<p>TODO: Describe how students should interact with this MicroSim.</p>"},{"location":"sims/boolean-order-of-ops/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"450px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/boolean-order-of-ops/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/boolean-order-of-ops/#grade-level","title":"Grade Level","text":"<p>9-12 (High School Geometry)</p>"},{"location":"sims/boolean-order-of-ops/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/boolean-order-of-ops/#prerequisites","title":"Prerequisites","text":"<p>TODO: List prerequisites.</p>"},{"location":"sims/boolean-order-of-ops/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): TODO</li> <li>Guided Practice (5 min): TODO</li> <li>Assessment (5 min): TODO</li> </ol>"},{"location":"sims/boolean-order-of-ops/#assessment","title":"Assessment","text":"<p>TODO: List assessment criteria.</p>"},{"location":"sims/boolean-order-of-ops/#references","title":"References","text":"<ol> <li>TODO: Add references.</li> </ol>"},{"location":"sims/break-vs-continue/","title":"Break vs Continue Visualizer","text":""},{"location":"sims/break-vs-continue/#break-vs-continue-visualizer","title":"Break vs Continue Visualizer","text":"<p>Run the Break vs Continue Visualizer MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/break-vs-continue/#about-this-microsim","title":"About This MicroSim","text":"<p>TODO: Describe what this MicroSim demonstrates.</p>"},{"location":"sims/break-vs-continue/#how-to-use","title":"How to Use","text":"<p>TODO: Describe how students should interact with this MicroSim.</p>"},{"location":"sims/break-vs-continue/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"450px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/break-vs-continue/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/break-vs-continue/#grade-level","title":"Grade Level","text":"<p>9-12 (High School Geometry)</p>"},{"location":"sims/break-vs-continue/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/break-vs-continue/#prerequisites","title":"Prerequisites","text":"<p>TODO: List prerequisites.</p>"},{"location":"sims/break-vs-continue/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): TODO</li> <li>Guided Practice (5 min): TODO</li> <li>Assessment (5 min): TODO</li> </ol>"},{"location":"sims/break-vs-continue/#assessment","title":"Assessment","text":"<p>TODO: List assessment criteria.</p>"},{"location":"sims/break-vs-continue/#references","title":"References","text":"<ol> <li>TODO: Add references.</li> </ol>"},{"location":"sims/class-vs-object-diagram/","title":"Class vs. Object Visual","text":""},{"location":"sims/class-vs-object-diagram/#class-vs-object-visual","title":"Class vs. Object Visual","text":"<p>Run the Class vs. Object Visual MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/class-vs-object-diagram/#about-this-microsim","title":"About This MicroSim","text":"<p>This infographic-style MicroSim shows a Dog class as a blue cookie cutter on the left and multiple Dog objects as decorated cookies on the right. The shared template lists common attributes and methods, while arrows labeled \u201cinstantiation\u201d show how every dog object is pressed from the same blueprint. Hover and creation interactions reinforce the difference between structure and instance data.</p>"},{"location":"sims/class-vs-object-diagram/#how-to-use","title":"How to Use","text":"<ol> <li>Hover over the Dog class to highlight the shared structure every dog receives (attributes + methods).</li> <li>Hover over any cookie to spotlight that object\u2019s unique attribute values (name, breed, age).</li> <li>Click Create New Dog to watch a new cookie animate from the class, complete with randomly generated attributes and sprinkle colors.</li> <li>On narrow screens, scroll vertically to compare the blueprint and cookies stacked in a single column.</li> </ol>"},{"location":"sims/class-vs-object-diagram/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"450px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/class-vs-object-diagram/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/class-vs-object-diagram/#grade-level","title":"Grade Level","text":"<p>9-12 (Intro to Computer Science)</p>"},{"location":"sims/class-vs-object-diagram/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/class-vs-object-diagram/#prerequisites","title":"Prerequisites","text":"<ul> <li>Students have seen a basic Python (or Java) class definition.</li> <li>Students understand that attributes store data and methods describe behaviors.</li> <li>Students can read simple diagrams and hover tooltips.</li> </ul>"},{"location":"sims/class-vs-object-diagram/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): Students freely hover on the class and each cookie, capturing in their notes what is shared and what changes per object.</li> <li>Guided Practice (5 min): As a class, generate two additional dogs and narrate the instantiation process, connecting the on-screen animation to Python code (<code>Dog(...)</code>).</li> <li>Assessment (5 min): In pairs, students explain which pieces of information belong in the class definition versus the constructor call for one of the cookies.</li> </ol>"},{"location":"sims/class-vs-object-diagram/#assessment","title":"Assessment","text":"<ul> <li>Students can articulate that attributes/methods live on the class and values live on each object.</li> <li>Students can describe the instantiation arrow as \u201ccalling the class to create an object\u201d.</li> <li>Optional exit ticket: sketch their own class/object pair using a different real-world analogy.</li> </ul>"},{"location":"sims/class-vs-object-diagram/#references","title":"References","text":"<ol> <li>Runestone Academy, \u201cClasses and Objects,\u201d Problem Solving with Algorithms and Data Structures, 2024.</li> <li>Oracle, \u201cDefining Classes,\u201d Java Tutorials, Oracle University, 2023.</li> </ol>"},{"location":"sims/code-readability/","title":"Code Readability Comparison","text":""},{"location":"sims/code-readability/#code-readability-comparison","title":"Code Readability Comparison","text":"<p>Run the Code Readability Comparison MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/code-readability/#about-this-microsim","title":"About This MicroSim","text":"<p>TODO: Describe what this MicroSim demonstrates.</p>"},{"location":"sims/code-readability/#how-to-use","title":"How to Use","text":"<p>TODO: Describe how students should interact with this MicroSim.</p>"},{"location":"sims/code-readability/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"450px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/code-readability/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/code-readability/#grade-level","title":"Grade Level","text":"<p>9-12 (High School Geometry)</p>"},{"location":"sims/code-readability/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/code-readability/#prerequisites","title":"Prerequisites","text":"<p>TODO: List prerequisites.</p>"},{"location":"sims/code-readability/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): TODO</li> <li>Guided Practice (5 min): TODO</li> <li>Assessment (5 min): TODO</li> </ol>"},{"location":"sims/code-readability/#assessment","title":"Assessment","text":"<p>TODO: List assessment criteria.</p>"},{"location":"sims/code-readability/#references","title":"References","text":"<ol> <li>TODO: Add references.</li> </ol>"},{"location":"sims/comparison-operator-explorer/","title":"Comparison Operator Explorer","text":""},{"location":"sims/comparison-operator-explorer/#comparison-operator-explorer","title":"Comparison Operator Explorer","text":"<p>Run the Comparison Operator Explorer MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/comparison-operator-explorer/#about-this-microsim","title":"About This MicroSim","text":"<p>TODO: Describe what this MicroSim demonstrates.</p>"},{"location":"sims/comparison-operator-explorer/#how-to-use","title":"How to Use","text":"<p>TODO: Describe how students should interact with this MicroSim.</p>"},{"location":"sims/comparison-operator-explorer/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"450px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/comparison-operator-explorer/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/comparison-operator-explorer/#grade-level","title":"Grade Level","text":"<p>9-12 (High School Geometry)</p>"},{"location":"sims/comparison-operator-explorer/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/comparison-operator-explorer/#prerequisites","title":"Prerequisites","text":"<p>TODO: List prerequisites.</p>"},{"location":"sims/comparison-operator-explorer/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): TODO</li> <li>Guided Practice (5 min): TODO</li> <li>Assessment (5 min): TODO</li> </ol>"},{"location":"sims/comparison-operator-explorer/#assessment","title":"Assessment","text":"<p>TODO: List assessment criteria.</p>"},{"location":"sims/comparison-operator-explorer/#references","title":"References","text":"<ol> <li>TODO: Add references.</li> </ol>"},{"location":"sims/compiled-vs-interpreted/","title":"Compiled vs. Interpreted Languages","text":""},{"location":"sims/compiled-vs-interpreted/#compiled-vs-interpreted-languages","title":"Compiled vs. Interpreted Languages","text":"<p>Run the Compiled vs. Interpreted Languages MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/compiled-vs-interpreted/#about-this-microsim","title":"About This MicroSim","text":"<p>TODO: Describe what this MicroSim demonstrates.</p>"},{"location":"sims/compiled-vs-interpreted/#how-to-use","title":"How to Use","text":"<p>TODO: Describe how students should interact with this MicroSim.</p>"},{"location":"sims/compiled-vs-interpreted/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"520px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/compiled-vs-interpreted/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/compiled-vs-interpreted/#grade-level","title":"Grade Level","text":"<p>9-12 (High School Geometry)</p>"},{"location":"sims/compiled-vs-interpreted/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/compiled-vs-interpreted/#prerequisites","title":"Prerequisites","text":"<p>TODO: List prerequisites.</p>"},{"location":"sims/compiled-vs-interpreted/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): TODO</li> <li>Guided Practice (5 min): TODO</li> <li>Assessment (5 min): TODO</li> </ol>"},{"location":"sims/compiled-vs-interpreted/#assessment","title":"Assessment","text":"<p>TODO: List assessment criteria.</p>"},{"location":"sims/compiled-vs-interpreted/#references","title":"References","text":"<ol> <li>TODO: Add references.</li> </ol>"},{"location":"sims/computational-thinking-pillars/","title":"Computational Thinking Pillars","text":""},{"location":"sims/computational-thinking-pillars/#computational-thinking-pillars","title":"Computational Thinking Pillars","text":"<p>Run the Computational Thinking Pillars MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/computational-thinking-pillars/#about-this-microsim","title":"About This MicroSim","text":"<p>TODO: Describe what this MicroSim demonstrates.</p>"},{"location":"sims/computational-thinking-pillars/#how-to-use","title":"How to Use","text":"<p>TODO: Describe how students should interact with this MicroSim.</p>"},{"location":"sims/computational-thinking-pillars/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"450px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/computational-thinking-pillars/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/computational-thinking-pillars/#grade-level","title":"Grade Level","text":"<p>9-12 (High School Geometry)</p>"},{"location":"sims/computational-thinking-pillars/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/computational-thinking-pillars/#prerequisites","title":"Prerequisites","text":"<p>TODO: List prerequisites.</p>"},{"location":"sims/computational-thinking-pillars/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): TODO</li> <li>Guided Practice (5 min): TODO</li> <li>Assessment (5 min): TODO</li> </ol>"},{"location":"sims/computational-thinking-pillars/#assessment","title":"Assessment","text":"<p>TODO: List assessment criteria.</p>"},{"location":"sims/computational-thinking-pillars/#references","title":"References","text":"<ol> <li>TODO: Add references.</li> </ol>"},{"location":"sims/control-flow-patterns/","title":"Control Flow Patterns","text":""},{"location":"sims/control-flow-patterns/#control-flow-patterns","title":"Control Flow Patterns","text":"<p>Run the Control Flow Patterns MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/control-flow-patterns/#about-this-microsim","title":"About This MicroSim","text":"<p>TODO: Describe what this MicroSim demonstrates.</p>"},{"location":"sims/control-flow-patterns/#how-to-use","title":"How to Use","text":"<p>TODO: Describe how students should interact with this MicroSim.</p>"},{"location":"sims/control-flow-patterns/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"450px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/control-flow-patterns/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/control-flow-patterns/#grade-level","title":"Grade Level","text":"<p>9-12 (High School Geometry)</p>"},{"location":"sims/control-flow-patterns/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/control-flow-patterns/#prerequisites","title":"Prerequisites","text":"<p>TODO: List prerequisites.</p>"},{"location":"sims/control-flow-patterns/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): TODO</li> <li>Guided Practice (5 min): TODO</li> <li>Assessment (5 min): TODO</li> </ol>"},{"location":"sims/control-flow-patterns/#assessment","title":"Assessment","text":"<p>TODO: List assessment criteria.</p>"},{"location":"sims/control-flow-patterns/#references","title":"References","text":"<ol> <li>TODO: Add references.</li> </ol>"},{"location":"sims/demorgans-laws/","title":"De Morgan's Laws Visualizer","text":""},{"location":"sims/demorgans-laws/#de-morgans-laws-visualizer","title":"De Morgan's Laws Visualizer","text":"<p>Run the De Morgan's Laws Visualizer MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/demorgans-laws/#about-this-microsim","title":"About This MicroSim","text":"<p>TODO: Describe what this MicroSim demonstrates.</p>"},{"location":"sims/demorgans-laws/#how-to-use","title":"How to Use","text":"<p>TODO: Describe how students should interact with this MicroSim.</p>"},{"location":"sims/demorgans-laws/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"450px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/demorgans-laws/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/demorgans-laws/#grade-level","title":"Grade Level","text":"<p>9-12 (High School Geometry)</p>"},{"location":"sims/demorgans-laws/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/demorgans-laws/#prerequisites","title":"Prerequisites","text":"<p>TODO: List prerequisites.</p>"},{"location":"sims/demorgans-laws/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): TODO</li> <li>Guided Practice (5 min): TODO</li> <li>Assessment (5 min): TODO</li> </ol>"},{"location":"sims/demorgans-laws/#assessment","title":"Assessment","text":"<p>TODO: List assessment criteria.</p>"},{"location":"sims/demorgans-laws/#references","title":"References","text":"<ol> <li>TODO: Add references.</li> </ol>"},{"location":"sims/expressions-vs-statements/","title":"Expressions vs. Statements","text":""},{"location":"sims/expressions-vs-statements/#expressions-vs-statements","title":"Expressions vs. Statements","text":"<p>Run the Expressions vs. Statements MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/expressions-vs-statements/#about-this-microsim","title":"About This MicroSim","text":"<p>TODO: Describe what this MicroSim demonstrates.</p>"},{"location":"sims/expressions-vs-statements/#how-to-use","title":"How to Use","text":"<p>TODO: Describe how students should interact with this MicroSim.</p>"},{"location":"sims/expressions-vs-statements/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"450px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/expressions-vs-statements/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/expressions-vs-statements/#grade-level","title":"Grade Level","text":"<p>9-12 (High School Geometry)</p>"},{"location":"sims/expressions-vs-statements/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/expressions-vs-statements/#prerequisites","title":"Prerequisites","text":"<p>TODO: List prerequisites.</p>"},{"location":"sims/expressions-vs-statements/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): TODO</li> <li>Guided Practice (5 min): TODO</li> <li>Assessment (5 min): TODO</li> </ol>"},{"location":"sims/expressions-vs-statements/#assessment","title":"Assessment","text":"<p>TODO: List assessment criteria.</p>"},{"location":"sims/expressions-vs-statements/#references","title":"References","text":"<ol> <li>TODO: Add references.</li> </ol>"},{"location":"sims/if-elif-else-flowchart/","title":"If-Elif-Else Flowchart","text":""},{"location":"sims/if-elif-else-flowchart/#if-elif-else-flowchart","title":"If-Elif-Else Flowchart","text":"<p>Run the If-Elif-Else Flowchart MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/if-elif-else-flowchart/#about-this-microsim","title":"About This MicroSim","text":"<p>TODO: Describe what this MicroSim demonstrates.</p>"},{"location":"sims/if-elif-else-flowchart/#how-to-use","title":"How to Use","text":"<p>TODO: Describe how students should interact with this MicroSim.</p>"},{"location":"sims/if-elif-else-flowchart/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"450px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/if-elif-else-flowchart/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/if-elif-else-flowchart/#grade-level","title":"Grade Level","text":"<p>9-12 (High School Geometry)</p>"},{"location":"sims/if-elif-else-flowchart/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/if-elif-else-flowchart/#prerequisites","title":"Prerequisites","text":"<p>TODO: List prerequisites.</p>"},{"location":"sims/if-elif-else-flowchart/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): TODO</li> <li>Guided Practice (5 min): TODO</li> <li>Assessment (5 min): TODO</li> </ol>"},{"location":"sims/if-elif-else-flowchart/#assessment","title":"Assessment","text":"<p>TODO: List assessment criteria.</p>"},{"location":"sims/if-elif-else-flowchart/#references","title":"References","text":"<ol> <li>TODO: Add references.</li> </ol>"},{"location":"sims/inside-a-computer/","title":"Inside a Computer","text":""},{"location":"sims/inside-a-computer/#inside-a-computer","title":"Inside a Computer","text":"<p>Run the Inside a Computer MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/inside-a-computer/#about-this-microsim","title":"About This MicroSim","text":"<p>TODO: Describe what this MicroSim demonstrates.</p>"},{"location":"sims/inside-a-computer/#how-to-use","title":"How to Use","text":"<p>TODO: Describe how students should interact with this MicroSim.</p>"},{"location":"sims/inside-a-computer/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"450px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/inside-a-computer/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/inside-a-computer/#grade-level","title":"Grade Level","text":"<p>9-12 (High School Geometry)</p>"},{"location":"sims/inside-a-computer/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/inside-a-computer/#prerequisites","title":"Prerequisites","text":"<p>TODO: List prerequisites.</p>"},{"location":"sims/inside-a-computer/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): TODO</li> <li>Guided Practice (5 min): TODO</li> <li>Assessment (5 min): TODO</li> </ol>"},{"location":"sims/inside-a-computer/#assessment","title":"Assessment","text":"<p>TODO: List assessment criteria.</p>"},{"location":"sims/inside-a-computer/#references","title":"References","text":"<ol> <li>TODO: Add references.</li> </ol>"},{"location":"sims/logical-operator-venn/","title":"Logical Operator Venn Diagrams","text":""},{"location":"sims/logical-operator-venn/#logical-operator-venn-diagrams","title":"Logical Operator Venn Diagrams","text":"<p>Run the Logical Operator Venn Diagrams MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/logical-operator-venn/#about-this-microsim","title":"About This MicroSim","text":"<p>TODO: Describe what this MicroSim demonstrates.</p>"},{"location":"sims/logical-operator-venn/#how-to-use","title":"How to Use","text":"<p>TODO: Describe how students should interact with this MicroSim.</p>"},{"location":"sims/logical-operator-venn/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"450px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/logical-operator-venn/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/logical-operator-venn/#grade-level","title":"Grade Level","text":"<p>9-12 (High School Geometry)</p>"},{"location":"sims/logical-operator-venn/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/logical-operator-venn/#prerequisites","title":"Prerequisites","text":"<p>TODO: List prerequisites.</p>"},{"location":"sims/logical-operator-venn/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): TODO</li> <li>Guided Practice (5 min): TODO</li> <li>Assessment (5 min): TODO</li> </ol>"},{"location":"sims/logical-operator-venn/#assessment","title":"Assessment","text":"<p>TODO: List assessment criteria.</p>"},{"location":"sims/logical-operator-venn/#references","title":"References","text":"<ol> <li>TODO: Add references.</li> </ol>"},{"location":"sims/loop-patterns-comparison/","title":"Loop Patterns Comparison","text":""},{"location":"sims/loop-patterns-comparison/#loop-patterns-comparison","title":"Loop Patterns Comparison","text":"<p>Run the Loop Patterns Comparison MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/loop-patterns-comparison/#about-this-microsim","title":"About This MicroSim","text":"<p>TODO: Describe what this MicroSim demonstrates.</p>"},{"location":"sims/loop-patterns-comparison/#how-to-use","title":"How to Use","text":"<p>TODO: Describe how students should interact with this MicroSim.</p>"},{"location":"sims/loop-patterns-comparison/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"450px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/loop-patterns-comparison/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/loop-patterns-comparison/#grade-level","title":"Grade Level","text":"<p>9-12 (High School Geometry)</p>"},{"location":"sims/loop-patterns-comparison/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/loop-patterns-comparison/#prerequisites","title":"Prerequisites","text":"<p>TODO: List prerequisites.</p>"},{"location":"sims/loop-patterns-comparison/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): TODO</li> <li>Guided Practice (5 min): TODO</li> <li>Assessment (5 min): TODO</li> </ol>"},{"location":"sims/loop-patterns-comparison/#assessment","title":"Assessment","text":"<p>TODO: List assessment criteria.</p>"},{"location":"sims/loop-patterns-comparison/#references","title":"References","text":"<ol> <li>TODO: Add references.</li> </ol>"},{"location":"sims/nested-loop-grid/","title":"Nested Loop Grid Visualizer","text":""},{"location":"sims/nested-loop-grid/#nested-loop-grid-visualizer","title":"Nested Loop Grid Visualizer","text":"<p>Run the Nested Loop Grid Visualizer MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/nested-loop-grid/#about-this-microsim","title":"About This MicroSim","text":"<p>TODO: Describe what this MicroSim demonstrates.</p>"},{"location":"sims/nested-loop-grid/#how-to-use","title":"How to Use","text":"<p>TODO: Describe how students should interact with this MicroSim.</p>"},{"location":"sims/nested-loop-grid/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"450px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/nested-loop-grid/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/nested-loop-grid/#grade-level","title":"Grade Level","text":"<p>9-12 (High School Geometry)</p>"},{"location":"sims/nested-loop-grid/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/nested-loop-grid/#prerequisites","title":"Prerequisites","text":"<p>TODO: List prerequisites.</p>"},{"location":"sims/nested-loop-grid/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): TODO</li> <li>Guided Practice (5 min): TODO</li> <li>Assessment (5 min): TODO</li> </ol>"},{"location":"sims/nested-loop-grid/#assessment","title":"Assessment","text":"<p>TODO: List assessment criteria.</p>"},{"location":"sims/nested-loop-grid/#references","title":"References","text":"<ol> <li>TODO: Add references.</li> </ol>"},{"location":"sims/palindrome-checker/","title":"Palindrome Checker","text":""},{"location":"sims/palindrome-checker/#palindrome-checker","title":"Palindrome Checker","text":"<p>Run the Palindrome Checker MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/palindrome-checker/#about-this-microsim","title":"About This MicroSim","text":"<p>TODO: Describe what this MicroSim demonstrates.</p>"},{"location":"sims/palindrome-checker/#how-to-use","title":"How to Use","text":"<p>TODO: Describe how students should interact with this MicroSim.</p>"},{"location":"sims/palindrome-checker/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"450px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/palindrome-checker/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/palindrome-checker/#grade-level","title":"Grade Level","text":"<p>9-12 (High School Geometry)</p>"},{"location":"sims/palindrome-checker/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/palindrome-checker/#prerequisites","title":"Prerequisites","text":"<p>TODO: List prerequisites.</p>"},{"location":"sims/palindrome-checker/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): TODO</li> <li>Guided Practice (5 min): TODO</li> <li>Assessment (5 min): TODO</li> </ol>"},{"location":"sims/palindrome-checker/#assessment","title":"Assessment","text":"<p>TODO: List assessment criteria.</p>"},{"location":"sims/palindrome-checker/#references","title":"References","text":"<ol> <li>TODO: Add references.</li> </ol>"},{"location":"sims/python-data-types/","title":"Python Data Types Overview","text":""},{"location":"sims/python-data-types/#python-data-types-overview","title":"Python Data Types Overview","text":"<p>Run the Python Data Types Overview MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/python-data-types/#about-this-microsim","title":"About This MicroSim","text":"<p>TODO: Describe what this MicroSim demonstrates.</p>"},{"location":"sims/python-data-types/#how-to-use","title":"How to Use","text":"<p>TODO: Describe how students should interact with this MicroSim.</p>"},{"location":"sims/python-data-types/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"450px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/python-data-types/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/python-data-types/#grade-level","title":"Grade Level","text":"<p>9-12 (High School Geometry)</p>"},{"location":"sims/python-data-types/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/python-data-types/#prerequisites","title":"Prerequisites","text":"<p>TODO: List prerequisites.</p>"},{"location":"sims/python-data-types/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): TODO</li> <li>Guided Practice (5 min): TODO</li> <li>Assessment (5 min): TODO</li> </ol>"},{"location":"sims/python-data-types/#assessment","title":"Assessment","text":"<p>TODO: List assessment criteria.</p>"},{"location":"sims/python-data-types/#references","title":"References","text":"<ol> <li>TODO: Add references.</li> </ol>"},{"location":"sims/range-function-explorer/","title":"Range Function Explorer","text":""},{"location":"sims/range-function-explorer/#range-function-explorer","title":"Range Function Explorer","text":"<p>Run the Range Function Explorer MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/range-function-explorer/#about-this-microsim","title":"About This MicroSim","text":"<p>TODO: Describe what this MicroSim demonstrates.</p>"},{"location":"sims/range-function-explorer/#how-to-use","title":"How to Use","text":"<p>TODO: Describe how students should interact with this MicroSim.</p>"},{"location":"sims/range-function-explorer/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"450px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/range-function-explorer/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/range-function-explorer/#grade-level","title":"Grade Level","text":"<p>9-12 (High School Geometry)</p>"},{"location":"sims/range-function-explorer/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/range-function-explorer/#prerequisites","title":"Prerequisites","text":"<p>TODO: List prerequisites.</p>"},{"location":"sims/range-function-explorer/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): TODO</li> <li>Guided Practice (5 min): TODO</li> <li>Assessment (5 min): TODO</li> </ol>"},{"location":"sims/range-function-explorer/#assessment","title":"Assessment","text":"<p>TODO: List assessment criteria.</p>"},{"location":"sims/range-function-explorer/#references","title":"References","text":"<ol> <li>TODO: Add references.</li> </ol>"},{"location":"sims/repl-vs-scripts/","title":"Python REPL vs. Scripts","text":""},{"location":"sims/repl-vs-scripts/#python-repl-vs-scripts","title":"Python REPL vs. Scripts","text":"<p>Run the Python REPL vs. Scripts MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/repl-vs-scripts/#about-this-microsim","title":"About This MicroSim","text":"<p>TODO: Describe what this MicroSim demonstrates.</p>"},{"location":"sims/repl-vs-scripts/#how-to-use","title":"How to Use","text":"<p>TODO: Describe how students should interact with this MicroSim.</p>"},{"location":"sims/repl-vs-scripts/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"660px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/repl-vs-scripts/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/repl-vs-scripts/#grade-level","title":"Grade Level","text":"<p>9-12 (High School Geometry)</p>"},{"location":"sims/repl-vs-scripts/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/repl-vs-scripts/#prerequisites","title":"Prerequisites","text":"<p>TODO: List prerequisites.</p>"},{"location":"sims/repl-vs-scripts/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): TODO</li> <li>Guided Practice (5 min): TODO</li> <li>Assessment (5 min): TODO</li> </ol>"},{"location":"sims/repl-vs-scripts/#assessment","title":"Assessment","text":"<p>TODO: List assessment criteria.</p>"},{"location":"sims/repl-vs-scripts/#references","title":"References","text":"<ol> <li>TODO: Add references.</li> </ol>"},{"location":"sims/split-join-visualizer/","title":"Split and Join Visualizer","text":""},{"location":"sims/split-join-visualizer/#split-and-join-visualizer","title":"Split and Join Visualizer","text":"<p>Run the Split and Join Visualizer MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/split-join-visualizer/#about-this-microsim","title":"About This MicroSim","text":"<p>TODO: Describe what this MicroSim demonstrates.</p>"},{"location":"sims/split-join-visualizer/#how-to-use","title":"How to Use","text":"<p>TODO: Describe how students should interact with this MicroSim.</p>"},{"location":"sims/split-join-visualizer/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"450px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/split-join-visualizer/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/split-join-visualizer/#grade-level","title":"Grade Level","text":"<p>9-12 (High School Geometry)</p>"},{"location":"sims/split-join-visualizer/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/split-join-visualizer/#prerequisites","title":"Prerequisites","text":"<p>TODO: List prerequisites.</p>"},{"location":"sims/split-join-visualizer/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): TODO</li> <li>Guided Practice (5 min): TODO</li> <li>Assessment (5 min): TODO</li> </ol>"},{"location":"sims/split-join-visualizer/#assessment","title":"Assessment","text":"<p>TODO: List assessment criteria.</p>"},{"location":"sims/split-join-visualizer/#references","title":"References","text":"<ol> <li>TODO: Add references.</li> </ol>"},{"location":"sims/string-formatting-comparison/","title":"String Formatting Comparison","text":""},{"location":"sims/string-formatting-comparison/#string-formatting-comparison","title":"String Formatting Comparison","text":"<p>Run the String Formatting Comparison MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/string-formatting-comparison/#about-this-microsim","title":"About This MicroSim","text":"<p>TODO: Describe what this MicroSim demonstrates.</p>"},{"location":"sims/string-formatting-comparison/#how-to-use","title":"How to Use","text":"<p>TODO: Describe how students should interact with this MicroSim.</p>"},{"location":"sims/string-formatting-comparison/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"450px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/string-formatting-comparison/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/string-formatting-comparison/#grade-level","title":"Grade Level","text":"<p>9-12 (High School Geometry)</p>"},{"location":"sims/string-formatting-comparison/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/string-formatting-comparison/#prerequisites","title":"Prerequisites","text":"<p>TODO: List prerequisites.</p>"},{"location":"sims/string-formatting-comparison/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): TODO</li> <li>Guided Practice (5 min): TODO</li> <li>Assessment (5 min): TODO</li> </ol>"},{"location":"sims/string-formatting-comparison/#assessment","title":"Assessment","text":"<p>TODO: List assessment criteria.</p>"},{"location":"sims/string-formatting-comparison/#references","title":"References","text":"<ol> <li>TODO: Add references.</li> </ol>"},{"location":"sims/string-indexing-visualizer/","title":"String Indexing Visualizer","text":""},{"location":"sims/string-indexing-visualizer/#string-indexing-visualizer","title":"String Indexing Visualizer","text":"<p>Run the String Indexing Visualizer MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/string-indexing-visualizer/#about-this-microsim","title":"About This MicroSim","text":"<p>TODO: Describe what this MicroSim demonstrates.</p>"},{"location":"sims/string-indexing-visualizer/#how-to-use","title":"How to Use","text":"<p>TODO: Describe how students should interact with this MicroSim.</p>"},{"location":"sims/string-indexing-visualizer/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"450px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/string-indexing-visualizer/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/string-indexing-visualizer/#grade-level","title":"Grade Level","text":"<p>9-12 (High School Geometry)</p>"},{"location":"sims/string-indexing-visualizer/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/string-indexing-visualizer/#prerequisites","title":"Prerequisites","text":"<p>TODO: List prerequisites.</p>"},{"location":"sims/string-indexing-visualizer/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): TODO</li> <li>Guided Practice (5 min): TODO</li> <li>Assessment (5 min): TODO</li> </ol>"},{"location":"sims/string-indexing-visualizer/#assessment","title":"Assessment","text":"<p>TODO: List assessment criteria.</p>"},{"location":"sims/string-indexing-visualizer/#references","title":"References","text":"<ol> <li>TODO: Add references.</li> </ol>"},{"location":"sims/string-methods-explorer/","title":"String Methods Explorer","text":""},{"location":"sims/string-methods-explorer/#string-methods-explorer","title":"String Methods Explorer","text":"<p>Run the String Methods Explorer MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/string-methods-explorer/#about-this-microsim","title":"About This MicroSim","text":"<p>TODO: Describe what this MicroSim demonstrates.</p>"},{"location":"sims/string-methods-explorer/#how-to-use","title":"How to Use","text":"<p>TODO: Describe how students should interact with this MicroSim.</p>"},{"location":"sims/string-methods-explorer/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"450px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/string-methods-explorer/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/string-methods-explorer/#grade-level","title":"Grade Level","text":"<p>9-12 (High School Geometry)</p>"},{"location":"sims/string-methods-explorer/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/string-methods-explorer/#prerequisites","title":"Prerequisites","text":"<p>TODO: List prerequisites.</p>"},{"location":"sims/string-methods-explorer/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): TODO</li> <li>Guided Practice (5 min): TODO</li> <li>Assessment (5 min): TODO</li> </ol>"},{"location":"sims/string-methods-explorer/#assessment","title":"Assessment","text":"<p>TODO: List assessment criteria.</p>"},{"location":"sims/string-methods-explorer/#references","title":"References","text":"<ol> <li>TODO: Add references.</li> </ol>"},{"location":"sims/string-operations/","title":"String Operations Playground","text":""},{"location":"sims/string-operations/#string-operations-playground","title":"String Operations Playground","text":"<p>Run the String Operations Playground MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/string-operations/#about-this-microsim","title":"About This MicroSim","text":"<p>TODO: Describe what this MicroSim demonstrates.</p>"},{"location":"sims/string-operations/#how-to-use","title":"How to Use","text":"<p>TODO: Describe how students should interact with this MicroSim.</p>"},{"location":"sims/string-operations/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"450px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/string-operations/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/string-operations/#grade-level","title":"Grade Level","text":"<p>9-12 (High School Geometry)</p>"},{"location":"sims/string-operations/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/string-operations/#prerequisites","title":"Prerequisites","text":"<p>TODO: List prerequisites.</p>"},{"location":"sims/string-operations/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): TODO</li> <li>Guided Practice (5 min): TODO</li> <li>Assessment (5 min): TODO</li> </ol>"},{"location":"sims/string-operations/#assessment","title":"Assessment","text":"<p>TODO: List assessment criteria.</p>"},{"location":"sims/string-operations/#references","title":"References","text":"<ol> <li>TODO: Add references.</li> </ol>"},{"location":"sims/string-slicing-playground/","title":"String Slicing Playground","text":""},{"location":"sims/string-slicing-playground/#string-slicing-playground","title":"String Slicing Playground","text":"<p>Run the String Slicing Playground MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/string-slicing-playground/#about-this-microsim","title":"About This MicroSim","text":"<p>TODO: Describe what this MicroSim demonstrates.</p>"},{"location":"sims/string-slicing-playground/#how-to-use","title":"How to Use","text":"<p>TODO: Describe how students should interact with this MicroSim.</p>"},{"location":"sims/string-slicing-playground/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"450px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/string-slicing-playground/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/string-slicing-playground/#grade-level","title":"Grade Level","text":"<p>9-12 (High School Geometry)</p>"},{"location":"sims/string-slicing-playground/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/string-slicing-playground/#prerequisites","title":"Prerequisites","text":"<p>TODO: List prerequisites.</p>"},{"location":"sims/string-slicing-playground/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): TODO</li> <li>Guided Practice (5 min): TODO</li> <li>Assessment (5 min): TODO</li> </ol>"},{"location":"sims/string-slicing-playground/#assessment","title":"Assessment","text":"<p>TODO: List assessment criteria.</p>"},{"location":"sims/string-slicing-playground/#references","title":"References","text":"<ol> <li>TODO: Add references.</li> </ol>"},{"location":"sims/truth-table-builder/","title":"Interactive Truth Table Builder","text":""},{"location":"sims/truth-table-builder/#interactive-truth-table-builder","title":"Interactive Truth Table Builder","text":"<p>Run the Interactive Truth Table Builder MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/truth-table-builder/#about-this-microsim","title":"About This MicroSim","text":"<p>TODO: Describe what this MicroSim demonstrates.</p>"},{"location":"sims/truth-table-builder/#how-to-use","title":"How to Use","text":"<p>TODO: Describe how students should interact with this MicroSim.</p>"},{"location":"sims/truth-table-builder/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"450px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/truth-table-builder/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/truth-table-builder/#grade-level","title":"Grade Level","text":"<p>9-12 (High School Geometry)</p>"},{"location":"sims/truth-table-builder/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/truth-table-builder/#prerequisites","title":"Prerequisites","text":"<p>TODO: List prerequisites.</p>"},{"location":"sims/truth-table-builder/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): TODO</li> <li>Guided Practice (5 min): TODO</li> <li>Assessment (5 min): TODO</li> </ol>"},{"location":"sims/truth-table-builder/#assessment","title":"Assessment","text":"<p>TODO: List assessment criteria.</p>"},{"location":"sims/truth-table-builder/#references","title":"References","text":"<ol> <li>TODO: Add references.</li> </ol>"},{"location":"sims/truthiness-tester/","title":"Truthiness Tester","text":""},{"location":"sims/truthiness-tester/#truthiness-tester","title":"Truthiness Tester","text":"<p>Run the Truthiness Tester MicroSim Fullscreen Edit in the p5.js Editor</p>"},{"location":"sims/truthiness-tester/#about-this-microsim","title":"About This MicroSim","text":"<p>TODO: Describe what this MicroSim demonstrates.</p>"},{"location":"sims/truthiness-tester/#how-to-use","title":"How to Use","text":"<p>TODO: Describe how students should interact with this MicroSim.</p>"},{"location":"sims/truthiness-tester/#iframe-embed-code","title":"Iframe Embed Code","text":"<pre><code>&lt;iframe src=\"main.html\"\n        height=\"450px\"\n        width=\"100%\"\n        scrolling=\"no\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"sims/truthiness-tester/#lesson-plan","title":"Lesson Plan","text":""},{"location":"sims/truthiness-tester/#grade-level","title":"Grade Level","text":"<p>9-12 (High School Geometry)</p>"},{"location":"sims/truthiness-tester/#duration","title":"Duration","text":"<p>10-15 minutes</p>"},{"location":"sims/truthiness-tester/#prerequisites","title":"Prerequisites","text":"<p>TODO: List prerequisites.</p>"},{"location":"sims/truthiness-tester/#activities","title":"Activities","text":"<ol> <li>Exploration (5 min): TODO</li> <li>Guided Practice (5 min): TODO</li> <li>Assessment (5 min): TODO</li> </ol>"},{"location":"sims/truthiness-tester/#assessment","title":"Assessment","text":"<p>TODO: List assessment criteria.</p>"},{"location":"sims/truthiness-tester/#references","title":"References","text":"<ol> <li>TODO: Add references.</li> </ol>"}]}